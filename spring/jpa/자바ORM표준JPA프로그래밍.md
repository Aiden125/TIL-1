# 자바 ORM 표준 JPA

## 1 장

* 객체 모델과 관계형 데이터베이스 모델은 지향하는 패러다임이 서로 다르다
* 문제는 이 패러다임의 차이를 극복하려고 개발자가 너무 많은 시간과 코드를 소비한다는 점이다
* 더 어려운 문제는 객체지향 어플리케이션답게 정교한 객체 모델릴ㅇ을 할 수록 패러다임의 불일치 문제가 더 커진다는 점이다
* 그리고 이 틈을 메우기 위해 개발자가 소모해야하는 비용도 점점 많아진다
* 결국 객체 모딜링은 힘을 잃고 점점 데이터 중심의 모델로 변해간다
* 이러한 패러다임의 불일치를 해결해주고 정료한 객체 모델링을 유지하게 도와주는 것이 JPA다

## 2 장

### 어노테이션

#### @Entity
* 이 클래스를 테이블과 매핑한다고 JPA에게 알려준다. 이롷게 @Entity가 사용된 클래스를 엔티티 클래스라 한다.
#### @executable
* 엔티티 클래스에 매핑할 테이블 정보를 알려준다. 이 어노테이션을 생략하면 클래스 이름을 테이블 이름오 매핑한다

#### @Id
* 엔티티 클래스의 필트를 테이블의 기본 키에 매핑한다 여기서 엔티티의 id 필트를 테이블의 id 기본 키 칼럼에 매핑한다.

#### @Column
* 필드를 컬럼에 매핑한다. 여기서는 name 속성을 사용해서 Member 엔티티의 username 필드를 Member 테이블의 name 칼럼에 매핑

#### 매핑 정보가 없는 필드
* 특정 필드에 매핑 어노테이션이 없을 경우 필드 명으로 칼럼명을 매핑한다. 데이터 베이스가 대소문자를 구분하는 경우도 있으니 명시적으로 선언하는것이 바람직하다.

### 2.6 엔티티 매니저 설정

#### 엔티티 매니저 팩토리 생성

* JPA를 동작시키키 위한 기반 객체를 만들고 JPA 구현체에 따라서 데이터베이스 컨넥션 풀도 생성하므로 엔티티 매니저 팩토리를 생성하는 비용은 아주 크다. 따라서 엔티티 매니저 팩토리는 애플리케이션 전체에서 딱 한번만 생성하고 귱유 해서 사용해야 한다.

#### 엔티티 매니저 생성
* 엔티티 매니저를 사용해서 엔티티를 데이터 베이스에 등록/수정/삭제/조회할 수 있다.
* 엔티티 매니저는 데이터베이스 컨넥션과 밀접한 관계가 있음으로 스레드간에 공유하거나 재사용하면 안된다.

#### JPQL

* JPA를 사용하면 애플리케이션 개발자는 앤티티 객체를 중심으로 개발하고 데이터베이스에 대한 처리는 JPA에 맡겨야 한다.
* JPA는 JPQL 이라는 쿼리 언어로 검색 조건이 포함된 SQL를 만들어준다.

* JPQL 과 SQL
	- JPQL은 엔티티 객체를 대상으로 쿼리한다. 쉽게 이야기해서 클래스와 필드를 대상으로 쿼리한다.
	- SQL은 데이터베이스 테이블을 대상으로 쿼리한다.

## 3 영속성 관리

* JPA가 제공하는 기능은 크게 엔티티와 테이블을 매핑하는 설계 부분과 매핑한 엔티티를 실제 사용하는 부분으로 나눌 수 있다.
* 이 장에서는 매핑한 엔티티를 엔티티 매니저를 통해 어떻게 사용되는지 알아보자
* 엔티티 매니저는 엔티티를 저장하고, 수종하고, 삭제하고, 조회하는 등 엔티티와 관련된 모든 일을 처리한다.
* 개발자 입장에서 엔티티 매니저는 엔티티를 저장하는 가상의 데이터베이스로 생각하면 된다.

### 엔티티 매니저 팩토리
* 엔티티 매니저 팩토리는 이름 그대로 엔티티 매니저를 만드는 공장인데, 공장을 만드는 비용은 상당히 크다. 따라서 한 개만 만들어서 애플리케이션 전체에서 귱유 할 수있도록 설계되어 있다.
* 반면 공장에서 엔티티 매니저를 생성하는 비용은 거의 들지 않는다.
* 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전함으로 서로 다른 스레드 간에 용유해도 되지만, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유 하면 안된다.

### 영속성 컨텐스트
* JPA를 이애하는 데 가장 우용한 용어는 욕속성 컨텐스트 이다
* 우리 말로 굳이 번역하자면 엔티티를 영구 저장하는 환경 이라는 뜻이다.
* 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.

### 엔티티의 생명주기
* 비영속 : 영속성 컨텐스트와 전혀 관계가 없는 상태
* 영속: 영속성 컨텍스트에 저장된 상태
* 준영속: 영속성 컨텍스트에 저장되어있다가 분리된 상태
* 삭제: 삭제된 상태

#### 비영속

* 엔티티 객체를 생성했다. 지금은 순수한 객체 상태이며 아직 저장하지 않았다. 따라서 용속성 컨텍스트나 데이터베이스와는 전혀 관련이 없다. 이것을 비용속성 상태라 한다.

#### 영속
* 엔티티 매니저를 통해서 엔티티를 용속성 컨텐스트에 저쟁했다. 이렇게 영속성 컨텐스트가 관리하는 엔티티를 영속 상태라 한다.
* 결국 양속 상태라는 것은 영속성 컨텐스트에 의해 관리된다는 뜻이다.

#### 준영속
* 용속성 컨텐스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다.
* 특정 엔티티를 중영속 상태로 만들려면 `em.detach()`를 호출하면된다. `em.close()`를 호출해서 영속성 컨텐스트를 닫거나 `em.clear()`를 호출해서 영속성 컨텍스트를 초기화해도 영속성 컨텍스트가관리하던 영속 상태의 엔티티는 중영속 상태가 된다.

#### 삭제
* 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제 한다.

### 영속성 컨텍스트의 특징

* 영속성 컨텍스트와 식별자 값
	- 영속성 컨텍스트는 엔티티를 식별자 값(@Id로 테이블의 기본 키와 매핑한 값)으로 구분한다.
	- **영속 상태는 식별자 값이 반드시 있어야한다.** 식별자 값이 없으면 예외가 발생한다.
* 영속성ㅇ 컨텍스트와 데이터베이스 저장
	- 영속성 컨텍스트에 엔티티를 저장하면 이 엔티티는 언제 데이터베이스에 저장될까? JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텐스트에서 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 플러시(flush)라 한다.

* 영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 있다.
	* 1차 캐시
	* 동일성 보장
	* 트랜잭션을 지원하는 쓰기 지연
	* 변경 감지
	* 지연 로딩

#### 엔티티 조회
* 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 기것을 1차 캐시라 한다. 영속 상태의 엔티티는 모두 이곳에 저장된다.
* 쉽게 이야기하면 영속성 컨텍스트 내부에 Map이 하나 있는데 키는 @Id로 매핑한 식별자 값은 엔티티 인스턴스이다.

#### 데이터베이스에서 조회
* 만약 em.find()를 호출했는데 엔티티가 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성한다. 그리고 1차 ㅋ캐시에서 저장한 후에 영속상 앤티티를 반환한다.

#### 영속 엔티티의 동일성 보장

```java
Member a = em.find(Memeber.class, "memeber1");
Member b = em.find(Memeber.class, "memeber1");

System.out.println(a == b);
```
* 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다 따라서 둘은 같은 인스턴스고 결과는 당연히 참이다.
* **따라서 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.**

### 엔티티 등록

```java
EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();

transaction.begin();

em.persist(memeberA);
em.persist(memeberB);

transaction.commit();
```
* 엔티티 매니저는 트랜잭션을 커밋하기 전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 차곡차곡 모아둔다.
* 그리고 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내는데 이것을 트랜잭션을 지원하는 쓰기 지연이라 한다.


### 엔티티 수정
* 변경 쿼리를 매번 만들어야함
	- 이름 변경, 등급 변경 쿼리 한번 한벌 필요 할 케이스

* JAP로 엔티티를 수정할 떄는 단순히 엔티티를 조회해서 데이터만 변경하면 된다

#### 변경 감지 순서
1. 트랜잭션을 커밋하면 엔티티 매니저 내부에서 먼저 플러시가 호출된다
2. 엔티티와 스냅샵을 비교해서 변경된 엔티티를 찾는다.
3. 변경된 엔티티가 있으면 수정 쿼리르 생성해서 쓰기 지연 SQL 저장소에 보낸다
4. 쓰기 지연 저장소위 SQL을 데이터베이스에 보낸다
5. 데이터베이스 트랜잭션을 커밋한다.

#### 중요
* 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다. 비용속, 준용석 처럼 영속성 컨텐스트의 관리를 받지 못하는 엔티티는 값을 변경해도 데이터베이스에 반영되지 않는다.

#### 엔티티의 모든 필드를 업데이트한다.
* 모든 필드를 사용하면 수정 쿼리가 항상 같다. 따라서 애플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용할 수 있다.
* 데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한 번 파싱된 쿼리를 재사용할 수 있다.
* 필드가 많거나 저장되는 내용이 너무 크면 수정된 데이터만 사용해서 동적으로 UPDATE  SQL을 생성하는 전략을 선택하면된다.
	- @org.hibernate.annotions.DynamicUpdate


### 플러시

* 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다

#### 플러시 작업 순서
1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
2. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.(등록 수정 삭제 쿼리)

#### 영속성 컨텍스트를 플러시하는 방법은 3가지이다.
1. em.flush()를 직접 호출
2. 트랜잭션 커밋 시 플러시가 자동 호출된다.
3. JPQL 쿼리 실행시 플러시가 자동 호출된다.

#### 플러시의 진정한 의미
* 영속성 컨텍스트의 변경 내용을 데이터 베이스에 동기화하는 것이 플러시이다.

### 준영속성 상태의 특징
* 거의 비용속 상태에 가깝다
	- 영속성 컨텍스트가 관리하지 않음으로 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 포함한 영속성 컨텍스트가 제공하는 어떠한 기능도 동작하지 않는다.
* 식별자 값을 가지고 있다.
	- 비용속 상태는 식별자 값이 없을 수도 있지만 준영속 상태는 이미 한 번 영속 상태 였음으로 반드시 식별자가 값ㅇ을 가지고있다.
* 지연 로딩을 할 수 없다
	- 지연 로딩은 실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법이다. 하지만 준 영속성 상태는 영속성 컨텍스트가 더는 관리하지 않으므로 지연 로딩 시 문제가 발생한다.

### 정리
* 엔티티 매니저는 엔티티 매니저 팩토리에서 생성한다. 자바를 직접 다루는 환경에서 앤티티 매니저를 만들면 그 내부에 양속성 컨텍스트도 함께 만드렁 진다. 이 영속성 컨텍스트는 엔티티 매니저를 통해서 접근할 수 있다.
* 영속성 컨텍스트는 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할을 한다. 영속성 컨텍스트 덕분에 1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기 지연, 변경 감지 , 지연로딩을 사용할 수있다.
* 영속성 컨텍스트에 저장한 엔티티는 플러시 시점에 데이터베이스에 반영되는데 일반적으로 트랜잭션 커밋할 때 영속성 컨텍스트가 플러시된다.
* 영속성 컨텍스트가 관리하는 엔티티를 영속 상태의 엔티티라 하는데, 영속성 컨텍스트가 해당 엔티티를 더 이상 관리하지 못하면 엔티티는 준영속 상태의 엔티티라 한다. 준영속 상태의 엔티티는 더는 영속성 컨텍스트의 관리를 받지 못하므로 영속성 ㅋ넌텍스트가 제공할는 1차 캐시, 동일성 보장, 트랜잭션을 지원할는 쓰기 지연, 변경 감지 지연 로딩 같은 기능을 사용할 수 없다.

## 4장


## 5장
* 엔티티들은 대부분 다른 엔티티와 연관관계가 있다. 예를 들어 주문 엔티티는 어떤 상품의 주문을 주문 했는지 알기 위해 상품 엔티티와 관계를 갖는다
* 객체는 참조(주소)를 사용해서 관계를 맺고 테이블은 외래 키를 사용해서 관계를 맺는다. 이 둘은 완전히 다른 특징을 가진다. 객체 관계 매핑ORM에서 가장 어려운 부분이 바로 객체 연관관계와 테이블 연관관계를 매핑하는 일이다.

### 핵심 용어

* 방향 Direction
	- 단방향, 양방향이 있다
	- 회원과 팀 관계가 있을 때 회원 -> 팀, 또는 팀 -> 회원 양쪽 모두 서로 참조하는 것을 양방향 관계라 한다
	- 방향은 객체관계에만 존재하고 테이블 관계는 항상 양방향이다.
* 다중성
	- `N : 1`, `1 : n`, `N : M`의 다중성이 있다.
* 연관관계의 주인
	- 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다.

### 단방향 연관관계

* 회원과 팀이 있다.
* 회원은 하나의 팀에만 소속될 수 있다.
* 회원과 팀은 다대일 관계다.

### 객체 연관관계
* 회원 객체는 Member.team 필드로 팀 객체와 연관관계를 맺는다
* 회원 객체와 팀 객체는 단방향 관계다. 회원은 Memeber.team 필드를 통해서 팀을 알 수 있지만 반대로 팀은 회원을 알 수 없다.

### 테이블 연관관계
* 회원 테이블은 TEAM_ID 외래 키로 팀 테이블과 연관관계를 맺는다.
* 회원 테이블과 팀 테이블은 양방향 관계이다. 외래키를 통해서 조인을 할 수있다.

### 객체 연관관계와 테이블 연관관계의 가장 큰 차이
* 참조를 통한 연관관계는 언제나 단방향이다. 객체간에 ㅇㄴ관관계를 양방향으로 만들고 싶으면 반대쪽에도 필드를 추가해서 참조를 보관해야한다. 결국 연관관계를 하나 더 만들어야 한다.
* 이렇게 양쪽에서 서로 참조하는 것을 양방햘ㅇ 연관관계라 한다
* 하지만 더 정확히 이야기하면 이것은 양방향 관계가 아니다 서로 다른 방향 관계 2개다

### 객체 단방향 연관관계
```java
class A {
	B b;
}

class B {}
```

### 객체 양방향 관계
```java
class A {
	B b;
}

class B {
	A a;
}
```

### 객체 연관관계 vs 테이블 연관관계 정리
* 객체는 참조(주소)로 연관관계를 맺는다
* 테이블은 외래 키로 연관관계를 맺는다.
* 이둘은 비슷해 보이지만 매우 다른 특징을 가진다. 연관된 데이터를 조화할 떄 객체는 참조 `(a.getB().getC())`를 사용하지만 테이블은 조인을 사용한다
* 참조를 사용하는 객체의 연관관계는 단방향이다
* 왜리 키를 사용하는 테이블의 연관관계는 양방향이다.
* 객체를 방향으로 참조하려면 단방향 연관관계를 2개 만들어야한다.
* 객체는 참조를 사용해서 연관관계를 탐색할수 있는데 이것을 **객체 그래프 탐색이**라 한다.
* 데이터베이스는 왜리 키를 사용해서 연관관계를 탐색할 수 있는데 이것을 조인이라 한다.

```java
public class Memeber {

    @Id
    @Column(name = "MEMBER_ID")
    private String id;

    private String username;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;


}

public class Team {
    @Id
    @Column(name = "MEMBER_ID")
    private String id;

    private String name;
}
```
* 객체 연관관계 : 회원 객체의 Member.team 필드사용
* 테이블 연관관계: 회원 테이블의 MEMBER.TEAM_ID  사용
* `@ManyToOne`: 이름 그대로 다대일 관계라는 매핑 정보다. 회원 팀은 다대일관계 이다
* `@JoinColumn(name = "TEAM_ID")` 조인 칼럼은 외래 키를 ㅐ핑할 떄 사용한다.

### 연관관계 사용

#### 조회


#### 객체 그래프 탐색

```java
Memeber meber = em.find(Memeber.class, "member1");
Team team = member.getTeam(); // 객체 그래프 탐색
```
* 객체를 통해 연관된 엔티티를 조회하는 것을 객체 그래프 탐색이라한다.

#### 객체지향 쿼리 사용(JPQL)
```SQL
select m from Member m join m.team t where tmname = :teamName
```

* JPQL의 `from Memeber m join m.team t` 부분을 보면 회원 팀과 관계를 가지고 있는 필드를 통해서 Memeber와 Team을 조인 했다
* 그리고 where절을 통해서 팀1의 속한 회원만 검색했다.

### 양방향 연관관계
* 엄밀히 이야기하면 객체에는 양뱡향 연관관계라는 것이 없다.
* 서로 다른 단방향 연관관관계를 2개를 애플리케이션 로직으로 잘 묶어서 양뱡향인 것처럼 보이게 할 뿐이다.

* 다시 한번 강조하지만 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리한다.
* 엔티티를 양방향 연관고ㅓㄴ계로 설정하면 객체의 참조는 둘인데 외래 키는 하나다. 따라서 둘 사이에서 차이가 발생한다. 그렇다면 둘 중 어떤 관계를 사용해서 외래키를 관리해아할까?
* 이런 차이로 JPA는 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야 하는 것인데 이것을 연관관계의 주인이라한다.

### 양방향 매핑의 규칙 : 연관관계의 주인
* 연관관계의 주인만이 데이터베이스 연관관계와 ㅁ매핑되고 외래 키를 관리 (등록, 수정. 삭제)를 할 수있다.
* 반면 주인이 아닌 쪽은 읽기만 할 수있다.
* 주인은 mappedBy 속성을 사용하지 않는다.
* 주인이 아니면 mappedBy 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정해야한다.

### 연관관계 주인 설정
* 연관관계의 주인을 정한다는 것은 사실 외래 키 관리자를 선택하는 것이다.
* 데티어베이스 테이블의 다대일, 일대다 관계에서는 항상 다 쪽이 외래키를 가진다. 다 쪽인 @ManyToOne은 항상 연관관계의 주인이 되므로 mappedBy를 설정할 수 없다.

### 양방향 연관관계의 주이점
* 양방향 연관관계를 설정하고 가장 흔히 하는 실수는 연관관계의 주인에는 값을 입력하지 않고, 주인이 아닌 곳에만 값을 입력하는 것이다. 데이터베이스에 외래키 값이 정상적으로 저장되지 않으면 이것부터 의심해보자
* 다시한번 강조하지만 연관관계의 주인만이 외래 키의 값을 변경할 수 있다.

### 순수한 객체까지 고려한 양방향 연관관계
* 그렇다면 정말 연관관계의 주인에만 값을 저장하고 주인이 아닌 곳에는 값을 저장하지 않아도 될까?
* 사실은 객체 관점에서 양쪽 방향에 모두 값을 입력해주는것이 가장 안전하다.
* 양쫅 방향 모두 값을 일력하지 않으면 JPA를 사용하지 않은 순수한 객체 상태에서 심각한 문제가 발생할 수 있다.

### 정리
* 단방향 매핑과 비교해서 양방향 매핑은 복잡하다. 연관관계의 주인도 정해야 하고 두 개의 단방향 연관관꼐를 양방향으로 만들기 위해 로직도 잘 관리해아 한다.
* 중요 한 사실은 연관관계의 하나인 단방향 매핑은 언제나 연관관계의 주인리하는 점이다.
* 단방향 매핑만으로 테이블과 객체의 연관관계 매핑은 이미 완료도었다.
* 단방향을 양방향으로 만들면 반대방향으로 객체 그래프 탐색 기능이 추가 된다.
* 앙방향 연관관계를 매핑하려면 객체에서 양쪽 방향으로 모두 관리 해야한다.


### 연관관계의 주인을 정하는 기준
* 단방향은 항상 외래 키가 있는 곳을 기준으로 매핑하면된다. 하지만 양뱡항은 연관관계의 주인 이라는 이름으로 인해 오해가 있을 수 있다.
* 비지니스 로직상 더 중요하다고 연관관계의 주인으로 산택하면 안된다.
* **비지니스중요도를 배제하고 단순히 외래 키 관리자가 정도의 으미만 부여해야 한다.**

## 6장 다양한 연관관계 매핑

### 다대일
* 다대일 관계의 반대 방향은 항상 일대다 관계고 일대다 관계의 반대 방향은 항상 다대일 관계이다
* 데이터베이스 테이블 일, 다 관계에서 외래 키는 항상 다쪽에 있다. 따라서 객체 방향 관계에서 연관관계의 주인은 항상 다 쪽이다.

### 양방향
* 양방향은 외래 키가 있는 쪽이 연관관계의 주인이다
	- 일대다와 다대일 연관관계는 항상 다에 외래 키가 있다.
	- JPA는 외래 키를 관리할 때 연관관계의 주인만 사용한다.
	- 주인이 아닌 곳에서는 조회를 위해 JPQL이나 그래프 탐색할 때 사용한다.
* 양방향 연관관계는 항상 서로를 참조해야 한다.
	- 어느 한 쪽만 참조하면 앙방향 연관과계까 성립하지 않는다. 항상 서로 참조하게 하려면 연관관계 편의 메소드를 작성하는 것이 좋다.

### 일대다
* 일대다 관계는 다대일 관계의 반대 방향이다. 일대다 관계는 엔티티 하나 이상 참조할 수  있으므로 자바 컬랙션인 Collection, List, Set, Map 중에 하나를 사용해야 한다.

### 일대다 단방향 [1:N]
* 보통 자신이 매핑한 테이블의 외래 키를 관리하늗네, 이 매핑은 반대쪽 테이블에 있는 외래 키를 관리한다.
* 일대다 단방향 매핑의 단점
	- 일대다 단방향 매핑의 단점은 매핑 한 객체가 관리하는 왜리 키가 다른 테이블에 있다는 점이다.
	- 본인 테이블에 왜리 키가 있다면 엔티티의 저장과 연관관계 처리를 Insert SQL 한 번으로 끝낼 수 있지만, 다른 테이블에 왜리 키가 있으면 연관관계 처리를 위한 UPDATE SQL을 추가로 실행해야한다.
* **일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자**
	- 일대다 단방향 매핑을 사용하면 엔티티를 매핑한 테이블이 아닌 다른 테이블의 외래 키를 관리해야 한다.
	- 이것은 성능 문제도 있지만 관리도 부담스럽다. 문제를 해결하는 좋은 방법은 일대다 단방향 매핑 대신에 다대일 양방향 매핑을 사용하는 것이다.
	- 다대일 양방향 매핑은 관리해야 하는 왜리 키가 본인 테이블에 있다. 따라서 일대다 단방향 매핑 같은 문제가 발생하지 않는다. ㄷ 매핑 테이블 모양은 완전히 같으므로 엔티티만 약간 수정하면된다.


### 일대다 양방향
* 일대다 양방향 매핑은 존재하지 않는다. 대신 다대일 양방향 매핑을 사용해야 한다.
* 더 정확히 말하자면 양방향 매핑에서 `@OneToMany`는 연관관계의 주인이 될 수 없다. 왜냐하면 관계형 데이터베이스의 특정상 일대다, 다대일 관계는 항상 다 쪽에 외래 키가 있다. 따라서 `@OneToMany`, `@ManyToOne` 둘 중에 연관관계의 주인은 항상 `@ManyToOne`을 사용한 곳이다. 이런 이유로 `@ManyToOne`에는 mappedBy 속성이 없다.
* 그렇다고 일대다 양방향 매핑이 완전히 불가능한 것은 아니다. 일대다 단방향 매핑은 반대편 같은 외래키를 사용하는 다대일 단방향 매핑을 읽기 전용으로 하나 추가하면된다.

### 일대일 [1:1]

* 일대일 관계는 양쪽이 서로 하나의 관계만 가진다. 예를 들어 회원은 하나의 사물함만 사용하고 사물함도 하나의 회원에 의해서만 사용된다.
* 일대일 관계는 반대로 일대일 관계다
* 테이블 관계에서 이랟다, 다대일은 항상 다 쪽이 외래 키를 가진다. 반면에 일대ㅇㄹ 관계는 주 테이블이나 대상 테이블 중 어느 한곳이나 외래 키를 가질 수 있다.

### 다대다: 단방향

```java

@ManyToMany
@Jointable(
	name = "memeber_product",
	joinColums = @JoinColums(name = "member_id"),
	inverseJoinColmuns = @JoinColums(name = "PRODUCT_ID")
	)
```

* `@JoinTable.name` : 연결테이블을 지정한다.
* `@JoinTable.joinColums` : 현재 방향인 회원과 매핑할 조인 컬럼 정보를 지정한다.
* `@JoinTable.inverseJoinColmuns`: 반대 방향인 상품과 매핑할 조인 컬럼 정보를 지정한다.

### 다대다: 매핑의 한계와 극복, 연결 엔티티 사용

* `@ManyToMany`를 사용하면 연결 테이블을 자동으로 처리해주므로 도메인 모델이 단순해지고 여러 가지로 편리하지만 이 매핑에을 실무에서 사용하기에는 한계가 있다.
* 회원이상품을 주문하면 연결 테이블에 단순히 주문한 회원 아이디와 상품 아이디만 담고 끝나지 않는다 연결 테이블에는 주문 수량 컬럼이나 주만 날짜 같은 컬럼이 더 필요하다
* 이러한 문제를 해결 하는것이 연결 엔티티

### 다다다: 새로운 기본 키 사용

* 추천하는 기본 키 생성 전략은 데이터베이스에서 자동적으로 생성해주는 대리 키를 Long 갑승로 사용하는 것이다
* 이것의 장점은 가년하고 거의 영구히 쓸 수 있으며 비지니스에 의존하지 않는다.
* OMR 매핑 시에 복합 키를 만들지 않아도 되므로 간단히 매핑을 완성할 수 있다.

### 다대다 연관관계 정리

* 다대다 관계를 일대다 다대일 관계로 풀어내기 위해 연결 테이블을 만들때 식별자를 어떻게 구성할지 선택해야한다

* 시별 관계 : 받아온 실별자를 기본 키 + 외래 키로 사용한다
* 비식별 관계 : 받아온 실별자는 왜래 키로만 사용하고 새로운 식별자를 추가한다.

## 07장 고급 매핑

* 상속 과계 매핑 : 객체의 상속 관계를 데이터베이스를 어떻게 매핑하는지 다룬다.
* `@MappedSuperclass` : 등록일, 수정일 같이 여러 엔티티에서 공통적으로 사용하는 매핑 정보만 상속받고 싶으면 이기능을 사용하면된다.
* 복합 키와 식별 관계 매핑 : 데이터베이스의 식별자가 하나 이상일 때 매핑하는 방법을 다룬다. 그리고 데이터베이스 설계에서 이야기하는 식별 관계와 비식별 관계에 대해서 다룬다
* 조인 테이블 : 테이블은 외래 키 하나로 연관관계를 맺을 수 있지만 연관관계를 관리하는 연결 테이블을 두는 방법도있다. 여기서는 이 연결 테이블을 매핑하는 방법을 다룬다
* 엔티티 하나에 여러 테이블을 매핑하기: 보통 엔티티 하나에 테이블하나를 매핑하지만 엔티티 하나에 여러 테이블을 매핑하는 방법도 있다.

### 상속 관계 매핑
* 관계형 데이터베이스에는 객체지향ㅇ 언어에 다루는 상속이라는 개념이 없다. 대신에 슈퍼타입과 서브타입 관계 라는 모델링 기법이 객체의 상속 개념과 가장 유사하다
* ORM에서 이야기하는 상소 관계 매핑은 객체의 상속 구조와 데이터베이스의 슈퍼ㅏ입 서브타입 관계를 매핑하는 것이다

### 상속관계 매핑 방법
* 각각의 테이블 변환 : 모두 테이블로 만들고 조회할 떄 조인을 사용한다. JPA에서는 조인 전략이라 한다.
* 통합 테이블로 변환 : 테이블을 하나만 사용해서 통합한다. JPA에서는 단일 테이블 전략이라 한다.
* 서브타입 테이블로 변환 : 서브 타임마다 하나으 테이블을 만든다. JPA에서는 구현 클래스마다 테이블 전략이라한다.

### 조이 전략
* 엔ㄴ티티 각각을 모두 테이블로 만들고 자식 테이블이 모두 부모 테이블의 기본 키를 받아서 기본 키 + 왜래 키로 사용하는 전략이다.
* 조회할 경우 조인을 사용한다. 이 전력을 사용할때 주의 점은 객체는 타입으로 구분할 수있지만 테이블은 타입의 개념이 없다. 따라서 타입을 구분하는 칼럼을 추가해야한다. 여기서는 DTYPE 칼럼을 구분 칼럼으로 사용한다.

```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {

    @Id
    @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;
}

@Entity
@DiscriminatorValue("A")
class Album extends Item {
    private String artist;
}

@Entity
@DiscriminatorValue("M")
class Movie extends Item {
    private String director;
    private String actor;
}
```
* `@Inheritance(strategy = InheritanceType.JOINED)` : 상속 매핑은 부모 클래스에 `@@Inheritance`를 사용해야한다. 그리고 매핑 전략을지정해야 하는데 여기서는 조인 전략을 사용하므로 `InheritanceType.JOINED`을 사용한다.
* `@DiscriminatorColumn(name = "DTYPE")`: 부모 클래스에 구분 칼럼을 지정한다. 이 칼럼으로 지정된 자식 테이블을 구분할 수있다. 기본 값이 DYTPE 이므로 `@DiscriminatorColumn`으로 줄여 사용해도 된다.
* @DiscriminatorValue("M"): 엔티티를 지정할 때 구분 칼럼을 입력을 지정한다. 만약 영화 엔티티를 지정하려면 구분 칼럼의 DTYPE을 지정값에 M을 지정하면된다.
* 기본값으로 자식 테이블은 부모 테이블의 ID 칼럼명을 그대로 사용하는데, 만약 자식 테이블의 기본 키 칼럼명을 변경하고 싶으면 `@PrimaryKeyJoinColumn`속성을 사용하면된다.

```java
@Entity
@PrimaryKeyJoinColumn(name = "BOOK_ID")
@DiscriminatorValue(value = "B")
class Book extends Item{
    private String author;
    private String isbn;
}
```
* BOOK 테이블의 ITEM_ID를 기본키 칼럼명을 BOOK_ID로 변경했다

* 장점
	- 테이블이 정규화 된다.
	- 왜래 키 참조 무결성 제약조건을 활용할 수 있다.
	- 저장공간을 효율적으로 사용한다.
* 단점
	- 조회할 떄 조인이 많이 사용되므로 성능이 저하될 수 있다.
	- 조회 쿼리가 복잡하다
	- 데이터를 등록할 Insert SQL을 두번 실행한다.
* 특징
	- JPA 표쥰 명세는 구분 칼럼을 사용하도록 하지만 하이버네이트를 포함한 몇 몇 구현체는 구분 칼러 없이도 동작한다.

### 단일 테이블 전략
* 단일 테이블 전략은 이름 그대로 테이블하나만 사용한다. 그리고 구분칼럼으로 어떤 자식 데이터가 저장되있는지 구분한다. 조회할 떄 종인을 사용하지 않으므로 일반적으로 가장 빠르다.
* 이 전략을 사용할 떄 주의점은 자식 엔티티가 매핑한 칼럼은 모두 null을 허용해야한다느 점이다.
* 예를들어 Book 엔티티를 저장하려면 ITEM 테이블의 AUTHOR, ISBN 칼럼만 사용하고 다른 엔티티와 매핑된 다른 칼럼은 사용하지 않음으로 null 처리해야한다



```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {

    @Id
    @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;
}

@Entity
@DiscriminatorValue("A")
class Album extends com.example.mall.test.Item {
    private String artist;
}
@Entity
@DiscriminatorValue("M")
class Movie extends com.example.mall.test.Item {
    private String director;
    private String actor;
}

@Entity
@DiscriminatorValue(value = "B")
class Book extends com.example.mall.test.Item {
    private String author;
    private String isbn;
}
```
* `@Inheritance(strategy = InheritanceType.SINGLE_TABLE)` 지정하면 단일 테이블 전략을 사용한다. 테이블 하나에 모든 것을 통합하므로 구분 칼럼을 필수로 사용해야 한다. 단일 테이블 저략은 장단점은 하나의 테이블을 사용하는 특징과 관련 있다.

* 장점
	- 조인이필요 없음으로 일반적으로 조회 성능이 빠르다.
	- 조회 쿼리가 단순하다
* 단점
	- 자식 엔티티가 매핑한 커러럼은 모두 null을 허용해야한다.
	- 단일 테이블에 모든 것을 지정하므로 테이블이 커질 수 도 있다. 그러므로 상황에 따라서 조회 성능이 오히려 느려질 수 있다.
* 특징
	- 구분 칼럼을 꼭 사용해야한다. 즉 `@DiscriminatorValue("M")`을 꼭 설정해야 한다.
	- `@DiscriminatorValue("M")`를 지정하지 않으면 기본 엔티티 이름을 사용한다.

### 구현 클래스 마다 테이블 전략
* 구현 클래스마다 테이블 전략은 자식 엔티티 테이블마다 테이블을 만든다. 그리고 자식 테이블에 가각 필요한 칼럼이 모두 있다.

```java
package com.example.mall.test.mutlple;

import javax.persistence.*;

@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {

    @Id
    @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;
}


@Entity
class Album extends com.example.mall.test.Item {
    private String artist;
}
@Entity
class Movie extends com.example.mall.test.Item {
    private String director;
    private String actor;
}

@Entity
class Book extends com.example.mall.test.Item {
    private String author;
    private String isbn;
}
```
* `@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)`를 선택하면 구현 클래스마다 테이블 전략을 사용해야한다. 이 전략은 자식 엔티티마다 테이블을 만든다, 일반적으로 추천하지 않는 전략이다.

* 장점
	- 서브 타입을 구분해서 처리할 떄 효과적이다.
	- not null 제약조건을 사용할 수 있다.
* 단점
	- 여러 자식 테으블을 함꼐 조회할 때 성능이 느리다.
	- 자식 테이블을통합해서 쿼리하기 어렵다
* 이 전략은 데이터베이스 설계자와 ORM 전문가 둘 다 추천하지 않는 전략이다. 조인이나 단일 테이블 전략을 고려하자
*

### 복합 키와 식별 관계 매핑
* 데이터베이스 테이블 사이에 관계는 외래 키가 기본 키에 포홤되있는지 여부에 따라 식벽 관계와 비 식별관계로 구분된다. 이 두 관계의 특징을 잏하고 각가 어떻게 매핑되는지 알아보자

### 식별 관계
* 식별 관계는 부모 테이블의 기본 키를 내려받아서자식 테이블의 기본 키 + 왜래키로 사요ㅇ하는 것이다.

### 비식별 관계
* 비식별 관계는 부모 테이블의 기본 키를 받아서 자식 테이블의 외래 키로만 사용하는 관계이다.
* 필수적 비식별 관계
	- 외래 키에 null을 허용하지 않는다. 연관관계를 필수적으로 맺어어야 한다.
* 선택적 비식별 관계
	- 외래 키에 null을 허용한다. 연관관계를 맺을지말지를 선택할 수 있다.

### 조인 테이블
* 데이터베이스 테이블의 연관관계를 설계하는 방법은 크게 2가지아다
	- 조인 커럼 사용(외래 키)
	- 조인 테이블 사용 (테이블 사용)

#### 조인 칼럼 사용
* 테이블 간에 관계는 주로 조인 칼럼이라 부르는 외래 키 칼럼을 사용한다
* 외부 조인을 할 경우 outer join을 선택해야한다. 실수로 내부 조인을 사용하면 사물함과 관계 없는 회원은 조회되지 않는다.

#### 조인 테이블 사용
* 조인 테이블은 조인을 위한 외래키 대신 테이블을 만들고 해당 테이블에 객체 관의 PK를 FK로 지정해서 객체를 연결하는 방법이다.
* 관리해야할 테이블이 하나 늘어나는 형태임으로 그렇게 추천하지는 않는다.
* 다대다 조인시 주로 사용


## 08 프록시와 연관관계 관리

* 프록시와 즉시로딩, 지연로딩
	- 객체는 객체 그래프로 연관된 객체들을 탐색한다. 그런데 객체가 데이터베이스에 저장되어 있으므려 연관된 객체를 마음껏 탐색하기는 어렵다.
	- JPA 구현체들은 이 문제를 해결하려고 프로식라는 기수을 사용한다. 프록시를 사용하면 연관된 객체를 처음부터 데이터베이스에서 조회할 수있다.
	- 프록시를 사용하면 연과된 객체를 처음부터 데이터베이스에서 조회하는 것이 아니라. 실제 사용하는 시점에 데이터베이스에서 조회할 수있다.
	- 하지만 자주 함께 사용하는 객체들은 조인을 사용해서 함꼐 조회하는 것이 효과적이다
	- JPA는 즉시 로딩괴 지연 로딩 이라는 방법으로 둘을 모두 지원한다
* 영속성 전이와 고아 객체
	- JPA는 연관된 객체를 함께 저장하거나 함꼐 삭제할수 있는 연속성 전이와 고아 객체 제거라는 편리한 기능을 제공하고있다

### 프록시

* 엔티티를 조회할 떄 연관된 엔티티들이 항상 사용되는 것은 아니다. 예를 들어 회원 엔티티를 조회할 때 연관된 팀 엔티티 비니지스 로직에 따라 사용될 때도 있지만 그렇지 않을 떄도 있다.
* 회원 엔티티만 조회하 고 싶을 경우도 있고 회원에 팀까지 조회하고 싶은 경우도 있다. 이럴 경우 두 벌의 비지니스 로직이 필요 하다.
* JPA는 이런 문제를 해결하려고 엔티티가 실제 사용될 떄 까지 데이터베이스 조회를 지연하는 방법을 제공하는데 이것을 `지연 로딩` 이라 한다.
* **쉽게 이야기해서 `team.getName()` 처럼 팀 엔티티의 값을 실제 사용하는 시점에 데이터베이스에서 팀 엔티티에 필요한 데이터를 조회하는 것이다**
* 그런데 지연 로딩 을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 할 수 있는 각짜 객체가 필요한데 이것을 **`프록시 객체`**라고한다
* JPA 표준 명세는 지연 로딩의 구현 방법을 JPA 구현체에 위임했다. 따라서 지금 부터 설명할 내용은 하이버네이트 구현체에 대한 내용이다. 하이버네이트는 지연 로딩을 지원하기 위해 프록시를 사용하는 방법과 바이트코드를 수정하는 두 가징 방법을 제공하는 데 바이트코드를 수정하는 방법은 설정이 복잡하므로 여기서는 별도의 설정없는 프록시에 대해서만 알아보겠다.

### 프록시 기초

* JPA에서 식별자로 엔티티 하나를 조회할 떄는 `EntityManager.find()`를 사용한다. 이 메서드는 영속성 컨텍스트에 엔티티가 없으면 데이터베이스를 조회한다.

```java
Memeber member = em.find(Memeber.class, "memeber1");
```
* 이렇게 엔티티를 직접 조회하면 조회한 엔티티를 실제 사용하든 사용하지 않든 데이터베이스를 조회하게 된다.
* 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미루고 싶다면 `EntityManager.getReference(Memeber.class, "member1")` 메소드를 사용하면된다
* 이 메소드를 호출할 때 JPA는 데이터베이스를 조회하지 않고 실제 엔티티 객체도 생성하지 않는다.
* 대신에 데이터베이스 접근을 위임한 프록시 객체를 반환한다.
* 지금부터 프록시에 대해서 알아보자

### 프록시의 특징
* 프록시 클래스는 실제 클래스를 상송 받아서 만들어지므로 실제 클래스와 겉 모양이 같다. 따라서 사용하는 입장에서는 이것이 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하 면된다.

### 프록시 객체의 초기화
프록시 객체는 `Member.getName()` 처럼 실제 사용될 때 데이터베이스를 조회해서 실제 엔티티 객체를 생성하는데 이것을 프록시 객체의 초기화라 한다.


```java
Member member = em.getReference(Member.class, "id1");
member.getName(); //1. getName();
```

```java
class MemberProxy extedns Member{
	Member target = null;

	public String getName(){
		if(target ==null){
			//2. 초기화 요청
			//3. DB 조회
			//4. 실제 엔티티 생성 및 참조 보관
			this.target = ...;
		}

		//5. target.getName();
		return target.getName();
	}
}
```
1. 프록시 객체에 `member.getName()`을 호출해서 실제 데이터를 조회한다.
2. 프록시 객체는 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 실제 엔티티 생성을 요청하는데 이것을 초기화라 한다.
3. 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성한다.
4. 프록시 객체는 생ㅇ성된 실제 엔티티 객체의 참조를 `Member target` 멤버 변수에 보관한다.
5. 프록시 객체를 실제 엔티티 객체의 `getName()`을 호출해서 결과를 반환한다.

### 프록시의 특징
* 프록시 객체는 처음 사용할 때 한번만 초기화된다.
* 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 프록시 객체가 초괴화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다.
* 프록시 객체는 ㅜ언본 엔ㄴ티티를 상속받은 객체이므로 타입 체크 시에 주의해서 사용해야한다.
* 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 따라서 영속성 컨텍스트의 도움을 받을 수 없는 준영속성 상태의 프록시를 초가화하면 문제가 발생환다.

### 즉시 로딩과 지연 로딩

* 프록시 객체는 주로 연ㄴ관된 엔티티를 지연 로딩할 떄 사용한다.
* Member1이 team1에 소속해 있다고 가정해보자
```java
Member member = em.find(Member.class, "member1");
Team team = member.getTeam(); // 객체 그래프 탐색
team.getName(); // 팀 엔티티 사용
```
* 회원 엔티티를 조회할 떄 연관된 팀 엔티티도 함꼐 데이터베이스에서 조회하는 것이 좋을까? 아니면 회원 엔티티만 조회해 두고 팀 엔티티는 실제 사용하는 시점에 데이터베이스에서 조회하는 것이 좋을까?
* JPA는 개발자가 연관된 엔티티의 조회 시점을 서냋ㄱ할 수 있도록 다음 두 가지 방법을 제공한다.
* 즉시 로딩 : 엔티티를 조회할 떄 연관된 엔티티도 함께 조회한다.
	- em.find(Member.class, "member1")를 호출할 때 회원 엔티티와 연관된 팀 엔티티도 함께 조회한다.
	- 설정 방법 : @ManyToOne(fetch = Fetchtype.Eanger)
	- 즉시 로딩을 최적화하기 위해서 가능하면 조인 쿼리를 사용한다. 여기서는 회원과 팀 조인을 해서 한 번으로 두 엔티티를 모두 조회한다.
* 지연 로딩 : 연관된 엔티티를 실제 사용할때 조회된다.
	- member.getTeam().getName() 처럼 조회한 팀 엔티티를 실제 사용하는 시점에 JPA가 SQL을 호출해서 팀 엔티티를 조회한다.
	- 설정 방법 : @ManyToOne(fetch = Fetchtype.LAZY)

### 즉시 로딩, 지연 로딩 정리
* 처음부터 연관된 엔티티를 모두 영속성 컨텍스트에 올려두는 것이 현실적이지 않고, 필요 할 때마다 SQL을 실행해서 연관된 엔티티를 지연 로딩하는 것도 최적화 관점에서 보면 꼭 좋은 것만은 아니다. 예를 들어 대부분 애플리케이션 로직에서 회원과 팀 엔티티를 같이 사용한다면 SQL 조인을 사용해서 회원 팀 엔티티를 한번에 조회하는 것이 더 효율적이다. 결국 연관된 앤티티를 즉시 로딩하는 것이 좋은지 아니면 실제 사용할 때 까지 이연해서 로딩하는 것이 좋은지는 상황에 따라 다르다.
* 지연 로딩(LAZY) : 연관된 엔티티를 프록시로 죄회한다. 프록시를 실제 사용할 때 초기화 하면서 데이터베이스를 조회한다.
* 즉시 로딩 (EAGER) : 연관된 엔티티를 즉시 조회한다. 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회한다.

### 지연 로딩 활용

#### 모델링 분석
* 회원은 팀 하나에만 소속할 수 있다. (N:1)
* 회원은 여러 주문내역을 가진다. (1:N)
* 주문내역은 상품정보를 가진다(N:1)
* Member와 연관된 Team은 자주 함께 사용되었다. 그래서 Member와 Team은 즉시 로딩으로 설정했다.
* Member와 연곤된 Order는 가끔 사용되었다. 그래서 member와 order는 지연 로딩으로 설정했다
* Order와 연괸된 Product 자주 함꼐 사용되었다. 그래서 Order와 Product 는 즉시 로딩으로 설정했다.

### JPA 기본 페치 전략(중요!)
* fetch 속성의 기본 설정값은 다음과 같다.
	- `@ManyToOne`, `@OneToOne`: 즉시 로딩 (Fetchtype.EAGER)
	- `@OneToMany`, `@ManyToMany`: 지연 로딩 (Fetchtype.LAZY)

* JPA의 기본 패치 전략은 야ㅕㄴ관된 엔티티가 하나면 즉시 로딩을, 컬랙션이면 지연 로딩을 사용한다. 컬렉션을 로딩하는 것은 비용이 많이 들고 잘못하면 너무 많은 데이터를 로딩할 수 있기 때문이다. 예를 들어 특정 회원이 연관된 컬랙션에 데이터를 수만 건 등록 했는데, 설정한 패치 전략이 즉시 로딩이이면 해당 회원을 로딩하는 순간 수만 건의 데이터도 함께 로딩된다. 반면에 연관된 에니티가 하나면 즉시 로딩을 해도 큰문제가 발생되지 않는다.
* **추천하는 방법은 모든 연관관계에 지연 로딩을 하는 것이다.** 그리고 애플리케이션 개발이 어느정도 완료단계에 왔을떄 실제 사용하는 상황을 보고 꼭피ㅏㄹ요한 곳에만 즉시 로딩을 사용하도록 최적화하면된다
* 참고로 SQL을 직접사용하면 이러 유연한 최적화가 어렵다. 예를 들어 SQL로 각각의 테이블을 조회해서 처리하다가 조인으로 한 번에 조회하도록 변경하려면 많은 SQL과 애플리케이션 코드를 수정해야한다.

### 컬렉션에 FetchType.EAGER 사용 시 주의점

* 컬랙션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다.
	- 컬렉션과 조이하는 것은 데이터베이스 테이블로 보면 일대다 조인이다. 일대다 조인은 결과 데이터가 다 쪽에 있는 수만큼 증가하게 된다. 문제는 서로 다른 컬랙션을 2 개 이상 조인할 때 발생하는데 예를들어 A 테이블에 N, M 두 테이블과 일대다 조인하면 SQL 실행 결과가 N곱하기 M이 되면서 너무 많은 데이터를 반환할 수 잇고 결과적으로 성능저화가 될 수있다.
	- 따라서 N개 이상은 즉시 로딩으로 설정하는 것은 권하지 않는다.
* 컬렉션 즉시 로딩은 항상 외부 조인을 사용한다.
	- 예를 들어 다대일 관계 인 회원 테이블과 팀 테이블을 조인할 떄 회원 테이블의 외래 키에 not null 제약 조건을 걸어두면 모든 회원은 팀에 소속되므로 항상 내부 조인을 사용해도 된다.
	- 반대로 팀 테이블에서 회원 테이블로 일대다 관계를 조인할 때 회원이 한명 도 없는 팀을 내부 조인하면 팀까지 조회되지 않는 문제가 발생한다. 데이터베이스 제약조건을 이런 사항을 말을 수 없다. 따라서 JPA는 일대다 관계를 즉시 로딩할 때 항상 외부 조인을 사용한다.

### FetchType.EAGER 설정과 조인 전략을 정리하면 다음과 같다.
* `@ManyToOne`, `@OneToOne`
	- (optional = false) : 내부 조인
	- (optional = true) : 외부 조인
* `@OneToMany`, `@ManyToMany`
	- (optional = false) : 외부 조인
	- (optional = true) : 내부 조인

### 영속성 전이 : CASECADE
* 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이 기능을 사용하면된다.
* JPA는 CASECADE 옵션으로 영속성 전이를 제공한다. 쉽게 말해서 영속성 전이를 사용하면 부모 엔티티를 저장할 떄 자식 엔티티도 함께 수정할 수있다.

```java
@Entity
public class Parent {
	@Id
	@GeneratedValue
	private Long id;

	@OneToMany(mappedBy = "parent")
	private List<Child> children = new ArrayList<Child>();
}

@Entity
public class Child {
	@Id
	@GeneratedValue
	private Long id;

	@ManyToOne
	private Parent parent;

	private static saveNoCsecade(EntityManager em){
		Parent parent = new Parent();
		em.persist(parent);

		// 1 번 자식 저장
		Child child1 = new Child();
		child1.setParent(parent); // 자식 -> 부모 연관관계 설정
		parent.getChilden().add(child1); // 부모 -> 자식
		em.persist(child1);


		// 2 번 자식 저장
		Child child2 = new Child();
		child1.setParent(parent); // 자식 -> 부모 연관관계 설정
		parent.getChilden().add(child2) // 부모 -> 자식
		em.persist(child2);
	}
}
```
* JPA에서 엔티티를 저장할 떄 연관된 모둔 엔티티는 영속성 상태여야 한다. 따라서 예제를 보면 부모 엔티티를 여속 상태로 만드로 자식 엔티티도 각각 영속 상태로 만든다. **이럴 때 영속성 전이를 사용하면 부모만 영속 상태로 만들면 연관된 자식 까지 한 번에 영속 상태로 만들 수 있다.**

### 영속성 전이 : 저장
```java
@Entity
public class Parent {
	@Id
	@GeneratedValue
	private Long id;

	@OneToMany(mappedBy = "parent", casecade = CasecadeType.PERSIST)
	private List<Child> children = new ArrayList<Child>();
}
```
* 부모를 영속화할 때 연관된 자식들도 함께 영속화하라고 `casecade = CasecadeType.PERSIST` 옵션을 설정했다. 이 옵션을 적용하면 간편하게 부모 자식 엔티티를 한 번에 영속화 할 수 있다.
```java
private static saveNoCsecade(EntityManager em){

	Child child1 = new Child();
	Child child2 = new Child();
	Parent parent = new Parent();

	parent.getChilden().add(child1); // 부모 -> 자식
	parent.getChilden().add(child2) // 부모 -> 자식
	child1.setParent(parent); // 자식 -> 부모 연관관계 설정
	child2.setParent(parent); // 자식 -> 부모 연관관계 설정

	em.persist(parent);
}
```
* 부모만 영속화 하면 `CasecadeType.PERSIST`로 설정한 자식 엔티티까지 함께 영속화해서 저장한다.
* 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없다. **단지 엔티티를 영속화 할 때 연관된 엔티티도 같이 영속화 하는 편리함을 제공할 뿐이다.**

### 영속성 전이 : 삭제

* 방금 젖아한 부모와 자식 엔티티를 모두 제거하려면 다음 코드와같이 각가의 엔티티를 하나씩 제거 해야한다.

```java

Parent parent = em.find(Parent.class, 1L);
Child child1 = em.find(Child.class, 1L);
Child child2 = em.find(Child.class, 2L);

em.remove(parent);
em.remove(child1);
em.remove(child2);
```
* 영속성 전이는 엔티티를 삭제할 떄도 사용할 수있다. `CasecadeType.REMOVE`로 설정하고 다음 코드 처럼 부모 엔티티만 삭제하면 연관된 자식 엔티티도 함께 삭제된다.
```java

Parent parent = em.find(Parent.class, 1L);
em.remove(parent);
```
* 코드를 실행하면 DELETE SQL을 3번 실행하고 부모는 물론 연관돈 자식도 모두 삭제한다.
* 삭제 순서는 외래 키 제약조건을 고려해서 자식을 먼저 삭제하고 부모를 삭제한다.
* 만약 `CasecadeType.REMOVE`를 설정하지 않고 이 코드를 실행하면 부모 엔티티만 삭제 된다. 하지만 데이터베이스 부모 로우를 삭제하는 순간 자식 테이블에 걸려있는 외래 키 제약 조건으로 인해, 데이터베이스에서 외래키 무결성 예외가 발생한다.

### CASECADE의 종류

```java
public enum CaseCadeType {
	ALL, // 모두 적용
	PERSIST, // 영속
	MERGE, // 병합
	REMOVE, // 삭제
	REFRESH, // REFRESH
	DETACH // DETACH
}
```
* 다음 처럼 여러 속성을 같이 사용할 수있다.
casecade = {CasecadeType,PERSIST, CasecadeType.REMOVE}

### 고아 객체
* JPA는 부모 엔티티와 연관관계가 끈ㄹㅎ어진 자식 엔티티를 자동으로 삭제하는 기능을 제공할는데 이것을 고아 객체 제거라 한다.
* 이 기능을 사용해서 부모 엔티티의 컬렉션에서 자식 엔티ㅣㅌ의 참조만 제거하면 자식 엔티티가 자동으로 삭제되도록 해보자

```java
```java
@Entity
public class Parent {
	@Id
	@GeneratedValue
	private Long id;

	@OneToMany(mappedBy = "parent", orphanRemoval = true)
	private List<Child> children = new ArrayList<Child>();
}

Parent parent1 = em.find(Parent.class, id);
parent1.getChildren().remove(0); //자식 엔티티를컬렉션에서 제거
```
* 실행 결과 SQL은 다음과 같다. `delete from child where id =?`
* 사용 코드를 보면 컬렉션에서 첫 번째 자식을 제거 했다. `orphanRemoval = true` 옵션으로 인해 컬렉션에서 엔티티를 제거하면 데이터베이스의 데이터도 삭제된다. 고아 객체 제거 기능은 영속성 컨텍스트를 플러시 할 떄도 적용되므로 플러시 시점에서 delete sql이 실행된다.
* 모든 자식 엔티티를 제거하려면 다음 코드처럼 컬렉션을 비우면 된다.
```java
parent1.getChildren().clean();
```
* 고아 객체를 정리해보자. **고아 객체 제거는 참조가 제고된 엔티티는 다른 곳에서 참조하지 않ㄹ은 고아 객체로 보고 삭제 하능 기능이다**.
* 따라서 이 긴능은 참조하는 곳이 하나일 때만 사용해야 한다. 쉽게이야기해서 특정 엔티티가 개이 소유 하는 엔티티에만 이 긴능을 적용해야 한다. 만약 삭제한 엔티티를 다른 곳에서 참조한다면 무제가 발생할 수있다.
* 이런 이유로 `orphanRemoval = true`은 `@OneToOne`, `@OneToMany` 에서만 사용할 수있다.

### 정리
* JPA 구현체들은 객체 그래프를 마음껏 탐색할 수 있도록 지원하는데 이때 프록시 기수을 사용한다.
* 객체를 조회할 때 연관된 객체를 즉시 로딩하는 방버을 즉시 로딩이라 하고, 연관된 객체를 지연해서 로딩하는 방법을 지연 로딩이라 한다.
* 객체를 저장하거나 삭제할 떄 연관된 객체도 함께 저장하거나 삭제할 수있는데 이것을 영속성 전이라 한다.
* 부모 엔티티와 연관계가 끊어진 자식 엔티티를 자동으로 삭제하려면 고아 객체 제거 기능을 사용하면된다.


## 09 값 타입
* JPA의 데이터 타입은 가장 크게 분류하면 엔티티 타입과, 값 타입을 나눌 수 있다.
* 엔티티 타입튼 `@Entity`로 정의하는 객체이고, 값 타입은 int, Interger, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체를 말한다.
* 엔티티 타입은 식별자를 통해서 지속해서 추적할 수있지만, 값 타입은 식별자가 없고 숫자나 문자같은 속성만 있으므로 추적할 수없다. 예를들어 회원 엔티티라는 것은 그 회원의 키나 나이 값을 변경해도 같은 회원이다. 심지어 그 회원의 모든 데이터를 변경해도 식별자만 유지하면 같은 회원으로 인식 할 수있다. 반면에 숫자 값을 100을 200으로 변경하면 완전히 다른 값으로 대체된다
* 비유하자면 엔티티 타입은 살아있는 생물이고, 값 타입은 단순한 수치정보이다.
* 기본 타입
	- 자바 기본 타입 : int, double
	- 래퍼 클래스 : Integer
	- String
* 임베디드 타입
	- 복합 값 타입
* 컬렉션 값


### 기본 타입
* Memeber 엔티티는 id라는 식별자 값도 가지고 새명주기도 있지만 값 타입은 name, age 속성은 식별자 값도 없고 샐명주기도 회원 엔티티에 의존한다. 따라서 회원 엔티티 인스턴스를 제거하면 name, age 값도 제거 된다. 그리고 값 타입은 공유하면 안된다.
* 예를 들어 다른 회원 엔티티의 이름을 변경한다고 해서 나의 이름까지 변경되는 것은 상상하기도 싫을 것이다

### 임베디드 타입(복합 값 타입)
* 새로운 값 타입을 직접 정의해서 사용할 수있는데, JPA에서 이것을 임베디드 타입 이라 한다. 중요한 것은 직접 정의한 임베디드 타입도 int, String 처럼 값 타입이라는 것이다.

```java
@Temporal(TempoalType.DATE) java.util.date starstDate;
@Temporal(TempoalType.DATE) java.util.DATE endDate

private String citty;
private String street;
private String zipcode;
```

* 회원 엔티티는 이름, 근무 시작일, 근무 종료일, 주소 도시, 주소 번지, 주소 우편 번호를 가진다
* 이런 설명은 단순히 정보를 풀어 둔 것뿐이다. 그리고 근무 시작일과 우편번호는 서로 아무 관련이 없다. 이것보다 다음처럼 설명하는것이 더 명확하다
* 회원 엔티티는 이름, 근무 기간, 집주소를 가진다.
* 회원이 상세한 데이터를 그대로 가지고 있는 것은 객체지향적이지 않으ㅕ 응집력만 떨어뜰인다. 대신에 근무 기간, 주소 같은 타입이 ㅇ있다면 코드가 더 명확해질것이다


```java
@Entity
public class Member {
	@Id
	private Long id;

	private String name;

	@Embedded Period workPeriod; // 근무기간
	@Embedded Address homeAddress; // 집주소
}

@Enbeddable
public class workPeriod{
	@Temporal (TemporalType.DATE) java.util.Date startDate;
	@Temporal (TemporalType.DATE) java.util.Date endDate;

	public boolean isWork(Date date){
		//값 타입을 위한 메소드를 지정할 수있다
	}
}

@Enbeddable
public class Address {
	@Column (name = "city") // 매핑할 컬럼 정의
	private String city;
	private String street;
	private String zipcode;

}
```
* `startDate`, `endDate`를 합해서 Period기간 클래스를 만들었다
* `city`, `street`, `zipcode`를 합해서 Address 주소 클래스를 만들었다.
* 새로 정의한 값 타입들은 재사용할 수 있고 응집도가 아주 높다. 또한 `isWork`처럼 해당 값 타입만 사용하는 의미 있는 메소들도 만들 수있다.
* `@Embeddable` : 값 타입을 정의하는 곳에 표시
* `@Embedded`: 값 타입을 사용하는 곳에 표시

### 임베디드 타입과 테이블 매핑
* 임베디드 타입은 엔티티의 값일 뿐이다. 따라서 값이 속한 엔티티의 테이블에 매핑한다.
* 임베디드 타입 덕분에 객체와 테이블을 아주 세밀하게 매핑하는 것이 가능하다
* 잘 설계한 OMR 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많다
* ORM을 사용하지 않고 개발하면 테이블 칼럼과 객체 필드를 대부분 1:1 매핑한다
* 주소나 근무 기간 같은 값 타입 클래스를 만들어서 더 객체지향적으로 개발하고 싶어도 SQL을 직접 다루면 테이블 하나에 클래스 하나를 매핑하는 것도 고단한 작업인데 테이블 하나에 여러 클래스를 매핑하는 것은 사상하기도 싫을 것이다.
*
