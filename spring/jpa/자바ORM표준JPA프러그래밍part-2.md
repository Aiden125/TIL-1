## 10 객체지향 쿼리 언어
* JPA는 복잡한 검색 조건을 사용해서 엔티티 객체를 조회 할 수있는 다양한 쿼리 기술을 지원한다.
	- JPQL, Criteria, QueryDSL 등이 있다

### 객체지향 쿼리 소개
* EntityManager.find() 메소드를 사용하면 식별자로 엔티티 하나를 조회할 수있다. 이렇게 조회한 엔티티에 객체 그래프 탐색을 사용하면 연관된 엔티티들을 찾을 수 있다.
* 식별자로 검색 EntityManager.find();
* 개체 그래프 탐색 a.getB().getC();

* 이 기능만으로 애플리케이션 개발하기는 어렵다. 예를들어 나이가 30살 이상인 회원을 모두 검색하고 싶다면 좀더 현실적이고 복잡한 검색 방법이 필요하다
* 그렇다고 모든 회원 엔티티를 메모리에 올려두고 애플리케이션에서 30살 이상 인 회원을 검색하는 것은 현실성이 없다. 결국 데이터는 데이터베이스에있으므로 SQL로 필요한 내용을 최대한 거러서 조회햐야 한다
* 하지만 ORM을 사용하면 테이블이 아닌 엔티티 객체를 대상으로 하는 방법이 필요하다
* JPQL은 이런 문제를 해결하기 위해서 만들어졌는데 다음과 같은 특징이 있다.
	- 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리다.
	- SQL은 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다
* SQL이 데이터베이스 테이블을 대상으로 하는 데이터 중심 쿼리라면 JPQL은 엔티티 객체를 대상으로 하는 객체지향 쿼리다.
* JPQL을 사용하면 이 JPQL을 분석한 다음 적절한 SQL을 만들어 데이터베이스를 조회한다. 그리고 조회한 결과로 엔티팇 객체를 생성해서 반환한다
* JPQL은 한마디로 정의하면 객체지향 SQL이다. 처음 보면 SQL로 오해할 정도로 문법이 비슷하다
* JPA는 JPQL뿐만 아니라 다양한 검색 방법을 제공한다. 다음은 JPA가 공식지원하는 기능이다.
	- JPQL
	- Criteria 쿼리 : JPQL을 편하게 작성하도록 조와주는 API, 빌더 클래스 모음
	- 네이티브 SQL : JPA에서 JPQL 대신 직접 SQL을 사용할 수있다
* 다음은 JPA가 공식 지원하는 기능은 아니지만 알아둘 가치가 있다.
	- QueryDSL : Criteria 쿼리처럼 JPQL을 편리하게 작성하도록 도와주는 빌더 클래스 모움, 비표준 오픈소스 프레임워크이다.
	- JDBC 직접 사용, MyBatis같은 SQL 매퍼 프레임워크사용

### JPQL 소개
* JPQL은 엔티티 객체를 조회하는 객체지향 쿼리다.
* JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다.
* 데이터베이스 방언만 변경하면 JPQL을 수정하지 않아도 자연스럽게 데이터베이스를 변경할 수 있다.
* JPQL은 SQL보다 간결하다

```java
String jpql = "select m from Member as m where m.username = 'kim'";
List<Member> resultList = em.creeatedQuery(jpql, Member.class).getResultList();
```

* 회원이르이 kim인 엔티티를 조회한다. JPQL에서 Member는 엔티티 이름이다 그리고 u.sername은 테이블 칼럼명이 아니라 엔티티 객체의 필드 명이다.

### Criteria 쿼리소개
* Criteria는 JPQL을 생성하는 빌더 클래스다. Criteria의 장점은 문자가 아닌 `query.select(m).where(..)` 처럼 프로그래밍 코드로 JPQL을 작성할 수있다는 좀이다.
* 이러한 점은 문자열에 오타 같은 실수를 런타임 에러시에 잡기 힘든 부분을 보안
	- IDE에서 지원 받으면 어느정도 해결 가능할거같음
* 컴파일 시점에 오류를 발견할 수있다.
* IDE를 사용하면 코드 자동완성을 지원한다
* 동적 쿼리를 작성하기 편하다

### QueryDSL 소개
* QueryDSL도 Criteria 처럼 빌더 역할을 한다. QueryDSL의 장점은 코드 기반이며 단순하고 사용하기 쉽다. 그리고 작성한 코드도 JPQL 과 비슷해서 가독성이 좋다
* QueryDSL과 Criteria 비교하면 Criteria는 너무 복잡하다

```java
JPAQuery query = new JPAQuery(em);
QMember member = Qmember.member;

List<Memeber> members = query.from(member).where(member.username.eq("kim")).list(member);
```
* `QMember`는 Member 엔티티 클래스를 기반으로 생성한 QueryDSL 쿼리 전용 클래스다.

### 네이티브 SQL 소개
* JPA는 SQL을 직접사용할 수있는 기능을 지원흔데 이것을 네이티브 SQL이라 한다.
* JPQL을 사용해도 가끔은 특정 데이터베이스에 의존하는 기능을 사용해야할때 사용한다.

### JPQL
* 어떤 방법을 사용하든 JPQL에서 모든 것이 시작된다
* 이론은 소개 절에서 이미 설명했으니 JPQL의 사용 바업 위주로 설명하겠다
* JPQL은 객체지향 쿼리 언어다. 따라서 테이블을 대상으로 쿼리하는 것이 아니라 엔티ㅣㅌ 객체를 대상으로 쿼리한다.
* JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.
* JPQL은 결국 SQL로 변환된다.

### 기본 문법과 쿼리 API
* JPQL도 SQL과 비슷하게 select, update, delete 문을 사용할 수있다.
* 참고로 에니팉 저장할 떄는 EntityManager.persist() 메소드를 사용하면 되므로 insert 문은 없다.
*
```SQL
select_문 :: =
	select_절
	from_절
	[where_절]
	[group by_절]
	[having_절]
	[orderBy_절]

update_문 :: = update_절 [where_절]
delete_문 :: = delete_절 [where_절]
```
### SELECT 문

```sql
select m from Member as m where m.username = 'Hello'
```
* 대소문자 구분
	- 엔티티와 속성은 대소문자를 구분한다. 예를 들어 Member, username은 대소문자를 구분한다. 반면 select, from as 같은 JPQL 키워드는 갯문자를 구분하지 않는다.
* 엔티티 이름
	- JPQL에서 사용하는 Member는 클래스 명이 아니라 엔티티 명이다. 엔티티 명은 `@Entity`로 지정할 수있다. 엔티티 명을 지정하지 않으면 클래스 명을 기본값으로사용한다
* 별칭은 필수
	- Member as m 을 보면 member에 m이라는 별을을 주었다. JPQL은 별칭을 필수로 사용해야한다.

### TypeQuery, Query
* 작성한 JPQL을 실행하려면 쿼리 객체를 만들어야 한다. 쿼리 객체는 TypeQuery와 Query가 있는데 반환할 타입을 명확하게 지정할 수 있으면 TypeQuery를 객체를 사용하고 반환 타입을 명확할게 지정할 수 없으면 Query 객체를 사용하면된다.

### TypeQuery 사용
```java
TypedQuery<Member> query = em.createQuery("select m from Member m", Member.class)

List<Member> resultList = query.getResultList();
for(Member meber : resultList){
	System.out.println("member =" + member);
}
```
* ` em.createQuery()`의 두 번째 파라미터에 반환할 타입을 지정하면 TypeQuery를 변환하고 지정하지 않으면 query를 반환한다. 조회 대상이 Member 엔티티이므로 조회 대상 타입이 명확하다. 이럴 때 `TypedQuery`를 사영한다.


### Query 사용

```jqva
Query query = em.createQuery("select m.usrname, m,age from Member m");
List resultLsit = query.getResultList();
```
* 조회 대상이 stirng 타입인 회원 이름과 integer 타입인 나이이므로 조회 대상 타입이 명호가하지 않다. 이 처럼 select 절에서 여러 엔티티나 칼럼을 선태갛ㄹ 때 반환 타입이 명확하지 않으므로 query객체를 사용해야한다.

### 결과조회
* query.getResultLsit() : 결과를 예제로 변환한다 만약 결과가 없다면 빈 컬랙션을 반환한다.
* query.getSingleResult() : 결과가 정확히 하나일 때 사용한다.
	- 결과가 없으면 예외가 발생한다.
	- 결과과 1개 보다 많으면 예외가 발생한다.
	-
### 파라미터 바인딩

* JDBC는 위치 기준 파라미터 바인딩만 지원하지만 JPQL은 이름 기준 파라미터 바인딩도 지원한다

* 이름 기준 파라미터
	- 이름 기준 파라미터는 파라미터 이름으로 구분하는 방법이다. 이름 기준 파라미터는 앞에 : 를 사용한다.

### 프로젝션
* SELECT 절에 조회할 대상을 지정하는 것을 프로젝션 이라 하고 `[select {프로젝션 대상} from]` 으로 대상을 선택한다.
* 프로젝션 대상은 엔티티, 임비디드 타입, 스칼라 타입이 있다.

### 집합과 정렬
```SQL
select
	count(m), //회원수
	sum(m.age), //나이 합
	AVG(m.age), //평균 나이
	max(m.age), //최대 나이
	min(m.age), //최소 나이
```

함수, 설명
count, 결과 수를 구한다. 반환 타입 Long
max | min, 최대 최소 구한다 문자 숫자 날짜 등에 사용한다.
avg, 평균값을 구한다 숫자타입만 사영할 수있다 반환 타입 Double
sum, 합을 구한다 숫자 타입만 사용할 수있다 long, doulbe 타입등


### JPQL 조인

#### 내부 조인
```SQL
select m from Member m inner join m.team t where t.name = :teamName
```
* inner를 생략할 수있다

#### 외부 조인
```SQL
select m
from Member m
left [outer] join m.team t
```

* 외부 조인은 기능상 SQL의 외부 조인과 같다.
* outer 생략 가능해서 보통 생략한다

### 컬랙션 조인

* 일대다 관계나 다대다 관계처럼 컬랙션을 사용하는 곳에 조인하는 것을 컬랙션 조인이라 한다.
	- `[회원 -> 팀]` 으로 조인을 다대일 조인이면서 단일 값 연관 `m.team `를 사용한다.
	- `[팀 -> 회원]` 은 반대로 일대다 조인이면서 컬렉션 연관 필드 `m.members`를 사용한다.

### 세타 조인
```SQL
select count(m) from Member m, Team t
where m.username = t.name
```
* where 절을 사용해서 세타 조인을 할 수있다. 참고로 **세타 조인은 내부 조인만 지원한다.**
* 세타 조인은 전혀 관계없는 엔티티도 조인할 수 있다.

### JOIN ON 절 (JPA 2.1)
```sql
select m, t from Member m
left join m.team on t.name = 'A'
```
* 2.1 부터 조인할 때 on 절을 지원한다. on 절을 사용하려면 조인 대상을 필터링 하고 조인할 수있다
* 참고로 내부 조인은 on 절은 where 절을 사용할 때와 결과 가 같으므로 보통 on 절은 외부 조인에서만 사용한다.

### 패치 조인
* 패치 조인은 SQL에서 이야기하는 조인의 종류는 아니고 JPQL에서 성능 최적화를 위해 제공하는 기능이다
* 이것은 연관된 엔티티나 컬랙션을 한번에 같이 조회하는 기능인데 join fetch 명령어로 사용할 수있다.

#### 엔티티 페치 조인
* 페치 조인을 사용해서 회원 엔티티를 조회하면 연관된 팀 엔티티도함께 조회하는 JPQL을 보자
```java
select m
from Member m join fetch m.team
```
* 예제를 보면 join 다음에 fetch라고 적었다 ㅇ렇게 하면 연관된 엔티티나 컬렉션을 함꼐 조회하는데 여기서 회원과 팀을 함꼐 조회한다.
* 참고로 일반 적인 JPQL 조인과는 다르게 m.team 다음에 별칭이 없는데 페치 조인은 별칭을 사용 할 수없다.
* 하이버네이트 패치 조인 별칠을 허용한다.
* 회원과 팀을 지연 로딩으로 설정했다고 가정해보자. 회원을 조회할 떄 페치 조인을 사용해서 팀도 함꼐 조호ㅚ했으므로 연관된 팀엔티티는 프록시가 아닌 실제 엔티티다 따라서 연관된 팀을 사용해도 지연 로딩이일어나지 않는다. 그리고 프록시가 앙닌 실제 엔티티이므로 회원 엔티티가 영속성 컨텍스트에서 분리되어 준영속 상태가 되어 연관된 팀을 조회할 수있다.

#### 컬렉션 페치 조인
```SQL
select t
from team t join fetch t.members
where t.name = "A팀"
```

### 패치 조인과 일반 조인 차이
* JPQL은 결과를 반환할 때 연관관계까지 고려하지 않는다. 단지 select 절에 지정한 엔티티만 조회할 뿐이다.
* 따라서 팀 엔티티만 조회하고 연관된 회원 컬렉션은 조회하지 않는다. 만약 회원 컬렉션을 지연 로딩으로 설정하면 프록시나 아지직 초기화하지 않은 컬렉션 래퍼를 변환한다. 즉시 로딩으로 설정하면 회원 컬랙션을 즉시 로딩하기 위해 쿼리를 한 번 더 실행한다.
* 반면 패치 조인을 사용하면 연관된 엔티티도 함꼐 조회한다.

### 패치 조인의 특징과 한계
* 패치 조인을 사용하면 SQL 한 번으로 연관된 엔티티들을 함께 조회할 수있어서 SQL 호출 횟수를 줄여 성능을 최적화 할 수있다.
* 엔티티에서 직접 적용하는 로딩 전략은 애플리케이션 전체에 영향을 미치믈 글로벌 로딩 전략이라 부른다.
* 패치 조인은 글로벌 로딩 전략보다 우선한다
* 최적화를 위해 글로벌 로딩 전략을 즉시 로딩으로 설정하면 애플리케이션 전체에서 항상 즉시로딩이 이렁난다
* 물론 일부는 빠를 수 있지만 전체로 보면 사용하지 않은 엔티티를 자주 로딩하므로 오히려 성능에 악영향을 미칠 수있다
* **따라서 글로벌 로딩 전략은 될 수 있으면 지연 로딩을 사용하고 최적화가 필요하면 패치조인을 사용하는 것이 좋다**
* 또한 패치 조인을 사용하면 연관된 엔티티를 쿼리 시점에 조회하므로 지연 로딩이 발생하지 않는다 따라서 준영속 상태에서 갹체 그래프를 탐색할 수있다.

#### 패치 조인 한계
* 문법을 자세히 보면 페치 조인에 별칭을 정의하는 내용이 없다 따라서 select, where 절 서브 쿼리에 패치 조인 대상을 사용할 수없다
* JPA 표준에서는 지원하지 않지만 하이버네이트를 포함한 몇몇 구현체들은 페치 조인에 별칭을 지원한다
* 하지만 별칭을 자롯 사용하면 연관된 데이터 수가 달라져 데이터 무결성이 꺠질 수 있으므로 조심해야 한다
* 특히 2차 캐시와 함꼐 사용할 때 조심해야 하는데 연관된 데이터가 수가 달라진 상태에서 2차 캐시에 저장되면 다른 곳에서 조회할 떄도 연관된 데이터 수가 달라지는 문제가 발생할 ㅜㅅ  있다.
* 둘 이상의 컬렉션을 페치할 수없다
* 컬렉션 패치 조인하면 페이징 API를 사용할 수 없다.
	- 컬력센이 아닌 단일 값 필드들은 패치 조인하면 사용해도 페이징 API를 사용할 수있다
	- 하이버네이트는 컬렉션 패치 조인하고 페이징 API를 사용하려면 경고 고르를 남기면서 메리로에 페이징 처리를 한다 데이터가 작으면 상관 없지만 데이터가 많으면 성능이슈오ㅓ 메모리 초과 예와가 발생할 수있어 위험하다.
* 패치 조인은 SQL 한 번으로 연관된 여러 엔티티를 조회할 수있어서 성능 최적화에 상당히 유용하다.
* 그리고 실무에서 자주 사용하게 된다. 하지만 모든 것을 패체 조인으로 해결 할 수는 없다. 패치 조인은 객체 그래프를 유지할 때사용하면 효과적이다. 반면 여러 테이블을 조인해서 인티티가 가진 모양이 아닌 전혀 다른 결과를 내여 한다면 억지로 패치 조인을 사용하는 것보다 여러 테이블에서 필요한 필드를 조회해서 DTO로 변환 하는것이 더 효율적일 수있다.



## 12 스프링 데이터 JPAQuery
* 스프링 데이터 JPA는 스프링 프레임워크에서 JPA를 편하게 사용할 수 있도록 지원하는 프로젝트다.
* 이 프로젝트는 데이터 저근 계층을 개발할 때 지루하게 반복되는 CRUD 문제를 세련된 방법으로 해결한다.
* 우선 CRUD를 처리하기 위한 공통 실행시점에 스프링 데이터 JPA가 구현 객체를 동적으로 생서해서 주입해준다
* **따라서 데이터 접근 계층을 개발할 때 구현 클래스 없이 인터페이스만 작성해도 개발을 완료 할 수있다**
* 일반전인 CURD 메소드는 JpaRepository 인터페이스가 공통으로 제공하므로 문제가 없다.
* 근데 `MemberReopsitory.findByUsername` 처럼 직접 작성한 공통으로 처리 할 수없는 메소드들은 스프링 데이터 JPA는 메소드 이름을 분석해서 다음 JPQL을 실행한다.

### 스프링 데이터 프로젝트

* 스프링 데이터 프로젝트는 JPA, 몽고 DB, NEO4J, REDIS, HADOOP, GEMFIRE 같은 다양한 데이터 저장소에 대한 적ㅂ근을 추상화해서 개발자 편의를 제공하고 지루하게 반복하는 데이터 접근 코드를 줄여준다.

### 고통 인터페이스 기능
* 스프링 데이터 JPA는 간단한 CRUD 기능을 공통으로 처리하는 JpaRepository 인터페이스를 제공한다.
* 스프링 데이토 JPA를 사용하는 가장 단순한 방법은 인터페이스를 상속 받는 것이다.

### 주요 메소드
* save(S): 새로운 엔티티는 저장하고 이미 있는 엔티티는 수정한다.
* delete : 엔티티 하나를 삭제한다
* findOne(id) : 엔티티하나를 조회한다.
* getOne 엔티티를 프록시로 조회한다.
* findAll: 모든 엔티티를 조회한다 정렬이나 페이징 조건으로 파라미터로 제공할 수있다.

### 쿼리 메소드 기능
* 쿼리 메소드 기능은 스프링 데이터 JPA가 제공하는 마법 같은 기능이다. 대표적으로 메소드 이름만으로 쿼리를 생성하는 기능이 있는데 인터페이스에 메소드만 선언하면 해당 메소드의 이름으로 적절한 JPQL 쿼리를 생성해서 실행한다.

	* 메소드 이름으로 쿼리 생성
	* 메소드 이름으로 JPA NamedQuery 호출
	* `@Query` 어노테이션을 사용해서 리포지토리 인터페이스 쿼리 직접 정의

### 메소드 이름으로 쿼리 생성

```java
List<Member> findByEmailAndName(String email, String name)
```
* 인터페이스에 정의한 findByEmailAndName 메소드를 실행하면 스프링 데이터 JPA는 메소드 이름을 분석해서 JPQL을 생성한다
```SQL
select m from Member m.email =?1 and m.name = ?2
```
### JPA NamedQuery
* 스프링 데이터 JPA는 메소드 이름으로 JPA Named 쿼리를 호출하는 기능을 제공한다.
* JPA Named 쿼리는 이름 그대로 쿼리에 이름을 부여해서 사용하는 방법이다

```java
List<Member> findByUsername(@Param("username") String username);
```

### 벌크 수정 쿼리

```java
@Modifying
@Query("update Product p set p.price =p.price * 1.1 where p.stockAomunt < :stockAmouint")
int bulkPriceUp(@Param("stockAmount") String StockAmount)
```
* 스프렝 데이터 JPA에서 벌성 수정 삭제 쿼리는 `@Modifying` 어노테이션을 사용하면된다


### 힌트
* JPA 쿼리 힌트를 사용하려면 `@QueryHint` 어노테이션을 사용하면 된다.

### 명세
* 책 도메인 주도 설계는 명세 라느 개념을 소개하는데 스프링 데이터 JPA는 JPA Criteira로 이 개념을 사영할 수 있또록 지원한다
* 명세를 이해하기 위해 핵심 단어는 술어 인데 이것은 단순히 참이나 거짓으로 평가된다
* 그리고 이것은 AND, OR 같은 연산자로 조합할 수있다
* 예를 들어 데이터 검색하기 위한 제약 조건 하나하나를 수어라 할 수있다 이 술어를 스프링 데이터 JPA는 Sepecitication 클래스로 정의 했다.


## 13 웹 애플리케이션과 영속성 관리

* 스프링이나 J2EE 환경에서 JPA를 사용하면 컨에티너가 트랙잭션과 영속성 컨텍스트를 관리해주므로 앺를리케이션을 손쉽게 개발 할 수있다.
* 하지만 컨테니어 환경에서 동작하는 JPA의 내부 동작 방식을 이해하지 못하면 문제가 발생했을 때 해결하기가 쉽지 않다
* JPA가 동작하는 내부 동작을 이해하고 컨테이너 환경에서 웹 애플리케이션을 개발할 대 ㅏㄹ생ㅎㄹ 수 있는 다양한 문제점과 해결 방을 알아보자

### 스프링 컨테이너의 기본 전략

* 스프링 컨테이너는 트랙잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용한다.
* 이 전략은 이름 그대로 트랜잭션의 범위와 영속성 컨텍스트의 생존 범위가 같다는 뜻이다. 좀더 풀어 이야기 해보자면 트랙잭션을 시작 할 때 영속성 컨텍스트를 생성하고 트랜잭션이 끝날 때 영속성 컨텍스트를 종료한다. 그리고 같은 트랜잭션 안에서 항상 같은 영속성 컨텍스트에 접근한다.
* 스프링 프레임워크를 사용하면 보통 비지니스 로직을 시작하는 서비스 계층에 `@Transactional` 어노테이션을 선언해서 트랜잭션을 시작한다. 외부에서는 단순히 서비스 계층의 메소드를 시작하는 것처럼 보이지만 이 어노테이션이 있다면 호출한 메소드를 실행하기 직전에 스프링의 트랜잭션 AOP가 먼저 동작한다.
* 스프링 트랜랜잭션 AOP는 대상 메소드를 호출하기 직전에 트랜잭션을 시작하고, 대상 메소드가 정상 종료되면 트랜잭션을 키밋하면서 종료한다. 이때 아주 중요한 일이 일어나느데 트랜잭션을 커밋하면 JPA는 먼저 영속성 컨ㅌㄱ스트를 플러시해서 변경 내용을 데이터베이스에 반영한 후에 데이터베이스 트랜잭션을 커밋한다. 따라서 영속성 컨텍스트의 변경 내용이 데이터비엣에 정상 반영된다. 만역 예외가 발생하면 트랜잭션을 롤백하고 종료하는데 이 떄는 플러시를 호출하지 않는다.

#### 트랜젹신이 같으면 같은 영속성 컨텍스트를 사용한다.
* 트랜잭션 범위의 영속성 컨텍스트 전략은 다양한 위치에서 엔티티 매니저를 주입받아 사용해도 트랜잭션이 같으면 항샅 같은 영속성 컨텍스트를 사용한다.
* 만약 엔티티 매니저를 사용하는 A,B 코드는 모두 같은 트랜잭션 범위에 있다면, 엔티티 매니저는 달라도 같은 영속성 컨텍스트를 사용한다.

#### 트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다.
* 여러 스레드에서 동시에 요청이 와서 같은 엔티티 매니저를 사용해도 트랜잭션에 따라 접근하는 영속성 컨텍스트가 다르다.
* 조금더 풀어서 이야기하자면 스프링 컨테이너는 스레드마다 각각 다른 트랜잭션을 할당한다. 따라서 같은 엔티티 매니저를 호출해도 접근하는 영속성 컨텍스트가 다르므로 멀티스레드 상황에 안전하다.

### 준영속 상태와 지연로딩
* 트랜잭션은 보통 서비스 계층에서 시작하므로 서비스 계칭이 끝나는 시점에 트랜잭션이 종료되면서 영속성 컨텍스트로 함께 종료된다.
* 따라서 조회한 엔티티가 서비스 리포지토리 계층에서는 영속성 컨텍스트에 관리되면서 영속 상태를 유지하지만 컨트롤러나 뷰 같은 프리젠테이션 계층에서는 준영속 상태가된다.

#### 준영속 상태와 변경감지
* 변경 감지 기능은 영속성 컼ㄴ텍스트가 살아 있는 서비스 계층 까지만 동작하고 영속성 컨텍스트가 죵료된 프리젠테이션 계층에서는 동작하지 않는다. 보통 변경 감지 기능은 서비스 계층에서 비지니스 로직을 수행하면서 발생한다. 단순히 데이터를 보여주기만 하는 프리젠테이션 계층에서 데이터를 수정할 일은 거의 없다. 오히려 변경 감지 기능이 프리젠테이션 계층에서 동작하면 애플리케이션 계층이 가지는 책임이 모호해 지고 무엇보다 데이터를 어디서 어떻게 변경 했는지 트리젠테이션 계층까지 다 찾아야 하므로 애플리케이션 유지보수하기가 어렵다.
* 비지니스 로직은 서비스 계층에서 끝내고 프리젠테이션 계층에서 동작하지 않은 것은 특별히 문제가 되지 않는다.

#### 준영속 상태와 지연로딩
* 준영송 상태의 가장 골치 아픈 문제는 지연 로링 기능이 동작하지 않는다는 점이다. 예를 들어 렌더링할 때 연관된 엔티티도 함께 사용해야 하는데 연관된 엔티티를 지연 로딩으로 설정해서 프록시 객체로 조회했다고 가정하자. 아직 초기화되지 않은 프록시 객체를 사용하면서 실제 데이터를 불러오려고 초기화를 시도한다. 하지만 준영속 상태는 영속 컨텍스트가 없음으로 하이버네이트 구현제로 사용하면 LazyInitinalztionExcepiton 예외가 발생한다

* 준영속 상태의 지연 로딩 문제를 해결하는 방법은 크게 2가지가 있다.
	- 뷰가 필요한 엔티티를 미리 로딩해두는 방법
	- OSIV를 사용해서 엔티티를 항상 영속 상태로 유지하는 방법

#### 뷰가 필요한 엔티티를 미리 로딩해두는 방법
* 뷰가 필요한 덴티티를 미리 로딩해두는 방법은 어디서 미리 로딩하느냐에 따라 3가지 방법이있다.
	1. 글로벌 페치 전략 수정
	2. JPAQL 폐치 조인
	3. 강제로 초기화

##### 1. 글로벌 페치 전략 수정

*  가장간단한 방법은 글로벌 패치 전략을 지연 로딩에서 즉시 로딩으로 변경하면된다.
```java
@ManyToOne(fetch = Fetchtype.EAGER)// 즉시 로딩 전략
```
* 엔티티에 있는 `fetch` 타입을 변경하면 애플리케이션 전체에서 이 엔티티를 로딩할 때마다 해당 전략을 사용하므로 글로벌 페지 전략이라 한다. 엔티티 매니저로 주문 엔티티를 조회하면 연관된 member 엔티티도 함상 함께 로딩한다.
```java
Order order = em.find(Order.class, orderId);
List<Order> orders = em.createQuery("select o from Order o")
```

* order와 orders 모두 연관된 member 엔티티를 미리 로딩해서 가진다. 따라서 준영속 상태가 되어도 member를 사용할 수 있다. 하지만 이렇게 글로벌 페지 전략을 즉시 로딩으로 설정하는 것은 2가지 단점 이 있다

###### 글로벌 페치 전략에 즉시 로딩 사용 시 단점
* 사용하지 않은 엔티티를 로딩한다.
	- 예를 드렁 사용자 A에서 order와  member 둘 다 필요해서 글로벌 전략을 즉시 로딩으로 설정했다.
	- 반면 화면 B는 order 엔티티만 있으면 충분하다. 하지만 화면 B는 즉시 로딩 전략으로 인해 order를 조회하면서 사용하지 않는 member도 함꼐 조회하게 된다.
* N + 1 문제가 발생한다
	- JPA를 사용하면서 성능상 가장 조심해야 하는 것이 N + 1 문제다.
	- `em.find()` 메소드로 엔티티를 조회할 때 연관된 엔티티를 로딩하는 전략이 즉시 로딩이면 데이터베이스에 JOIN 쿼리를 사용해서 한 번에 연관된 엔티티까지 조회한다. 다음 예제는 `Order.member`를 즉시 로딩으로 설정했을 경우 실행되는 SQL은 다음과 같다.

###### N + 1 문제
```sql
select o.* m.*
from Order o
left outer join Member m on o.MEMBER_ID=m.MEMBER_ID
where o.id =1
```
* 실행된 SQL을 보면 즉시 로딩으로 설정한 member 엔티티를 조인 쿼리로 함꼐 조회한다. 여기까지 보면 글로벌 즉시 로딩 전략이 상당히 좋아보이지만 문제는 JPQL을 사용할 때 발생한다.
* 위처럼 즉시 로딩으로 설정했다고 가정하고 JPQL로 조회 해보자

```java
List<Order> orders = em.createQuery("select o from Order o", Order.class)
	.getResultList(); // 연과된 모든 엔티티를 조회한다.
```
* 실행된 SQL은 다음과 같다.

```
