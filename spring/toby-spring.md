# 토비의 스프링



### 1.7

#### 제어의 역전(IoC)과 의존선 주입
* DaoFactory처럼 객체를 생성하고 관계를 맺어주는 등의 작업을 담당하는 기능을 일반화 한것이 스프링의 IoC 컨테이너이다.
* IoC는 매우 느슨하게 정의돼서 폭넓게 사용되는 용어라는 점 때문에 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못한다
* 그래서 스프링이 제공하는 IoC 방식을 핵심을 짚어주는 의존관계 주입(DI)라는, 좀더 의도가 명확히 드러나는 이름을 사용하기 시작함

### 1.5.3

* 빈
  - 빈 또는 빈 오브젝트는 스프링이 IoC 방식으로 관리하는 오브젝트 라는 뜻이다. 관리되는 오베직트라고 부르기도한다. 주의할 점은 스프링을 사용하는 애플ㄹ케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니라는 사실이다. 그중에서 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 부른다.
* 빈 팩토리
  - 스프링의 IoC를 담당하는 핵심 컨테이너를 가리킨다. 빈을 등록하고, 생성하고 조회하고 둘려주고, 그 외에 부가적인 빈을 관리하는 기능을 담당한다.
* 어플리케이션 컨텍스트
  - 빈 팩토리를 확장한 IoC 컨테이너다. 빈을 등록하고 관리하는 기본적인 기능을 빈 팩토리와 동일하다. 여기서 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다. 빈 팩토리라고 부를 때는 주로 빈의 생성과 제어의 관점에서 이야기하는 것이고 애플리케이션 컨텍스트라고 할 때는 스프링이 제공하는 에플리케이션 지원기능을 ㅁ두 포함해서 이야깋는 것이라고 보면 된다.
* 설정정보/설정 매타정보
  - 스프링의 설정정보란 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해서 사용하는 매타정보로 말한다. 영어로 `configuration` 이라고 한다.

### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트

#### 서버 애플리케이션과 싱글톤
* 내가 아는 거랑 크게 차이 없음

#### 싱글톤 패턴의 한계

### 1.9 정리

* 먼저 책임이 다른 코드를 분리해서 두 개의 클래스로 만들었다.(관심사 분리, 리팩토링)
* 그중에서 바뀔수 있는 쪽의 클래스는 인터페이스를 구현하도록 하고, 다른 클래스에서 인터페이스를 통해서만 접근하도록 만들었다. 이렇게해서 인터페이스를 정의한 쪽의 구현 방법이 달라져 클래스가 바꿔더라도, 그 기능을 사용하는 클래스는 코드는 같이 수정할 필요가 없도록 만들었다 잔략 패턴
* 이를 통해 자신의 책임 자체가 변경되는 경우 외에는 불필요한 변화가 발생하지 않도록 막아주고, 자신이 사용하는 외부 프로젝트의 기능은 자유롭게 확장하거나 변경할 수있게 만들었다. (OCP)
* 결국 한쪽의 기능 변화가 다른 쪽의 변경을 요구하지 않아도 되게 했고 자신의 책임과 관심사에만 순수하게 집줒ㅇ하는 깔금한 코드를 만들 수있었다.
* 오브젝트가 생성되고 여타 오브젝트와 관계를 맺는 작업의 제어권을 별도의 오브젝트 팩토리를 만들었 넘겼다 또는 오브젝트 팩토리의 기능을 일반화 IoC 컨터이너로 넘겨서 오브젝트가 자신이 사용할 대상의 생성이나 선택에 관한 책임으로 부터 자우롭게 만들어줬다(제어의 역전 /IoC)
<<<<<<< HEAD


# 3장 템플릿

확장에는 자우롭게 열려 있고 변경에는 굳게 닫혀 있다는 객체지향 설계의 핵심 원칙인 개방 폐쇄 원칙 OCP를 다시한 번 생각해보자.

변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조를 만ㄷㄹ어주는 것이 바로 개방 폐쇄 원칙이다.

템플릿이란 이렇게 바꿔는 서징이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특정을 가진 부분을 자유롭게 변경되는 성질을 가진부븐으로 부터 독립시켜 효과적으로 확용할 수있도록 하는 방법이다.

# 4장 예외

## Error
에러는 시스템에 뭔가 비정상 적인 상황이 발생했을 경우 사용된다. 그래서 주로 VM에서 발생시키는 것이고 애플리케이션 코드에서 잡으려고하면 안된다. OutOfMemoryError나 ThreadDeath 같은 에러는 catch 블록으로 잡아봤자 아무런 대응 방법이 없기 때문이다. 따라서 이런 시스템 레벨에서 특별한 작업을 하는게 아니라면 애플리케이션에서는 이런 에러에 대한 처리는 신경 쓰지 않아도 된다.

## Exception과 체크 예외

일반적으로 예외라고 하면 Exception 클래스의 서브클래스 중에서 RuntimeException을 상속하지 않은 것만을 말하는 체크 예외라고 생각해도된다. 체크 예외가 발생할 수 있는 메소드들은 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야한다. 아니면 다시 throw를 정의해서 메소드 밖으로 던저야한다. 그렇지 않으면 컴파일 예러가 발생한다.

## RuntimeException과 언체크/런타임 예외
RuntimeException 클래스를 상속한 예외들은 명시적인 예외처리를 강제 하지 않기 때문에 언체크 예외라고 불린다. 대표 클래스 이름을 따서 런타임 예외라고 한다. 에러와 마찬가지로 이 런타임 예외 catch 문으로 잡거나 throw로 선언하지 않아도 된다.

런타임 예외는 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것들이다. 대표적으로 NullPointerEception 등 이 있다.

## 예외 처리 방법

### 예외 복구

예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것이다. 예를 들어 사용자가 파일을 읽으려고 시도했는데 해당 파일이 없거나 다른 문제가 있어서 읽히지가 않아서 IOException이 발생했다고 생각해보자. 이때는 사용자에게 상황을 알려주고 다른 파일을 이용하도록 안내해서 예외사황을 해결할 수 있다.

네티워크가 불안해서 가끔 서버에 접속이 잘 안되는 떄는 SQLException이 발생하는 경우 재시도를 해 볼 수 있다. 특정 횟수 만큼 더 접속을 시도하고도 안돼면 그떄 throw를 발생시 킬 수도 있다.

### 예외처리 회피
예외 처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던저버리는 것이다. throw문으로 선언해서 예외가 발생한다면 알아서 던져지게 하거나 catch문으로 일단 예외를 잡은후에 로그를 남기고 다시 예외를 던지는 것이다.

예외를 자신이 처리하지 않고 회비하는 방법이다. 빈 catch 블록으로 잡아서 예외가 발생하지 않은 것처럼 만드는 경우는, 드물지만 특별한 의도를 가지고 예외를 복구했거나 아무 개념이 없어서 회피하는것만은 아니다.

### 예외 전환
예외 회피와 비슷하게 예외를 복구해서 정상적인 상태로는 만들 수 없기 때문에 예외를 메소드 밖으로 던지는 것이다. 하지만 예외 회피와 달리 발생한 예외를 그대로 넘기는 게 아니라 적절한 예외로 전환해서 던진다는 특징이 있다.
