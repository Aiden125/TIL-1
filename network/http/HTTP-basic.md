# 네트워크의 기본은 TCP/IP

## 계층으로 관리하는 TCP/IP

* TCIP/IP에서 중요한 개념 중 하나가 계층입니다. TCIP/IP는 애플리케이션 계층, 전송 계층, 네트워크 계층, 링크 계층 이렇게 4 계츠으로 나뉘어 있습니다.
* TCIP/IP가 계층화된 것은 메리트가 있기 때문입니다. 예를 들면 인터넷이 하나의 프로토콜로 되어 있다면 어디선가 사양이 변경되었을 때 전체를 바꾸지 않으면 안되지만, 계층화되어 있으면 사양이 변경된 해당 계층만 바꾸면 됩니다. 각 계층은 계층이 연결되어 있는 부분만 결정되어 있어, 각 계층의 내부는 자유롭게 설계할 수 있습니다.
* 계층화하면 설계를 편하게 할 수 있습니다. 애플리케이션 층에서 애플리케이션은 자기 자신이 담당하는 부분을 고려하면 되고, 상대가 어디에 있는지 어떤 루트로 메시지를 전달하는지, 전달할 메시지가 확실하게 전달되고 있는지는 고려 안해도 됩니다.

### 애플리케이션 계층
애플리케이션 계층은 유저에게 제공되는 애플리케이션에서 사용하는 통신의 움직임을 결정하고 있습니다.
TCIP/IP에는 여러 가지의 공통 애플리케이션이 준비되어 있습니다. 예를 들면, FTP, DNS 등도 애플리케이션의 한 가지입니다. HTTP도 이 계층에 포함됩니다. 

### 전송 계층
전송 계층은 애플리케이션 계층에 네트워크로 접속되어 있는 2대의 컴퓨터 사이의 데이터 흐름을 제공합니다. 전송 계층에서 서로 다른 설징을 가진 TCP, UDP두 가지 프로토콜이 있습니다

### 네트워크 계층
네트워크 계층은 네트워크 상에서 패킷의 이동을 다룹니다. 패킬이란 전송하는 데이터의 최소 단위입니다. 이 계층에서 어떠한 경로를 거처 상대방의 컴퓨터까지 패킷을 보낼지를 결정하기도 합니다.

인터넷의 경우라면 상대 컴퓨터에 도달하는 동안에 여러 대의 컴퓨터랑 네티워크 기기를 거쳐 상대방에게 배송됩니다. **그러한 여러 가지 선택지 중에서 하나의 길을 결정하는 것이네트워크 계층의 역할입니다.**

### 링크 계층
네티워크에 접속하는 하드웨어적인 면을 다룹니다. 운영체제가 하드웨어를 제어하기 때문에 디바이스 드라이버와 네티워크 인터페이스 카드(NIC)를 포함합니다. 그리고 케이블 등과 같이 물리적으로 보이는 부분도 포함합니다. 하드웨어적 측면은 모두 링크 계층의 역할입니다.

### TCP/IP 통신의 흐름

![](/assets/tcp-4later.png)

TCP/IP로 통신할 때 계층을 순서대로 거쳐 상대와 통신합니다. 송신하는 측은 애플리케이션 계층에서 부터 내려가고, 수신하는 측은 애플리션 계층으로 올라갑니다. 

1. 클라이언트의 애플리케이션 계층에서에서 HTTP 리퀘스트를 지시합니다.
2. 전송 계층(TCP)애서는 애플리케이션 계층에서 받은 데이터(HTTP 메시지)를 통신하기 쉽게 조각내어 안내 번호와 포트 번호를 붙여 네트워크 계층으로 전달합니다.
3. 네트워크 계층(IP)에서는 수진지 MAC 주소를 추가해서 링크 계층에 전달합니다. 이로써 네트워크를 통해 송싱할 준비가 되었습니다.
4. 링크 계층에서 데이터를 받아들여 순서대로 위의 계층에 전달하여 애플리케이션 계층까지 도달합니다. 애플리케이션 계층에 도달하게 되면 드디어 클라이언트가 발신했던 HTTP 리퀘스트 내용을 수신할 수 있습니다.


![](/assets/network-4layer-header.png)

각 계층이 거칠 떄는 반드시 헤더로 불리는 해당 계층마다 해당 계층에 필요한 정보를 추가합니다. 반대로 수신측에서 각 계층을 거칠 때마다 반드시 해당 계층의 헤더를 삭제합니다. 이렇게 정보를 감싸는 것을 캡슐화라고 부릅니다.

## HTTP와 관계가 깊은 프로토콜 IP/TCP/DNS


### 배송을 담당하는 IP
* IP는 계층으로 말하자면 네트워크 계층에 해당됩니다.
* IP의 역할은 개개의 패킷을 상대방에게 전달하는 것입니다.
* 상대방에게 전달하기까지 여러 가지 요소가 필요합니다. 이 중에서도 **IP 주소와 MAC 주소 라는 요소가 중요합니다. IP주소는 결국 MAC주소와 결부됩니다.**

### 통신은 ARP를 이용하여 MAC 주소에서 한다.
* IP 통신은 MAC 주소에 의존해서 통신을 합니다. 인터넷에서 통신 상대가 같은 랜선 내에 있을 경우 적어서 여러 대의 컴퓨터와 네트워크 기기를 중계 해서 상대방에게 도착합니다.
* **중계하는 동안에는 다음으로 중계할 곳의 MAC 주소를 사용하여 목적지를 찾아가는 것입니다. 이때 ARP이라는 프로토콜이 사용됩니다.**
* ARP는 주소를 해결하기 위한 프로토콜 중 하나인데, 수신지의 IP주소를  바탕으로 MAC 주소를 조사할 수 있십니다.
```
1. 192.0.43.10 IP 주소에 패킷을 보냄
2. ARP를 사용해서 조사한 결과 우선 10-EW-C6...에 보냅니다.
3. 라우터는 MAC 주소 00-XX-C6... 으로 보냅니다.
4. 또 라우터는 MAC 주소 11-K1-C6... 으로 보냅니다.
5. 결국 수신측으로 전달됩니다.
```

### 신뢰성을 담당하는 TCP
TCP는 계층으로 말하자면 전송 계층에 해당하는데, 신뢰성 있는 바이트 스트림 서비스를 제공합니다. 바이트 스트림 서비스란 용량이 큰 데이터를 보내기 쉽게 TCP 새그먼트라고 불리는 단위 패킷으로 작게 분해햐여 관리하는 것을 말하고, 신뢰성 있는 서비스는 상대방에게 보내는 서비스를 의미합니다. 결국 **TCP는 대용량의 데이터를 보내기 쉽게 작게 분해하여 상대방에게 보내고, 정확하게 도착했는지 확인하는 역할을 담당하고 있습니다.**

#### 상대에게 데이터를 확실하게 보내는 것이 일이다.
상대에게 확실하게 데이터를 보냐기 위해서는 TCP는 `쓰리웨이 핸드세이킹` 이라는 방법을 사용하고 있습니다. 이 방법은 패킷을 보내고 바로 끝내는 것이 아니라 보내졌는지 여부를 상대방에게 확인하러 갑니다. 이것은 `SYN`, `ACK`라는 TCP 플래그를 사용합니다.

* 송신측에서 최초 `SYN` 플래그로 상대방에게 접속함과 동시에 패킷을 보내고, 수신측에서 `SYN/ACK` 플래그로 송신측에 접속함과 동시에 패킷을 수신한 사실을 전합니다.
* 마지막으로 송신측이 `ACK` 플래그를 보내 패킷 교환이 완료되었을을 전달합니다.
* 이 과정에서 어디선가 통신이 도중에 끊어지면 TCP는 그와 동시에 같은 수순으로 패킷을 재전송합니다.


# 간단한 프로토콜 HTTP
* HTTP는 상태를 계속 유지하지 않은 스테이트리스 프로토콜입니다. 
* HTTP 프로토콜 독자적으로, 리퀘스트와 리스폰스를 교환하는 동안에 상태를 관리하지 않습니다. 결국 **HTTP 프로토콜 레벨에서 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해서는 전혀 기억하지 않습니다.**
* HTTP에서는 새로운 리퀘스트가 보내질 때 마다 새로운 리스폰스가 생성됩니다. 프로토콜로서는 과거의 리퀘스트나 리스폰스 정보를 전혀 가지고 있지 않습니다.
* **HTTP/1.1은 상태를 유지하지 않은 프로토콜입니다. 그래서 상태를 계속 유지하고 싶은 욕구에 부응하기 위해서 쿠키라는 기술이 도입되었습니다.**

## 지속 연결로 접속량을 절약

### 지속 연결
HTTP/1.1와 HTTP/1.0에서는 TCP 연결 문제를 해결하기 위해서 지속 연결이라는 방법을 고안하였습니다. 지속 연결의 특징은 어느 한 쪽이 명시적으로 연결을 종료하지 않은 이상 TCP 연결을 계속 유지합니다. **지속 연결은 1회의 TCP 컨넥션 연결로 리퀘스트와 리스폰스 교환을 여려 번 한다.**

### 파이프라인화
지속 연결은 여려 리퀘스트를 보낼 수 있도록 파이프라인화를 가능하게 합니다. 파이프라인화에 의해서 이전에는 리퀘스트 송신 후에 리스폰스를 수신할 때까지 기다린 뒤에 리퀘스트를 발행하던 것들을 리스폰스를 기다리지 않고 다음 리퀘스트를 보낼 수 있습니다.

### 쿠키를 사용한 상태관리
쿠키는 리퀘스트와 리스폰에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템입니다. 쿠키는 서버에서 리스폰스로 보내진 Set-Cookie라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 됩니다. 다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때, 자동적으로 쿠키 값을 넣어서 송신합니다. 서버는 클라이언트가 보내온 쿠키를 확인해 어느 클라이언트가 접속 했는지 체크하고 서버 상의 기록을 확인해 이전 상태를 알 수 있습니다. 

# HTTP 정보는 HTTP 메시지에 있다.

## 리퀘스트 메시지와 리스폰스 메시지의 구조
* 리퀘스트 라인 : 리퀘스트에 사용하는 메소드와 리퀘스트 URI와 사용하는 HTTP 버전이 포함됩니다.
* 상태 라인 : 리스폰스 결과를 나타내는 상태 코드와 설명, 사용하는 HTTP 버전이 포함됩니다.
* 헤더 필드 : 리퀘스트와 리스폰스의 여러 조건과 속성 등을 나타내는 각종 헤더 필드가 포함됩니다. 

## 인코딩으로 전송 효율을 높이다.
HTTP로 데이터를 전송할 경우 그 대로 전송할 수 오 있지만 전송할 때에 인코딩을 실시함으로써 전송 효율을 높일 수 있습니다.

### 메시지 바디와 엔티티 바디의 차이
* 메시지 : HTTP 통신의 기본 단위로 옷쳇 시퀀스(8비트)로 구성되고 통신을 통해 전성됩니다.
* 엔티티 : 리퀘스트와 리스폰스의 페이로드로 전성되는 정보로 엔티티 헤더 필으와 엔티티 바디로 구성됩니다.

### 일부분만 받는 레인지 리퀘스트
엔티티의 범위를 지정해서 다운로드할 필요가 있습니다. **이와 같이 범위를 지정하여 리퀘스트 하는 것을 레인지 리퀘스트 라고 부릅니다.**

레인지 리퀘스트를 사용하면 전체 10,000 바이트 정도 크기의 리소스에서 5,001 ~ 10,000 바이트 범위 만을 리퀘스트 할 수 있습니다. 레인지 리퀘스트 할 때에는 Range 헤더 필드를 사용해서 리소스의 바이트 렝니지를 지정합니다.

```
# 5,001 ~ 10,000 바이트
Ragne: bytes = 5001-10000

# 5,001 이상
Ragne: bytes = 5001

# 처음부터 3,000 바트까지, 그리고 5,000 ~ 7,000 바이트까지의 복수 범위 지정
Ragne: bytes = -3000, 5000-7000
```
레인지 리퀘스트에 대한 리스폰스 상태 코드 206 이라는 리스폰스 메시지가 되돌아 옵니다. 

### 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션
콘텐츠 네고시에이션은 제공하는 리소스를 언어와 문자 세트, 인코딩 방식 등을 기준으로 판단하고 있습니다.

판단 기준은 리퀘스트 메시지와 포함된 다음과 같은 리퀘스트 헤더 필드입니다.

* Accept
* Accept-Charset
* Accept-Encoding
* Accept-Language
* Content-Language

# Clinet -> Server


## Client
* 웹브라우저 
  * 사용자가 URL을 입력한다.
  * URL은 웹 브라우저가 해석하여 HTTP 메시지를 만들고, Socket 라이브러리에게 건네 준다.
  * Sokect 라이버러리는 받은 HTTP 메시지를 송신 데이터로 프로토콜 스택으로 건네 준다
* 프로토콜 스택 (TCP/IP)
  * TCP는 송신 데이터를 패킷길이의 길이에 맞게 분할하고, TCP MAC 주소를 주사하여 MAC 헤더도 부가하고나서 LAN 드라이버에게 건네줍니다.
* LAN
  * LAN 드라이버는 IP에서 송신 패킷을 받고 이것을 ...
  * 물리 계층을 통해서 서버로 전달합니다.(수많ㄹ은 과정 생략)