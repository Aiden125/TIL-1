# Javascript Patterns [도서](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9788966260157)

**해당 책을 공부하면서 간단하게 정리한 내용입니다. 정리 안하면 리셋되는 나를 위한...**

## 1장

- 딱히 내용이 없는데 나중에 시간 있을떄 정리하는 게 좋을듯

## 2장 기초

- 자바스크립트 코드를 작성하는 데 핵심이 되는 모범적인 관행과 습관, 패턴을 검토
- 전역변수 최소화
- 루프 내에서 `length`를 캐시해두고 사용
- 코등 규칙을 준수하는 것
- API 문서 작성, 동료 리뷰 진행, JSLint 실행
- 이런한 습관과 실천들을 익히면 좀더 훌룡하고 이해하기 쉽고 유지보수 하기도 쉬운 코드를 작성 할 수있다.
- **_몇 달이나 몇년 지나서 다시 봐도 자랑스러운 코드 말이다._** ~~이말이 제일 감동...~~

## 2.1 유지보수 가능한 코드 작성

- 소프트웨어의 버그를 고치는 데는 비용이 든다.
- 버그가 공개적으로 출시된 제품 안에 숨어 들어간 경우에는 특히 비용이 커진다. ~~나 때문에 회사가 돈을 못버는듯...~~
- 발견 즉시 버그를 고칠수 있다면 가장 좋다. 코드가 어떤 일을 수행하는지가 머릿속에 아직 생생하기 때문이다. ~~나는 아닌데... 그래도 늦으면 더 힘든건 사실~~
- 시간이 흐른 다음에 코드를 다시 들여다 볼 때는 다음 과긑은 이유로 시간이 든다.

  - 문제를 다시 학습하고 이해하는데 걸리는 시간
  - 이 문제를 해결하는 코드를 이해하는데 걸리는 시간

- 코드는 작성하는 것보다 읽는 데 더 많은 시간이 소요된다. ~~존나 공감~~

### 요지보수 가능한 코드란 다음과 같은 특징을 지닌다.

- 읽기 쉽다
- 일관적이다
- 예측이 가능하다
- 한 사람이 작성한 것처럼 보인다.
- 문서화되어 있다.

## 2.2 전역 변수 최소화

- 자바스크립트는 함수를 사용하여 유효범위를 관리한다.
- 함수 안에서 선언된 변수는 해당 함수의 지역 변수가 되며 함수 외부에서는 사용할 수 없다.
- 반대로 전역 변수란 어떤 함수에도 속하지 않고 선언되거나, 아예 선언되지 않은 채로 사용되는 변수를 가르 킨다.
- 모든 자바사크립트 실행 환경에는 전역 객체(global object)가 존재한다.
- 어떤 함수에도 속하지 않은 상태에서 `this`를 사용하면 전역 객체에 접근하게 된다.
- 전역 변수를 생성하는 것은, 이 전역 객체의 프로퍼티를 만드는 것과 같다.
- 브라우저에는 전역 객체에 `window`라는 부가적인 프로퍼티가 존재하며, 전역 객체 자신을 가리킨다. (대개)

다음 코드는 브라우저 환경에서 전역 변수를 생성하고 이 변수에 접근하는 방법을 보여준다.

```javascript
myglobal = 'hello' //안티패턴
console.log(myglobal); //'hello'
console.log(window.myglobal); //'hello'
console.log(window['myglobal']); //'hello'
console.log(this.myglobal); //'hello'
```

### 전역 변수의 문제점

- **_전역 변수의 문제점은 자바스크립트 애플리켜이션이나 웹페지 내 모든 코드 사이에서 공윧된다는 점이다._** ~~모든 악몽의 씨발점~~
- 즉 모든 전역 변수는 동일한 전역 네임스페이스 안에 존재하 기 때문에, 애플리케이션 내의 다른 영역에서 목적이 다른 전역 변수를 동일한 이름으로 정의할 경우 서로 덮어쓰게된다.

#### 다음과 같은 경우

- 서드파티 자바스크립트 라이브러리
- 내가 작성한 자바스크립트 코드

위 같은 경우에 둘다 `result` 라는 전역 변수가 있을 경우 어떻게 될것인가?

- 따라서 다른 스크립트들과 한 페이지 안에서 사이좋게 공존하려면, 전역 변수를 최소한으로 사용해야한다.
- 이것을 해결 하기 위해 네임스페이스 패턴, 즉시 실행 함수를 활용하는 방법들에 대해서 다룬다.

#### 변수를 선언 할 경우 항상 var를 사용하기
* 자바스크립트 성격상 의로하지 않았더라도 전역 변수를 만들기가 너무 쉽다.
  * 자바스크립트에서 변수를 선언하지 않고도 사용할수 있다.
  * 자바스크립트에는 암묵적 전역(implied globals)라는 개념이 있다.
  * 즉 선언하지 않고 사용한 변수는 자동으로 젼역 객체의 프로퍼티가 되어 명시적으로 선언된 전역 변수와 별차이 없이 사용된다. ***예제 코드 참고***

#### 예제 코드 안티패턴
```javascript
function sum(x, y) {
  // 안티패턴: 암묵적 전역
  result = x +y;
  return result;
}
```

* `result`는 `var`가 선언되지 않은 사앹로 사용되었다.
* 이 코드는 동장은 하지만 `result`는 네임스페이스에 `result`라는 변수가 남아 문제를 일르킬 수 있다.


#### 에제코드 바림직한 패턴
```javascript
function sum(x, y) {
  // var를 통한 변수 선언 (함수내의 지역 변수가된다.)
  vat result = x +y;
  return result;
}
```

#### var 선언을 빼먹었을 때의 부작용
* 암죽적 전역 벼수와 명시적으로 선언된 변수 사이에 존재하는 또 하나의 차이점
* delete 연산자를 사용하여 이 변수의 정의를 취소할 수 있는지 여부다.
  * var를 사용하여 명시적으로 선언된 전역 변수(함수에 속하지 않은 변수)는 삭제할 수 없다.
  * var를 사용하지 않고 생성한 암묵적 전역 변수는 (함수 안에서든 밖에서든 생성된)는 삭제 할 수 있다.
* **이는 암묵적 전역 변수가 엄밀히 말하면 변숙 아니라 전역 객체의 프로피터라는 사실을 보여준다.**
* **프로퍼티는 delete 연산자로 삭제할 수 있지만 변수는 그렇지 않다.**

#### 단일 var 패턴

**함수 상단에서 var 선언을 한번만 쓰는 패턴을 유용하고 시도해 볼만하다. 다음과 같은 이점을 갖는다.**

* 함수에서 필요로 하는 모든 지역 변수를 한군데서 찾을 수 있다.
* 변수를 선언하지 전에 사용할 때 발생하는 로직상의 오류를 막아준다. (히이스팅)
* 변수를 먼저 선언한 후에 사용한다는 사실을 상시시키기 떄문에 전역 변수를 최소하 하는데 도움을준다.
* 코드량이 줄어든다. (작성량과 전송량 모두 줄어든다.)
* 무엇보다도 프로그래머에게 변수 선언을 패턴화 시키고 그것을 강제 시킨다는게 가장큰 의미인듯. ~~이건 내 생각~~

#### 단일 var 패턴 예제
```javascript
function func() {
  var
    a = 1,
    b = 2,
    sum = a + b,
    myobject ={},
}
```

* 변수를 선언할 떄 초기값을 주어 초기화 하는 것 역시 좋은 습관이다.
* 문법 오류를 막을 수 있고,코드 가독성도 향상된다.
* 무엇 보다도 초기 값 없이 선언된 변수들은 모두 `undefined`라는 값으로 초기화된다.

#### 호이스팅 : 분산된 var 선언의 문제점
* 자바스크립트에서는 함수 내 여기저기서 여러 개의 `var`를 선언을 사용할 수 있지만
* 실제로는 모두 함수 상단에서 변수가 선언된 것과 동일하게 작동한다.
* ***이러한 동작 방식을 호이스팅 이라 한다.***
* 자바스크립트는 동일한 함수 안에 있는 변수는 `var`선언 전에 사용해도 이미 선언된 것으로 간주한다

#### 예제코드
```javascript
//안티패턴
name = 'global'; //전역변수
function func() {
  alert(name) //'undefined'
  var name = 'local';
  alert(name); //'local'
}
func();
```
* `global` -> `local` 순으로 호출될 거라 예상이 되겠지만
* 그러나 `undefined` -> `local` 순으로 출력된다.
* 첫번째 `alert`이 호출되는 시점에서 `name`이 아직 선언되지 않았으므로 전역 변수인 `name`을 바라볼것이라고 예상하겠지만 그렇지 않다
* `name`이 함수의 지역 변수로 선언되었다고 간주기하 때문이다. 선언문 자체는 그 다음에 나온다 해도 말이다.
* 즉 첫번째 `alert(name)`에 `name`은 함수내에 지역 변수로 선언된 것처럼 인식하고, `name`은 초기화 되어 있지 않기 때문에 `undefined`이라는 메세지를 출력하는 것이다.

#### 위의 예제코드는 아래와 동일하게 동작한다.
```javascript
name = 'global'; //전역변수
function func() {
  var name; // 변수에 값을 할당하지 않았음으로 undefined으로 인식된다.
  alert(name) //'undefined'
  name = 'local'
  alert(name); //'local'
}
func();
```


## 2.3 for 루프

#### 일반적인 for 루프 패턴 예제
```javascript
//최적화 되지 않은 루프
for (var i = 0;, i < myarray.length; i++){
  // myarray[i]를 다루는 코드...
}
```

* 이 패턴의 문제점은 루프 순회시마다 배열의 length에 접근한다는 점이다.
* 따라서 for 루프를 좀더 최적화하기 위해서는 다음 예제처럼 배열의 `length`를 캐시해야한다.

```javascript
for(var i = 0; max = myarray.length; i < max; i++){
  // myarray[i]를 다루는 코드...
}
```
* 이렇게 하면 `length` 값을 한 번만구하고, 루프를 도는 동안에 이 값을 사용하게 된다.

## 2.4 for-in 루프

* `for-in` 루프는 배열이 아닌 객체를 순회할 때만 사용해야한다.
* 객체를 순회할가 아닐 경우는 `for`를 사용하는 것이 바람직하다. `for` 루프가 훨씬더 빠르기 때문이다.


## 2.6 switch 패턴

* 다음 패턴을 따르면 switch문의 가독성과 견고성을 향상시킬 수 있다.

```javascript
var inspect = 0,
    result = '';
switch (inspect) {
  case 0:
    result = 'zero';
    break;
  case 1:
    result = 'one';
    break;
  default:
    result = 'undefined'
}
```

* 각 `case`문을 `switch` 문에 맞추어 졍렬된다.
* 각 `case`는 명확하게 `break;`로 종료시킨다.
* 사응하는 `case`문이 하나도 없을 경우에도 정상적인 결과가 나올 수 있도록 `switch`문 마지막에 `default;`문을 작성한다.
* `break`문을 생략하여 통과 시키지 않는다.

## 2.7 암묵적 타입캐스팅 피하기

* 자바스크립트는 변수를 비교할 때 암묵적인 타입으로 캐스팅을 실행한다.
* `false == '0'` or `'' == 0` 비교가 `true`가된다.
* 암묵적인 타입캥스팅으로 인한 혼동을 막기 우해서는 항상 표현식의 값과 타입을 모두 `===` or `!==` 연산자를 사용해야한다.

```javascript
var zero = 0;
if(zero === false){
  // zero는 0이고 false가 아니기 때문에 이 블록은 실행되지 않는다.
}
//안티패턴
if(zero == false)
  // 이블록은 실행된다 암묵적인 타입캐스팅이 작동되기 떄문에
```

## 2.8 코딩 규칙
* 코딩 규칙을 수립하고 준수하는 중요한 이유는 이를 통해 코드의 일관성이 유지되고 예측 가능해지며 일곡 이해하기가 훨씬 더 쉬워지기 때문이다.

### 들여쓰기
* JSLint로 대체
*
### 중괄호
* JSLint로 대체

### 생성자를 대문자로 시작하기

* 자바스크립트에는 클래스가 없지만 생성자 함수를 `new`와 함께 호출할 수는 있다.
* 생성자도 여전히 함수이기 때문에, 함수 이름만 보고 생성자로 쓸 함수 인지 일반 적인 함수인지 알아챌 수 있다는 도움이 된다.
* 다음 장에서는 생성자가 실제로 생성 자 처럼 동작호도록 프로그램상으로 강제할 수 있게 해주는 몇몇 패턴들을 다룰 것이다.

### 단어 구분

#### 함수경우
* `camle case`를 따른다

#### 변수
* `_`로 단어 구분점을 준다 ex) `var max_width;`
* 상수는 대문자와 `_`로 단어 구분저을 준다  ex) `var MAX_WIDTH;`

***다양한 예제가 있었으나 나는 기본적으로 위에서 설명한 규칙을 따른다.***

### API 문서작성

* YUI DOC를 추천

## 3장 리터럴과 생성자
* 리터럴 표기법 패턴을 사용하면 좀더 정확하고 표현력이 풍부하면서도 에러율은 앉은 방식으로 객체를 정의할 수 있다.
* 이 장의 핵심은 생성자 사용을 자제하고 대신 리터럴 표기법을 사용하라는 것이다.

## 3.1 객체 리터럴

* 자바스크립트에서 `객체` 라고 하면 단순히 이름-값 쌍의 해시 테이블을 생각하면된다.
* 객체 리터럴 표기법은 이 처럼 필요에 따라 객체를 생성할 때 이상적이다.

```javascript
var dog = {};

// 프로퍼티 추가
dog.nmae 'Yun';

// 이번에는 메서드를 추가한다.
dog.getName = function(){
  return dog.nmae;
}
```

* 이 예제는 빈객체를 선언하고
* 프로퍼티와 메서드를 추가한다.
* 프로그램 생명주기 중 어느 때라도 다음과같은 일을할 수 있다.
  * 프로퍼티 값 변경
  * 프로포티나 메서드를 완전 삭제
  * 다른 프로파티나 메서드를 추가

### 객체 리터럴 문법
* 객체를 중공화 `{}`로 감싼다
* 객체 내의 프롶티와 메서드를 쉼표 `,`로 분리한다.
* 마지막에 이름-깂 쌍 뒤에 쉼표가들어가면 IE에서는 에러가 발생하므로, 마지막에는 `,`를 붙이지 않는다.

### 생성자 함수로 객체 생성하기
* 자바스크립트에서는 클래스가 없기 때문에 상당히 유연하다.
* 객체에 대해서 사전에 알아야 두러야하는 '청사진' 같은 것이 필요 없기 때문이다.
* 객체를 생설할 때는 직접 만든 생성자 함수를 사용할 수도 있고, `Object(), Date(), String()`등 내장 생성자를 사용할 수도 있다.


```javascript
// 객체 리터럴 사용
var car = {gose: 'far'};

// 다른 방법 - 내장 생성자 사용
// 경고: 이 방법은 인티패턴이다.

var car = new Object();
car.gose = 'far'
```
* 객체 리터럴 표기법의 이점은 더 짧다느 것이다.
* 객체란 그 저 변형가능한 해시에 불과하며 어떤 쪼리법에 의해 구워내야만 하는 특별한 것이 아님을 확실히 보여준다. (그냥 자바스크립트에서 객체는 키-벨류 라는 것을 설명하는 거같다)


### 객체 생성자의 함정
* 객체 리터럴을 사용하는 수 있는 상황에서는 `new Object()` 생성자를 쓸 이유가 없지만, 다른 사람이 작성한 레거시 코드를 물려받을 수도 있기 때문에 이 생성자의 기능 하나들ㄹ 알아둘 필요가 있다.
* 결국 생성자를 써서는 안 되는 이유이기도 하다.

## 3.2 사용자 정의 생성자 함수
* 객체 리터럴 패턴이나 내장 생성자 함수를 쓰지 않고, 직접 생성자 함수를 만들어 객체를 생성할 수도 있다.

```javascript
var adam = new Person('Admin');
adam.say(); // 'iam admin'
```

* 이 패터은 자바에서 `Person`이라는 클래스를 사용하여 객체를 생성하는 방식과 상당히 유사하다
* 그러나 문법은 비슷해도 클래스라는 것이 없으면 `Person`은 그저 보통함수일 뿐이다.

### 다음은 `Person` 생성자 함수를 정의한 예시이다.
```javascript
var Person = function(name){
  this.name =name;
  tihs.say = function (){
    return 'I am' + this.name;
  }
}
```

**`new` 와 함께 생성자 함수를 호출하면 함수 안에서 다음과 같은 일들이 일어난다.**

* 빈 객체가 생성된다. 이 객체는 this라는 변수로 참조할 수 있고, 해당 함수의 프로토타입을 상속받는다.
* this로 참조되는 객체에 프로퍼티와 메서드가 추가된다.
* 마지막에 다른 객체가 명시적으로 반환되지 않을 경우, this로 참조된 이 객체가 반환된다.

즉 이면에서 다음과 같이 진행된다고 할 수있다.

```javascript
var Person = function (name) {
  // 객체 리터럴로 새로운 객체를 생성한다.

  // var this = {};

  // 프로퍼티와 메서드를 추가한다.
  this.name = name;
  this.say = function () {
    return 'I am' + this.name;
  };
  // this를 반환한다
  // return this
}
```

* 이 예제에서느 간다히 `say()`라는 메서드를 this에 추가했다.
* 결과적으로 `new Person()`을 호출할 때마다 메로이에 새로운 함수가 생성된다.
* `say()` 라는 메서드는 인스턴스별로 달라지는게 아니므로 이런 방식은 명백히 비효율적이다.
* 이 메서드는 Person의 프로토타입에 추가하는 것이 더 낫다

```javascript
Person.prototype.say = function () {
  return 'I am' + this.name;  
};
```
* 이어지는 장에서 프로토타입과 상속에 대해서 더 자세히 다루겠지만 여기서는 메서드와 같이 재사용되는 멤는 프로토타입에 추가해야한다는 점만 기억해두자.
*  `var this ={}`는 빈 객체는 실제로는 텅 빈 것이 아니다.
* 이 객체는 Person의 프ㅡ로토타입을 상솔받는다. 즉 다음 코드에 더 가깝다.
var tihs = Object.create(Person.prototype);

## 3.3 new를 강제하는 패턴
* 생성자란 new와 함께 호출될 뿐 여전히 별다른 것 없는 함수에 불과하다
* 그렇다면 생성자를 호출할 때 new를 빼먹으면 어떻게 될까?
* 문법 요루나 런타임 에러가 발생하지는 않는다.
* 하지만 논리적인 오류가 생겨 예기치 못한 결과가 나올수있다
* new를 빼먹으면 생성자 내부의 this가 전역 객체를 가르키게 되기 떄문이다. (브라우저에서는 this가 window를 가리키게 된다.)
* 셍상지 내부에 this.member와 같은 코드가 있을 때 이 생성자를new 없이 호출하면 실제로는 전역 객체에 member라는 새로운 프로포티가 생성된다.
* 이 프로퍼티는 window.member 또는 member를 통해 접근할 수 있다
* 전역 네임스페이스가 항상 깨긋하게 유지해야하기 때문에 이런 동작은 정말 바람직하지 않다.

### 예제

```javascript
// 생성자
function Waffle() {
  this.taster = 'yun';
}

// 새로운 객체
var test_msg = New Waffle();
console.log(typeof test_msg); // 'object'
console.log(test_msg.taster); // 'yun'

// 안티패턴 'new'를 생략했다.
var test_msg =  Waffle();
console.log(typeof test_msg); // 'undefined'
console.log(window.taster); // 'yun'
```

* ECMAScript 5에서는 이러한 동작을 방지하기 위해서 스크릭트모드에서 this가 전역 객체를 가리키지 않도록 했다.

### 명명 규칙
* 가장 간단한 대안은 앞 장에서 다룬 명명 규칙을 사용하는 것이다.
* 생성자 함수의명의 첫글자를 대문자로 작성한다

### that 사용
* 명명 규칙을 따른 것도 꽤 도움이 되지만 이는 올바른 동적 방식을 권할뿐 강제하지는 못한다
* 생성자가 항상 생성자로 동작하도록 해주는 패턴을 살펴보자.
* this에 모든 맴버를 추가하는 대신, that에 모든 멤버를 추가한 후 that을 반환하는 것이다.

```javascript
function Waffle(){
  var that = {};
  that.taster = 'yun';
  return that;
}
```
* 간단한 객체라면 that이라는 지역 변수를 만들 필요 없이 객체 리터럴을 통해 객체를 반환 해도된다
```javascript
function Waffle(){
  return{
    taster : 'yun'
  };
}
```

## 3.4 배열 리터럴
* 자바스크립트의 배열은 이 언어 내 다른 모든것들과 마찬가지로 객체이다.

```javascript
// 모두 안티패턴이다.
var a = new Array('a', 'b', 'c');

var a = new Array['a', 'b', 'c'];

console.log(typeof a); // 배열로 객체이기 떄문에 'object'가 출력된다.
console.log(a.construertor === Array); // true;
```
### 배열 리터럴 문법
* 배열 객체 리터럴 문법은 틀별한 것이 없다
* 각 원소는 쉼표로 분리하고 전체 목록을 대확호로 감싸준다 ex) `var array = ['a', 'b', 'c'];`

### 배열 생성자의 특이성

```javascript
// 한 개의 원소를 가지는 배열
var a = [3];
console.log(a.length); // 1
console.log(a[0]); // 3

// 세 개의 원소를 가지는 배열
var a = new Array(3);
console.log(a.length); // 3
console.log(typeof a[0]); // 'undefined'
```

## 3.5 에러 객체

```javascript
try{
  // 에러를 발생시킨다.
  throw{
    name: 'MyErrorType', // 임의의 에러 타입
    message: 'oops',
    extra: 'This was rather embarrassing',
    remedy: 'genericErrorHandler', // 에러를 처리할 함수
  };
} catch (e){
  // 사용자에게 공지한다.
  alert(e.message); //'oops'
  e.remedy(); //훌룡허개 애로를 처리한다
}
```
## 요약
* 객체 리터럴 표기법 - 이름-값 쌍을 쉼표로 분리하고 괄호로 감싸 객체를 만든다
* 생성자 함수 - 내장 생성자 함수와 사용자 정의 생성자를 살펴보았다. 내장 생성자의 경우, 대개는 대응하는 리터럴 표기법을 쓰는 것이 좋다
* 생성자 함수가 항상 new와 함께 호출된 것처럼 동작하도록 보장하는 방법을 살펴보았다.
* 배열 리터럴 표기법
* 에러 객체 throw를 객체 리터럴 방법으로 처리하는 것을 살펴보았다.

## 4장 함수
* 자바스크립트는 함수를 다양한 방법으로 사용한다.
* 이 장에서는 자바스므립트에서 함수를 정의하는 다양한 방법들과 함수 표현식 그리고 함수 선언문에 대해서 알아본다
* 지역 유효범위와 변수 호이스팅이 어떻게 동작하는지 살펴 본다
* 함수에 더 나은 인터페이스를 제공하는 API, 전역 변수를 덜 사용하는 코드 초기화, 불필요한 작업을 회피해 성능에 도움을 주는 여러가지  패턴들에 대해 배운다

### 4.1 배경지식
* 자바스크립트의 함수를 특별하게 만드는 두 가지 중요한 특징이있다.
  * 일급객체 , 유효범위를 제공한다

#### 함수는 다음과 같은 특징을 가지는 객체다.
* 런타임, 즉 프로그램 실행 중에 동적으로 생성할 수 있다.
* 변수에 할당할 수 있고, 다른 변수에 참조를 복사할 수 있으며, 확장이가능하고, 몇몇 특별한 경우를 제외하면 삭제할 수 있다.
* 다른 함수의 인자로 전달할 수 있고, 다른 함수의 반환 값이 될 수 있다.
* 자기 자신의 프로퍼티와 메서드를 가질 수 있다.
