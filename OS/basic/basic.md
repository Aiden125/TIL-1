- [운영 체에의 역할](#%EC%9A%B4%EC%98%81-%EC%B2%B4%EC%97%90%EC%9D%98-%EC%97%AD%ED%95%A0)
  - [시스템 자원 관리자](#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%9E%90%EC%9B%90-%EA%B4%80%EB%A6%AC%EC%9E%90)
  - [응용 프로그램 이란?](#%EC%9D%91%EC%9A%A9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%9D%B4%EB%9E%80)
- [시분활 시스템 멀티 태스킹](#%EC%8B%9C%EB%B6%84%ED%99%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%A9%80%ED%8B%B0-%ED%83%9C%EC%8A%A4%ED%82%B9)
- [CPU Protection Rings](#cpu-protection-rings)
  - [시스템콜은 커널 모드로 실행](#%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%BD%9C%EC%9D%80-%EC%BB%A4%EB%84%90-%EB%AA%A8%EB%93%9C%EB%A1%9C-%EC%8B%A4%ED%96%89)
  - [사용자 모드와 커널 모드](#%EC%82%AC%EC%9A%A9%EC%9E%90-%EB%AA%A8%EB%93%9C%EC%99%80-%EC%BB%A4%EB%84%90-%EB%AA%A8%EB%93%9C)
- [멀티 프로그래밍](#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
  - [멀티 프로그래밍](#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-1)
  - [정리](#%EC%A0%95%EB%A6%AC)
- [스케줄러 알고리즘](#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
  - [프로세스란 ?](#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%9E%80)
  - [스케줄러와 프로세스](#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC%EC%99%80-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)
  - [스케쥴링 알고리즘](#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
  - [최단 작업 우선(SJF) 스케줄러](#%EC%B5%9C%EB%8B%A8-%EC%9E%91%EC%97%85-%EC%9A%B0%EC%84%A0sjf-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC)
  - [우선순위 기반 스케쥴러](#%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%EA%B8%B0%EB%B0%98-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC)
  - [Round Robin 스케줄러](#round-robin-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC)
  - [정리](#%EC%A0%95%EB%A6%AC-1)
- [프로세스 상태](#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C)
  - [프로세스 상태간 관계](#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C%EA%B0%84-%EA%B4%80%EA%B3%84)
- [입터럽트](#%EC%9E%85%ED%84%B0%EB%9F%BD%ED%8A%B8)
  - [입터럽트 필요 이유](#%EC%9E%85%ED%84%B0%EB%9F%BD%ED%8A%B8-%ED%95%84%EC%9A%94-%EC%9D%B4%EC%9C%A0)
  - [인터럽트 종류](#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%EC%A2%85%EB%A5%98)
  - [인터럽트 내부 동작](#%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%85%E1%85%A5%E1%86%B8%E1%84%90%E1%85%B3-%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE-%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%A8)
    - [인터럽트와 IDT](#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%99%80-idt)
- [컨텍스트 스위칭](#%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%EC%9C%84%EC%B9%AD)
  - [컨텍스트 스위칭 원리](#%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%EC%9C%84%EC%B9%AD-%EC%9B%90%EB%A6%AC)
  - [컨텍스트 스위칭 개념 정리](#%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%EC%9C%84%EC%B9%AD-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC)
- [프로세스간 커뮤니케이션](#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%84-%EC%BB%A4%EB%AE%A4%EB%8B%88%EC%BC%80%EC%9D%B4%EC%85%98)
  - [IPC](#ipc)
    - [IPC 기법](#ipc-%EA%B8%B0%EB%B2%95)
    - [Pipe](#pipe)
    - [메시지 큐](#%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90)
    - [메시지 큐, 파이프](#%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90-%ED%8C%8C%EC%9D%B4%ED%94%84)
    - [공유 메모리](#%EA%B3%B5%EC%9C%A0-%EB%A9%94%EB%AA%A8%EB%A6%AC)
    - [Signal](#signal)
    - [Socket](#socket)
  - [정리](#%EC%A0%95%EB%A6%AC-2)

# 운영 체에의 역할

## 시스템 자원 관리자
* Operating System 또는 OS 라고 부릅니다.
* 시스템 자원(System Resource) = 컴퓨터 하드웨어
    * CPU(중앙처리장치), Memory(DRAM, RAM)
    * I/O Devices (입출력 장치)
        * Moinitor, Mouse, Keyboard, Network
    * 저장 매체 : SSD, HDD (하드디스크)

> 컴퓨터 하드웨어는 스스로 할 수 있는 것이 없습니다.

1. CPUL: 각 프로그램이 얼마나 CPU를 사용할지를 CPU가 결정 할 수 없습니다.
2. Memory: 각 프로그램어 어느주소에 저장더ㅣ어애 하는지, 어느 정도 메모리 공간을 확보해줘야 하는지를 결정 할 수 없습니다.
3. 저장매체(HDD, SDD): 어떻게, 어디에 저장할지 결정할 수 없습니다.
4. 키보드/마우스 : 스스로 표시 할 수 없습니다

> 이 모든 것들을 운영체제가 진행합니다.



## 응용 프로그램 이란?
* 프로그램 = 소프트웨어
* 소프트웨어 = 운영체제, 응용 프로그램

# 시분활 시스템 멀티 태스킹
* 응용 프로그램이 CPU를 사용하는 시간을 잘개 쪼개서, 여러 개의 응용 프로그램이 동시에 실행사는 기법
* 시분할 시스템 : 다중 사용자를 지원하고, 컴퓨터 응답 시간을 최소하하는 시스템
* 멀티 태스킹 
    * 가능한 CPU를 많이 활용하도록 하는 기능(시간대비 CPU사용율을 높이자)
    * 단일 CPU에서, 여러 응용 프로그램의 병렬 실행을 가능케 하는 시스템 
* 멀티 프로그래밍 : 최대한 CPU를 많이 활용 하도록 하는 시스템(시간대비, CPU 활용도를 높이자)
    * I/O 작업이 일어나면 CPU가 대기 상태로 넘어가는 것을 비동기 방식으로 CPU를 다른 작업을 진행 할 수 있게 진행

# CPU Protection Rings
* CPU도 권한 모드라는 것을 가지고 있습니다.
    * 사용자 모드
    * 커널 모드 : 특권 명령어 실행과 원하는 작업 수행을 위한 자원 접근을 가능케 하는 모드

## 시스템콜은 커널 모드로 실행
* 커널 모드에서만 실행 가능한 기능들이 있음
* 커널 모드로 실행 하려면, 반드시 시스템 콜(커널모드)을 해야함
* 시스템 콜은 운영체제 제공

## 사용자 모드와 커널 모드
* 함부로 응용 프로그램이 전체 컴퓨터 시스템을 헤치지 못함
* 운영체제는 시스템 콜을 제공
* 프로그래밍 언어 별로 운영체제 기능을 활요하기 위해, 시스템 콜을 기반으로 API 제공
* 응용 프로그램은 운영체제 기능 필요시, 해당 API를 사용해서 프로그램을 작성
* 응용 프로그램이 실행되서, 운영체제 기능이 필요한 API를 호출하면, 시스템 콜이 호출되서, 다시 커널 모드 변경되어 OS 내부에 해당 명령이 실행되고, 다시 응용 프로그램으로 돌아간다.

# 멀티 프로그래밍
* 최대한 CPU를 많이 활용하도록 하는 시스템
    * 시간 대비 CPU 활용도를 높이자
    * 으용 프로그램 짧은 시간안에 실행 완료를 시킬 수 있음
## 멀티 프로그래밍
* 응용 프로그램은 온전히 CPU를 쓰기보다, 다른 작업을 중간에 필요로 하는 경우가 많음
    * 응용 프로그램이 실행되다가 파일을 읽는다.
        * I/O 작업이 일어나면 시스템이 Blocking 된다
    * 응용 프로그램이 실행되다가 프린팅을 한다.
        * 마찬 가지로 I/O 작업이 일어나면 Blocking 된다
## 정리
* 시분할 시스템 : **다중 사용자 지원**, 컴퓨터 응답시간을 최소화 하는 시스템
* 멀티 캐스팅: **단일 CPU에**서 여러 응용 프로그램을 동시에 실행하는 것처럼 보이게 하는 시스템
* 멀티 프로세싱 : **여러 CPU**에 하나의 응용 프로그램을 병렬로 실행하게 해서, 실행속도를 높이는 기법
* 멀티 프로그래밍 : 최대한 CPU를 일정 시간당 많이 활용하는 시스템


# 스케줄러 알고리즘
## 프로세스란 ?
* 실행 중인 프로그램은 프로세스라고 함
    * 프로세스 : 메모리에 올려져서, 실행 중인 프로그램
    * 코드 이미지(바이너리): 실행 파일, 예

## 스케줄러와 프로세스
* 프로세스 실행을 관리하는 것이 스케줄러

## 스케쥴링 알고리즘
* 목표
    * 시분할 시스템 예: 프로세스 응답 시간을 가능한 짧게
    * 멀티 프로그래밍 예: CPU 활용도를 최대로 높혀서, 프로세스를 빨리 실행

## 최단 작업 우선(SJF) 스케줄러
* SJF 스케줄러 
    * 가장 프로세스 실행 시간이 짧은 프로세스 부터 먼저 실행 시키는 알고리즘

## 우선순위 기반 스케쥴러
* priority-based 스케줄러
    * 정적 우선순위
    * 프로세스마다 우선순위를 미리 지정
    * 동적 우선순위 : 스케줄러가 상황에 따라 우선순위를 동적으로 변경 

## Round Robin 스케줄러
* 큐에 쌓아 놓고 일정 시간이 지나면 다시 대기 큐로 돌려 보낸다. 그 뒤에 있는 작업을 진행한다.

## 정리
* FIFO 스케줄링 알고리즘 : 배치 시스템
* 최단 작업 우선 스케줄링 알고리즘
* 우선순위 기반 스케줄링 알고리즘
    * 정적 순위, 동적 우선 순위
* Round Robin 스케줄링 알고리즘
    * 시분할 시스템 기반

  
# 프로세스 상태

![](/assets/process-flow.png)
* running state: 현재 CPU에서 실행 상태
* ready state: CPU에서 실행 가능 상태 (실행 대기 상태)
* block state: 특정 이벤트 발생 대기 상태

## 프로세스 상태간 관계

![](/assets/proccess-status.png)

1. Process blocks for input : 특정 이벤트 대기
2. Scheduler picks another process
3. Scheduler picks this process
4. Process Becomes avaliable

# 입터럽트
 
> CPU가 프로그램을 실행하고 있을때, 입출력 하드웨어 등 의 장치(이벤트 발생)나 또는 예외상횡이 발생하여 처리가 필요한 경우 CPU에 알려준 처리 기술

> 어느 한순간 CPU가 실행하는 명령은 단 하나, 다른 장치와 어떻게 커뮤니케이션을 할까요?

## 입터럽트 필요 이유

* 선점형 알고리즘
    * 프로그램이 실행중에 어떠한 이유(Blocking 되는 작업 등)로 중간에 멈춰야 할때 
* 예외 상황 핸들링
    * CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생할 경우, CPU가 해당 처리를 할 수 있도록 CPU에 알려줘야함

## 인터럽트 종류
* 내부 인터럽트
    * **주로 소프트웨어 인터럽트라고 함**
    * 주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용시 발생
        * 0 으로 나눴을 때
        * 사용자 모드에서 허용되지 않은 명령 또는 공간 접근시
        * 계산 결과가 Overflow/Underflow 날 때
* 외부 인터럽트
    * 주로 하드웨어 발생되는 이벤트 (프로그램 외부)
        * 전원 이상
        * 기계문제
        * **키보드등 IO 관련 이벤트**
        * **Timer 이벤트**
    * **주로 하드웨어 인터럽트라고 함**



## 인터럽트 내부 동작

### 인터럽트와 IDT
* 인터럽트는 미리 정의되어 각 번호와 실행코드를 가리키는 주소가 기록되어 있음
    * IDT(Interrupt Descriptor Table)에 기록
    * 컴퓨터 부팅시 운엥체제가 기록
* 리눅스 경우
    * 0 ~ 31 : 예외상황 인터럽트 (내부 인터럽트, 소프트웨어 인터럽트)
    * 32 ~ 37: 하드웨어 인터럽트 주변 장치 (외부 인터럽트)
    * 128 : 시스템콜

# 컨텍스트 스위칭 

## 컨텍스트 스위칭 원리
* 프로세스 구조
    * Stack, Heap, Data(BSS, DATA), Code
* PCG
    * 프로세스 정보 상티 
        * PC, SP : 컨텍스트 스위칭
        * 메모리
        * 스케줄링


## 컨텍스트 스위칭 개념 정리
* Context Switching(문맥 교환)
    * CPU에 실행할 프로세스를 교체하는 기술

1. 실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업디이트해서, 메인 메모리에 저장
2. 다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 PCB 정보를 CPU에 넣고 실행

![](/draw/context-switcing.png)
1. 실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트해서, 메인 메모리에 저장
2. 다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 **PCB 정보(PC, SP)를 CPU의 레지스터리**에 넣고 실행

# 프로세스간 커뮤니케이션

* 프로세스는 다른 프로세스의 공간을 접근할 수 없다.
    * 프로세스들이 서로의 공간을 쉽게 접근할 수있다면 프로세스 데이터/코드가 바뀔수 있으니 위험하다.
* 프로세스간 통신이 필요한이유 ?
    * 성능을 높이기 위해 여러 프로세르를 만들어 동시에 실행할 경우 이때 프로세스 간 상태 확인 및 데이터 송수신이 필요

## IPC
* 프로세스간의 통신 방법을 제공함
* IPC: InterProcess Communication

### IPC 기법
* Message Queue
* Shared Memory
* Pipe
* Signal
* Semaphore
* Socket

### Pipe 
* 기본 파이프는 단방향 통신
* fork()로 자식 프로세스 만들었을때, 부모와 자식간의 통신

![](/draw/process-pipe.png)

* 부모 프로세스에서 fd[1]을 기반으로 데이터를 생성
* 자식 프로세스에서 fd[0]을 기반으로 데이터를 읽을 수 있음
* **단방향 통신이다**
* 실제 데이터가 전달되는 pipe는 커널 영역에 존재한다.

### 메시지 큐
* 큐 정책 그대로 FIFO 정책으로 데이터 전송
* 먼저 넣은 데이터가 먼저 읽혀진다.
* 메시지큐는 양방향이 가능


### 메시지 큐, 파이프
* mesage queue는 부모/자식이 아니라, 어느 프로세스간에더라도 데이터 송수신이 가능
* 먼저 넣은 데이터가 

### 공유 메모리

![](/draw/shared-memory.png)
* 노골적으로 kernel space에 메모리 공간을 만들고, 해당 공간을 변수처럼 쓰는 방식
* message queue 처럼 FIFO 방식이 아니라. 해당 메모리 주소를 마치 변수처럼 접근하는 방식
* 공유 메모리 key를 가지고, 여러 프로세스가 접근 가능

### Signal
* 커널 또는 프로세스에서 다른 프로세스에 어떤 이벤트가 발생되었는지를 알려주는 기법
* 시그널은 미리 정의된 이벤트이다.
* 서로 다른 프로세스들이 시그널 이벤트를 이용해서 프로세스간의 통신이 가능하다.
  * 미리 정의된 시그널 중에서 아무 동작도 하지 않은 시그널을 통해서 시그널을 정의해서 사용 한다.
* 프로세스 관련 코드에 관련 시그널 핸들러를 등록해서, 해당 시그널 처리 실행
  * 시그널 무시
  * 시그널 블록(블록을 푸는 순간, 프로세스에 해당 시그널 전달)
  * 등록된 시그널 핸들러로 특정 동작 수행
  * 등록된 시그널 핸들러가 없다면, 커널에 기본 동작 수행 

### Socket
* 소켈은 네티워크 통신을 위한 기술
* 기본적으로는 클라이언트와 서버등 두 개의 다른 컴퓨터간의 네티워크 기반 통신을 위한 기술
* 소켓을 하나의 컴퓨터 안에서, 두 개의 프로세스 간에 통신 기법으로 사용 가능


## 정리
* 여러 프로세스 동시 실행을 통한 성능 개선, 복잡한 프로그램을 위해 프로세스간 통신 필요
* 프로세스간 공간이 완전분리
* 프로세스간 통신을 위한 특별한 기법 IPC 지원
* 대부분의 IPC 기법은 커널 커널 공간을 활용
    * 이유: 커널 공간은 프로세스간의 공유가 가능