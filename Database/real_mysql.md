> 해당 글은 [Real MySQL 개발자와 DBA를 위한](http://www.yes24.com/Product/Goods/6960931)을 정리한 내용입니다.

# 02 설치와 설정

## 서버 설정

### my.conf 설정 파일

#### max_connections
MySQL 서버가 쵀대 허용할 수 있는 클라이언트 연결 수를 제안하는 설정이다. `max_connections` 설정은 동적으로 변경할 수 있으므로 컨넥션이 부족하다면 그때 그때 변경해 주면 된다. 어떤 웹 서버가 20대라면 한 서버당 컨넥션이 100개씩 이라고 해도 2000의 컨넥션이 필요하다. 컨넥션 풀에서도 적절한 컨넥션 개수의 설정이 중요하다. MySQL 서버의 `max_connections` 설정은 이러한 위험을 막는 최후의 보루라는 점을 기억해야 한다.

#### thread_chace_size
MySQL 서버에서 스레드와 컨넥션은 거의 같은 의미로 사용되곤 하지만 사실 **컨넥션은 클라이언트와 서버의 연결 그자체를 의미하며, 스레드는 해당 컨넥셔능로 부터 오는 작업 요청을 처리하는 주체다.** 최초 쿨러아온툻뷰토 접속 요청이 오면 MySQL 서버는 스레드를 준비해 그 컨넥션에 작업 요청을 처리 줄 스레드를 매핑하는 형태이다.

**아무리 스레드가 경량이라 하더라도 생성하는 데는 시간과 CPU 처리가 필요하기 때문에 컨넥션이 종료되어 불필요해진 스레드를 MySQL 서버는 그냥 제거하지 않고 스레드 풀(컨넥션 풀과 동일한 개념)에 저장해 뒀다가 새로운 접속 요청이 오면 해당 컨넥션에 스레드를 할당할 수 있게 보관한다.** `thread_chace_size` 설정 변수는 최대 몇 개까지의 스레드를 스레드 풀에 보관할지 결정한다.

요즘 웹 서버나 애플리케이션 서버는 컨넥션 풀을 유지하기 때문에 한꺼번에 대량의 컨넥션 요청이 발생하지는 않을것이다. 따라서 해당 값을 크게 유지할 필요는 없을 것으로 보인다. MySQL 서버가 스레드를 캐시해 두려면 메모리가 필요하기 때문에 가능하다면 이 값을 크게 늘리는 것보다는 클라이언트 프로그램이 컨넥션 풀을 사용할 수 있게 개발하는 것이 좋다.

#### wait_timeout
MySQL 서버에 연결돤 클라이언트가 `wait_timeout`에 지정된 시간 동안 아무런 요청이 없이 대기하는 경우 MySQL 서버는 해당 커넥션을 강제료 종료해 버린다. 이 설정값은 `28800 sec`(8시간)이다. 만약 MySQL 서버 앞쪽에 L4와 같은 로드 밸런스용 장비가 있다면 그러한 장비의 `idle-timeout`도 반드시 확인해 안정적인 커넥션이 유지되느지 확인 해야한다. 이러한 네트워크의 불안정이나 예상 외의 `timeout` 시간과 관련해서는 운영체제의 `keep-alive` 설정 등도 함께 확인하는 것이 좋다.

> KeepAlive란?
> 네트워크를 통해 만들어진 TCP 컨넥션을 계속 유효한 상태(살아 있게)로 유지하는 것을 의미 하는데, MySQL 서버의 컨넥션도 TCP 기반이므로 운영체제의 KeepAlive 관리 대상이 된다. 운영체제에서는 컨넥션이 유효한지 확인 하기 위해 원격지의 컴퓨터와 체크 메시지(HeartBeat과 같은)를 주고받는데, 이 과정을 KeepAlive 프로브 라고한다. 
> 일반적인 운영체제는 TCP 컨넥션에 대해 얼마만큼의 시간 간격을 두고 KeepAlive 프로브를 실행할지, 그리고 KeepAlive 프로브가 몇번 연속 실패했을 때 해당 컨넥션을 종료시킬지 등을 설정할 수 있다. 특히 MySQL 서버가 L4와 같이 사용되는 경우에는 L4에 설정된 타임아웃 시간보다 MySQL 서버가 설치된 운영체제의 KeepAlive 프로브 간경을 더 낮게 설정해주는 것이 좋다.

#### max_allowed_packet
네트워크 문제나 MySQL 서버 또는 클라이언트의 버그로 인해 잘못된 패킷이 MySQL 서버로 전달될 경우 MySQL 서버에 심각한 문제를 일으킬 수 있다. 이러한 문제점을 없애고자 MySQL 서버는 모든 클라이언트의 패킷이 `max_allowed_packet` 설정값에 지정된 크기 이하일 것으로 간주하고 처리한다. 만약 `max_allowed_packet`이 32MB로 설정된 서버에서 실행해야 할 쿼리 문장이 그 이상이 되는 경우에는 이 값을 더 큰 값으로 변경해야 한다. 이러한 문제는 `BLOB`, `TEXT` 타입의 칼럼에 상당히 큰 데이터를 지정해야하는 경우에 주로 발생한다.

**MySQL 서버와 통신 할때 클라이언트가 MySQL 서버로 쿼리 요총을 보내는 경우에는 무조건 하나의 패킷만 사용할 수있으며, 쿼리의 실행 결과는 여러 개의 패킷으로 나눠서 전달받게 된다. 그래서 이 설정값은 클라이언트가 서버로 요청하는 쿼리 문장의 길이보다 큰 값으로만 설정하기만 하면 된다.**

#### max_heap_table_size
메모리 스토리 엔진을 사용한 메모리 테이블은 힙 테이블이라고도 하기 떄문에 변수의 이름에 `head_table` 이란 단어가 사용된 것이다. 만약 빠른 처리를 위해 메모리 테이블을 사용한다면 값을 그에 맞게 적절히 변경하는 편이 좋다. 여기서 메모리 테이블이라 함은 사용자가 스토리지 엔진을 Memory로 지종해 CREATE TABLE로 생성한 테이블뿐만 아니라 MySQL이 사용자의 쿼리를 처리하기 위해 내부적으로 생성하는 임시 테이블로 포함된다.

#### sort_buffer_size
MySQL에서 인덱스를 ㅅ이용하거나 별도의 메모리 디스크 공간에 결과를 저장해 정렬을 수행할 수 있다. ㅇ;ㄴ덱스를 이용하는 경우는 정렬된 상태로 저장된 인덱스를 순서대로 읽기만 하는 것을의미하며, 실제 정렬 알고리즘이 실행되는 것이 아니라서 당당히 빠르게 처리 된다.

일반적인 DBMS에서 가증 큰 부하를 일으키는 사용자 요청이 정렬(순수한 정렬이나 그룹핑 작업으로 인한) 작업인데, `sort_buffer_size`는 인덱스를 사용 없는 정렬에 메모리 공간을 얼마나 할당할지 결정하는 설정값이다.

#### joint_buffer_size
조인 버퍼는 MySQL에서 조인이 발생할 때마다 사용되는 버퍼가 아니다. 적절한 조인 조건이 없어서 드리븐 테이블의 검색이 풀 테이블 스캔으로 유도되는 경우에 조인 버퍼가 사용된다. 일반적으로 이런 경우에는 `Using join buffer`라는 내용이 실혱 계획에 표시된다. 

#### innodb_buffer_pool_size
InnoDB 스토리 엔진에서 가장 중요한 옵션이다. InnoDB 스토리지 엔진의 버퍼풀 디스크의 데이터를 메모리에 캐싱함과 동시에 데이터의 변경을 버퍼링하는 역할을 수행한다. 일반적으로 innodb_buffer_pool_szie는 운영체제나 MySQL 클라이언트에 대한 서버 스레드가 사용할 메모리를 제외하고는 남는 거의 모든 메모리 공간을 설정한다.

하지만 이 예측치는 최대 사용 가능한 메모리 크기이므로 상당히 현실성이 떨어지며, 실제 사용하는 메모리는 쿼리의 특성에 따라 달라진다. 그래서 일반적으로 50 ~ 80% 까지 수준에서 inndb_buffer_pool_size를 설정한다.

### client 설정 그룹

## Mysql 서버의 시작과 종료

```
$ /etc/init.d/mysql start
$ /etc/init.d/mysql stop
```

## MySQL 복제 구축

### 설정 준비
MySQL 복제를 구축하려면 복제 그룹 내에 속한 각 MySQL 서버가 중복되지 않은 server-id 값을 가지고 있어야 한다. 또 마스터 MySQL 서버는 반드시 바이너리 로그가 활성화돼 있어야 한다. 

#### 복제 계정 준비
슬레이브 MySQL이 마스터로 부터 바이너리 로그를 가져오려면 마스터 MySQL 서버에 접속해 로그인 해야하느데. 이때 슬레이브가 사용할 계정을 복제용 계정이라 한다. 복제용 계정은 MySQL에 미리 준비돼 있어야 하며, 이 계정은 반드시 `REPLICATION SLAVE` 권한을 가지고 있어야 한다.

## 03 MySQL 아키텍처

![](https://github.com/cheese10yun/TIL/raw/master/assets/mysql-server-1.png)

### MySQL 엔진
MySQL 엔진은 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 컨넥션 핸들러와 SQL 파서 및 전처리기, 그리고 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룬다. 그리고 성능 향상을 위해 MylSAM의 키 캐시나 InnoDB의 버퍼 풀과 같은 보조 저장소 기능이 포함돼 있다. 또한 MySQL은 표준 SQL(ANSI SQL-92) 문법을 지원하기 떄문에 표준 문법에 따라 작성된 쿼리는 타 DBMS와 호환되어 실행될 수 있다.

### 스토리지 엔진
MySQL 엔진은 요청된 SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행하고, 실제 데이터를 디스크 스토리지에 저장하가너 디스크 스토리지로부터 데이터를 읽어오는 부분을 스토리지 엔진이 전담한다. MySQL 서버에서 MySQL 엔진은 하나지만 스토리 엔진은 여러 개를 동시에 사용할 수 있다. 

#### MySQL 스레딩 구조
![]()

MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 동작하며, 크게 포그라운드 스레드외, 백그라운드 스레드로 구분할 수 있다.

##### 포그라운드 스레드 (클라이언트 스레드)
포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리하는 임무다. **클라이언트 사용자가 작업을 마치고 컨넥션을 종료하면, 해당 컨넥션을 담당하던 스레드는 다시 스레드 캐시로 되돌아 간다. 이떄 이미 스레드에 캐시에 일정 개수 이상의 대기중인 스레드가 있다면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재한다.** 이렇게 스레드의 개수를 일정하게 유지하게 만들어주는 파라미터가 `thread_cache_size` 이다.

포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시러 부터 가져오며, 버퍼나 캐시에 없는 경우엔느 직접 디스크의 데이터나 인덱스 파일러부터 데이터를 읽어와서 작업을 처리한다. MyISAM 테이블의 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만, InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.

##### 백그라운드 스레드
MyISAM의 경우는 별로 해당상이 없는 부분이지만 InnoDB는 여러 가지 작업이 백그라운드 처리딘다. 대표적으로 인서트 버퍼(Insert Buffer)를 병합 하는 스레드. 로그를 디스크로부터 기록하는 스레드, InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드데이터를 버퍼로 읽어들이는 스레드, 그리고 기타 여러 가지 잠금이나 데드락을 모니터링하는 스레드가 있다. 이런한 모든 스레드를 총광하는 메인 스레디도 있다.

SQL 처리 도중 데이터의 쓰기 작업은(버퍼링)되어 처리될 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다.(사용자가 SELECT 쿼리를 실행 했는데, "요청된 SELECT는 10분 뒤에 결과를 돌려주겠다" 라고 응답을 보내는 DBMS는 없다) 그래서 일반적인 사용 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 참재돼 있으며 InnoDB 또한 이러한 방식으로 처리한다. 하지만 MyISAM은 그렇지 않고 사용자 스레드가 쓰기 작업까지 함께 처리하도록 설계돼 있다. 이러한 이유로 **InnoDB에서는 INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우, 데이터가 디스크의 데이터파일로 완전히 저장죌 때까지 기라디지 않아도 된다.** 하지만 MyISAM에서 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.

### 메모리 할당 및 사용 구조
![]()

MySQL에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다. 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 무조건 운영체제로부터 할당 된다. 운영체제의 종류에 따라 다르겠지만 요청된 메모리 공간을 100% 할당해줄 수 있고. 그 공간 마늠 예약해두고 필요할 때 조금씩 할당해주는 경우도 있다. 각 운영체제의 메모리 할당 방식은 상당히 복잡하며, MySQL 서버가 사용하고 있는 정확한 메모리 양을 측정하는 것 또한 쉽지 않다. 그냥 단순하게 MySQL의 파라미터로 설정해 둔 만큼 운영체제로부터 메모리를 할당받는 다고 생각하는 것이 좋을 듯 하다.

글로벌 메모리 영꽈 로컬 메모리 영억의 처이는 MySQL 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 아닌지에 따라 구분되며 각각 다음과 같은 특성이 있다.

#### 글로벌 메모리 영역
일반적으로 클라이언트 스레드의 수와 무관하게 일반적으로 하나의 메모리 공간만 할당된다. 단 필요에 따라 2개 이상의 메모리 공간을 할당받을 수도 있지만 클라이언트의 스레드 수와 무관하며, 생성된 글로벌 영역이 N개라 하더라도 모든 스레드에 의해 공유된다.

#### 로컬 메모리 영역(세션 메모리 영역)
세션 메모리 영역이라고도 표현하며, MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용되는 메모리 영역이다. 대표적으로 위 그림에 컨넥션 버퍼와 정렬 버퍼 등이 있다. 클라이언트가 MySQL 서버에 접속하면 MySQL 서버에는 클라이언트 컨넥션으로부터 요청을 처리하기 위해 스레드를 하나씩 할당하게 되는데, 클라이언트 스레드가 사용하는 메모리 공간이리고 해서 클라이언트 메모리 역영이라고도한다. 클라이언트와 MySQL 서버와의 컨넥션을 세션이라고 하기 때문에 로컬 메모리 영역을 세션 메모리 영역이라고도 한다.