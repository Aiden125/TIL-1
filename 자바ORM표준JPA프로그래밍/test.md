# 15 고급 주제와 선능 최적화

## 엔티티비교 
영속성 컨텍스트 내부에는 엔티티 인스턴스를 보관하기 위한 1차 캐시가 있다. 이 1차 캐시는 영속성 컨텍스트와 생명주기를 같이 한다.
영속성 컨텍스트를 통해 데이터를 저장하거나 조회하면 1차 캐시에 엔티티가 저장된다. 이 1차 캐시 덕분에 변경 감지 기능도 동작하고, 이름 그대로 1차 캐시로 사용되어서 데티어베이스를 통하지 않고도 데이터를 바로 조회할 수있다.
영속성 컨텍스트를 좀더 정확히 이해하기 위해서는 1차 캐시의 가장 큰 장점인 **애플리케이션 수준의 반복 가능한 읽기**를 이해해야한다. 같은 영속성 컨텍스트에서 엔티티를 조회하면 다음 코드와 같이 항상 같은 엔티티 인스턴스를 변환한다. 이것은 동승성 비교 수준이 아니라 정말 주소값이 같은 인스턴스를 반환한다.

```java
Member member1 = em.find(Member.class, "1L");
Member member2 = em.find(Member.class, "1L");

assertTrue(member1 == member2); // 둘은 같은 인스턴스다.
```

### 영속성 컨텍스트가 같을 때 엔티티 비교 
영속성 컨텍스트가 같으면 엔티티를 비교할 때 다음 3가지 조건을 모두 만족한다.

* 동일성: == 비교가 같다
* 동등성: equals() 비교가 같다
* 데이터베스 동등성: @Id인 데이터베이스 식별자가  같다.

### 영속성 컨텍스트가 다를 때 엔티티 비교
영속성 컨텍스트가 다르면 동일성 비교에 실패한다. 영속성 컨텍스트가 다를 때 엔티티 비교는 다음과 같다.
* 동일성: == 비교가 실패한다
* 동등성: equals() 비교가 만족한다. 단 equals()를 구현해야한다 보통 비지니스 키로 구현한다.
* 데이터베으 동등성: @Id인 데이터베이스가 식별자가 같다.

앞서 보았듯이 같은 영속성 컨텍스트를 보장한다면 동일성 비교만 충분하다. 따라서 OSIV 처럼 요청의 시작부터 끝까지 같은 영속성 컨텍스ㅡ를 사용할 때는 동일성 비교가 성공한다. 하지만 지금 처럼 영소겅 켄텍스트가 달라지면 동일성 비교는 실패한다. 따라서 엔티티의 비교에 다른 방법을 사용해야한다. 동일성 비교 대신에 데이터베이스 동등성을 비교하면 엔티티를 영속화 해야 식별자를 얻을 수 있다는 문제가 있다. 엔티ㅣ를 영속화 하기전에 식별자 값이 null 이므로 정확한 비교를 할 수 없다. 물론 식별자 값을 직접 부여하는 방식을 사용할 때는 데이터베이스 식별자 비교도 가능하다. 하지만 항상 식별자를 먼저 부여하는 것을 보장하기는 쉽지 않다.

남은 것은 equals()를 사용한 동등성 비교인데, **엔티티를 비교할 떄는 비지니스 키를 활용한 동등성 비교를 권장한다.**. 동드엇ㅇ 비교를 위해 equals()를 오버라이딩할 떄는 비지니스 키가 된느 필드를 선택하면 된다. 비지니스 키가 되는 필드는 보통 중복되지 않고 거의 변하지 않는 데이터베이스 기본 키 후보들이 좋은 대상이다. 기본 키는 유일성만 보장되면 가끔 있는 변경 정도는 허용한다. 따라서 데이터베이스 기본 키 같은 너무 딱딱하게 정하지 않아도된다. 예를 들어 회원 엔티티에 이름과 연락처가 같은 회원이 없다면 회원의 이름과 연락처 정도만 조합해서 사용해도 된다.

**정리하자먄 동일성 비교는 같은 영속성 컨텍스트의 관리를 받는 영속 상태의 엔티티에만 적용할 수있다. 그렇지 않을 때는 비지니스 키를 사용한 동등성 비교를 해야한다.**