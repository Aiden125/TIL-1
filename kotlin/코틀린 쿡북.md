> [코틀린 쿡북](http://www.yes24.com/Product/Goods/90452827)

# 2장 코틀린 기초

## 코틀린에서 널 허용 타입 사용하기

**문제**
변수가 절대 null 값을 갖짐 못하게 하고싶다.

**해법**
물음표를 사용하지 않은 변수의 타입을 정의한다. 또한 널 허용 타입은 안전 호출 연사자 ?. or 엘비스 연산자 ?:와 결합하여 사용한다.

**설명**

```kotlin
data class Person(
    val first: String,
    val middle: String?,
    val last: String
)

val middleLength = person.middle?.length ?: 0
```
안전 호출자 `?.`와 엘비스 연산자 `?:`와 결합하여 사용한다.

## 자바에서 널 허용성 지시자 추가하기

**문제**
코틀린 코드가 자바 코드와 상호 작용이 필요하고 널 허용성 애노테이션을 강제하고 싶다.

**해법**
코틀린 코드에서 JSR-305 널 허용 애노테이션을 강제하려면 컴파일 타임 파라미터 `Xjsr305=strict`을 사용한다

**설명**

자바 코드와 상호작용을 하기 위해서 JSR-305 호환 애노테이션을 사용 중이며 코틀린은 해당 호환 라이브러를 지원한다. 해당 라이브러리는 개발이 중지된 상태이다.

```kts
java.sourceCompatibility = JavaVersion.VERSION_11

tasks.withType<KotlinCompile> {
	kotlinOptions {
		freeCompilerArgs = listOf("-Xjsr305=strict")
		jvmTarget = "11"
	}
}
```

JSR-305에 정의돈 `@Notnull` 애노테이션은 when 이라는 속성을 갖는다. when 속성의 값이 when.ALWAYS인 경우 해당 애노테이션의 타입은 널 비허용 타입으로 다뤄진다. when.NAVER라면 널 허용 다뤄진다. when.UNKNOWN 이라면 해당 타입은 널 허용성을 알 수 없는 플랫폼 타입으로 간주한다.

## 자바를 위한 메서드 중복

**문제**
기본 파라미터를 가진 코틀린 함수가 있는데, 자바에서 각 파라미터의 값을 직접적으로 명시하지 않고 코틀린 함수를 호출하고 싶다.


**해법**
@JvmOverloads 애노테이션을 해당 함수에 추가한다.

**설명**

```kotlin
@Test
    internal fun `코틀린에서 중복 함수 변경 호출하기`() {
        // default 메서드에 따라 3개 메서드 구현
        addProduct(name = "name", price = 10, "DESC")
        addProduct(name = "name", price = 10)
        addProduct(name = "name")
    }

    fun addProduct(name: String, price: Int = 0, desc: String? = null) {
        // ..
    }
```
자바는 메소드 기본 인자를 지원하지 않기 떄문에 자바에서 addProduct 함수를 호출하려면 모든 인자를 제공해야한다.

`@JvmOverloads` 애노테이션을 addProduct 함수에 추가하면 컴파일 후 생성된 클래스는 예제 처럼 모든 함수 중복을 지원 한다.

```java
@Test
void checkOverloads() {
    assertAll("overloads called from java", 
        () -> System.out.println(Overloadskt.addProduct("Name", 5.0, "Desc")),
        () -> System.out.println(Overloadskt.addProduct("Name", 5.0)),
        () -> System.out.println(Overloadskt.addProduct("Name"))
    );
}
```
코틀린이 생상한 바이코드를 디컴파일 해보면 다음과 같다.

```java
public final class Person {
   
   @JvmOverloads
   public final void addProduct(@NotNull String name, int price, @Nullable String desc) {
      Intrinsics.checkNotNullParameter(name, "name");
      System.out.println("name: " + name);
      System.out.println("price: " + price);
      System.out.println("String: " + StringCompanionObject.INSTANCE);
   }

   // $FF: synthetic method
   public static void addProduct$default(Person var0, String var1, int var2, String var3, int var4, Object var5) {
      if ((var4 & 2) != 0) {
         var2 = 0;
      }

      if ((var4 & 4) != 0) {
         var3 = null;
      }

      var0.addProduct(var1, var2, var3);
   }

   @JvmOverloads
   public final void addProduct(@NotNull String name, int price) {
      Intrinsics.checkNotNullParameter(name, "name");
      addProduct$default(this, name, price, (String)null, 4, (Object)null);
   }

   @JvmOverloads
   public final void addProduct(@NotNull String name) {
      Intrinsics.checkNotNullParameter(name, "name");
      addProduct$default(this, name, 0, (String)null, 6, (Object)null);
   }
}
```

Person 클래스는 3개의 생성자를 제공한다. @JvmOverloads 애노테이션을 추가하면 명시적으로 constructor 키워드를 사용해야 한다. 

```kotlin
data class Person @JvmOverloads constructor(
    val first: String,
    val middle: String?,
    val last: String
)
```

@JvmOverloads에 의해 생성된 생성자의 경우에 자신의 인자의 개수와 같은 인자의 개수를 같은 부모 클래스의 생성자 호출이 일어나지 않는다.

## 명시적으로 타입 변환하기

**문제**
코틀린은 자동으로 기본 타입을 더 넓은 타입으로, 예를 들어 Int를 Long으로 승격하지 않는다.

**해법**
더 작은 타입을 명시적으로 변환하려면 toInt, toLong 등 구체적으로 변환 함수를 사용한다.

**설명**
더 짧은 타입으로 자동으로 더 긴 타입으로 승격되지 않는다.

```kotlin
int myInt = 3;
long myLong = myInt; //(1)
```
* (1) int가 long으로 자동 승격

자바에서는 자료형을 변환 시키기 위해서는 아래와 같은 코드가 필요하다.

```java
Intefer myInteger = 3;
// Long myWrappedLong = myInteger;          // (1)
Long myWrappedLong = myInteger.longValue(); // (2)
myWrappedLong = Long.valueOf(myInteger);    // (3)
```
* (1) 컴파일되지 않음
* (2) long으로 추출한 다음 래퍼 타입으로 감쌈
* (3) 래퍼 타입을 벗겨 int 타입을 얻고 long으로 승격시킨 다음 다시 랩

래퍼 타입을 직접 다루는 것은 언박싱을 개발자 스스로 해야 한다는 의미이다. 먼저 포장된 값을 추출하는 작업 없이는 간단하게 Integer 인스턴스를 Long에 할당할 수 없다.

```kotlin
val intVar: Int = 3
// val longVar: Long = intVar       // (1)
val longVar: Long = intVar.toLong() // (2)
```
* (1) 컴파일도지 않음
* (2) 명시적 타입 변환

다행이도 코틀린은 타입 변환을 투명하게 수행하는 연산자가 있기 때문에 다음 코드는 명시적 타입 변환이 필요하지 않다.

```kotlin
val longSum = 3L + intVar
```

더하기(+) 연산자는 자동으로 intVardml 값을 long으로 변환하고 long 리터널에 그 값을 더한다.

## 다른 기수로 출력하기

**문제**
십진법이 아닌 다른 기수를 사용하는 숫자를 출력하고 싶다.

**해법**
올바른 기수를 위해 확장 함수 toString(radix: int)를 사용하자.

**설명**
자바에서 숫자를 이진법으로 출력하고 싶다면 Integer.toBinaryString 메소드나 정적 Integer.toString(int, int) 메서드를 사용할 것이다. 첫 번째 인자는 변환할 값이고 두 번째 인자는 원하는 기수이다.

하지만 코틀린에서 자바의 정적 메서드를 사용해서 Byte와 Short, Int, Long에 확장 함수 toSring(radix: Int)을 만들어 놓았다.

```kotlin
42.toString(2) == "101010"
```
이진 표현에서 비트의 위치는 오른쪽에서 왼쪽로 1, 2, 4, 8, 16 등에 해당한다. 42는 2+8+32 이며 그 이유는 해당 숫자의 비트 위치는 1이고 나머지는 0이기 때문이다.


## 숫자를 거듭제곱하기

**문제**
숫자를 거듭제곱하고 싶지만 코틀린에는 미리 정의된 거듭제곱 연산자가 없다

**해법**
Int와 Long에 정의돼 있는 코틀린 확장 함수 pow에 위임하는 중위 함수를 정의한다.

**설명**
코틀린에는 자바처럼 내장 거듭제곱 연산자가 없다.

```kotlin
@Test
fun `정수를 지수로 만들기`() {
    val toInt = 2.toDouble().pow(8).toInt()
    println(toInt)
}
```

## 비트 시프트 연산자 사용하기

**문제**
비트 시프트 연산자를 사용하고 싶다.

**해법**
코틀린에는 비트 시프트를 위한 shr, shl, ushr 같은 비트 중위 연산자가 있다.

**설명**
비트 연산은 리스트 접근 제어 및 통신 프로토컬, 압축, 암호화 알고리즘, 컴퓨터 그래픽을 비롯한 수많은 애플리케이션에서 사용된다.

| 함수 | 설명                    |
| ---- | ----------------------- |
| shl  | 부호 있는 외쪽 시프트   |
| shr  | 부호 있는 오른쪽 시프트 |
| ushr | 부호 없는 오른쪽 시프트 |


```kotlin
@Test
    fun `2를 곱하거나 나누기`() {
    // shl
    then(2).isEqualTo(1 shl 1)
    then(4).isEqualTo(1 shl 2)
    then(8).isEqualTo(1 shl 3)
    then(16).isEqualTo(1 shl 4)
    then(32).isEqualTo(1 shl 5)
    then(64).isEqualTo(1 shl 6)
    then(128).isEqualTo(1 shl 7)

    // shr
    then(117).isEqualTo(235 shr 1)
    then(58).isEqualTo(235 shr 2)
    then(29).isEqualTo(235 shr 3)
    then(14).isEqualTo(235 shr 4)
    then(7).isEqualTo(235 shr 5)
    then(3).isEqualTo(235 shr 6)
}
```

## 비트 불리언 연산자 사용하기

**문제**
비트 값에 마스크를 적용하고 싶다.

**해법**
비트 불리언 연산을 위해 코틀린이 제공하는 and, or, xor, inv 비트 연산자를 사용한다.

**설명**
Int와 Long에 정의되어 있는 시프트 연산자뿐만 아니라 코틀린은 마스킹 연산자 and, or, xor, inv도 정의되어 있다.

inv 함수는 숫자의 모든 비트를 뒤집는다,. 간단한 예를 들면 숫자 4의 바이너리 값은 0b00000100이다. 주어진 모든 비트를 뒤집으면 0b11111011인데, 이 값은 십진수로 251이다. 하지만 숫자 4에서 inv 함수를 호출하면

```kotlin
@Test
fun `숫자 4비트 반전`() {
    // 4 == 0b0000_0100
    // 주어진 비트 보수
    then(-5).isEqualTo(4.inv())
}
```

```kotlin
@Test
fun `and or xor 간단한 예`() {
    val n1 = 0b000_1100 // 십진수 12
    val n2 = 0b001_1001 // 십진수 25

    val n1_and_n2 = n1 and n2
    val n1_or_n2 = n1 or n2
    val n1_xor_n2 = n1 xor n2

    then(n1_and_n2).isEqualTo(0b000_1000) // 8
    then(n1_or_n2).isEqualTo(0b001_1101) // 29
    then(n1_xor_n2).isEqualTo(0b001_0101) // 21
}
```

## 레시피 to Pair 인스턴스 생성하기

**문제**
Pair 클래스의 인스턴스를 생성하고 싶다.

**해법**
직접 Pair 클래스의 인스턴스를 생성하기보다 중위 to 함수를 사용한다.

**설명**

mapOf와 같은 맵 생성을 위한 최상위 함수를 몇 가지 제공한다.

```kotlin
fun <K, V> map(varag pairs: Pair<K, V>): Map<K, V>
```

Pair는 first, second라는 이름의 두 개의 원소를 갖는 데이터 클래스다. Pair 클래스의 시그니처는 다음과 같다.

```kotlin
data class Pair<out A, out B> : Serializable
```
2개의 인자를 받는 생성자를 사용해서 Pair 클래스를 생성할 수 있지만 to 함수를 사용하는 것이 더 일반적이다. to 함수는 다음과 같이 정의되어 있다.

```kotlin
public infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)
```

```kotlin
@Test
fun `mapOf 인자인 pair를 생성하기 위해 to 함수 사용하기`() {
    val map = mapOf(
        "a" to 1,
        "b" to 2,
        "c" to 2
    )
    println(map) // {a=1, b=2, c=2}
}

@Test
fun `map of`() {
    val pair1: Pair<String, Int> = Pair("z", 1)
    val pair2: Pair<String, Int> = "a" to 1
}
```




# 3장 코틀린 객체 지향 프로그래밍

# 4장 함수형 프로그래밍

# 5장 컬렉션

# 6장 시퀀시

# 7장 영역 함수

# 8장 코틀린 대리자

# 9장 테스트

# 10장 입력/출력

# 11장 그 밖의 코틀린 기능

# 12장 스프링 프레임워크

# 13 코루틴과 구조적 동시성