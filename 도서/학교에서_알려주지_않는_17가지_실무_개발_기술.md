> [학교에서 알려주지 않는 17가지 실무 개발 기술](http://www.yes24.com/Product/Goods/89906094)를 보고 정리한 내용입니다.

# 문자열 인코딩

## 문자열 인코딩이란
**문자열 인코딩 이란 2진법을 사용하는 컴퓨터가 인간의 언어를 일정한 큐칙에 따라 2진수로 뱐환하는 방식입니디.** 컴퓨터는 `안녕하세여`와 같은 문자을 그래도 읽거나 처리할 수 없기 떄문입니다.

**그래서 컴퓨터는 사람들이 만든 2진수와 문자를 일대일로 대응하는 규칙을 통해 2진수로 문자를 처리합니다.** `EUC-KR`, `UTF-8`, `UTF-16`, `UTF-32` 이러한 규칙에 포함됩니다. 문자열 인코딩 규칙은 종류에따라 변호나 방식이 조금씩 다르지만 원리는 간단합니다.

아스키 코드를 예를 들면 2진수 `01000001`을 10진수로 읽으면 `65`가 되지만, 아시크 코드로 읽으면 문자 `A`가됩니다. 

여러 국가에서 컴퓨터를 사요아기 위해 국가별로 사용하는 언어를 표현하고자 독자적인 규칙을 만들기 시작했습니다. 모든 언어를 같은 규칙으로 표현할 수 있는 유니코드 방식이 등장하기 전까지 말입니다.

개발자는 서로 호환되지 않은 유니코드 문자열 인코딩 방식 `UTF-8`, `UTF-16`, `UTF-32` 중 하나를 책해야 합니다. 심지어 한국에서는 유니코드가 등장하기 전에 만든 독자적인 인코딩 방식 `EUC-KR`을 쓰는 오래된 시스템도 아직 남아 있습니다.

개발자들은 문자열 인코딩 외 **문자 집합** 이라는 용어도 함꼐 사용합니다. 엄격하게 구분하면 문자 집합은 사용할 수 있는 문자들의 집합을 말합니다. 유니코드, ISO-8859, ASCII 등이 이에 해당합니다.

반면 문자열 인코딩은 문자를 코드로 표현하는 방식을 일컷습니다. 예를 드렁 유니코드라는 문자 집합을 표현하는 문자열 인코딩은 `UTF-8`, `UTF-16`, `UTF-32`등이 있습니다.

## 아스키 코드
아스키 코드는 처음으로 표휸을 정립한 문자열 인코딩 방식으로 아직까지 많이 사용됩니다. 사용할 수 있는 문자의 종류에는 대문자,소문자, 아리바아 숫자, 공백 및 특수문자들이 있으며 문자를 표현할 떄는 0 ~ 127, 총 128개의 숫자를 사용합니다.

![](https://ww.namu.la/s/05acaba21abdca4ab79fdc7a1c604e2535b074bbe37a51181d89120499081e0d19000a106a7c96c99bebf82bc785f0e8ff45a98a32493cef61ba8722acef83475d80e50d978d53ad6e2bf2e9f3a05f0c69f20a8ec8aeec85f7c62c2b4816a564)

**컴퓨터는 2진수 데이터를 한 가지 형태로만 인식할 수 있기 떄문에 숫자와 문자를 동시에 인식할 수 없습니다.** 이러한 문제를 해결하기 위해 숫자를 나타내는 문자열을 만들었습니다.

## EUC-KR
EUC-KR은 한국 산업 표준으로 지정되어 한국 문자 집합으로 문자 하나를 표현하기 위해 2바이트를 사용합니다. 단 아스키 코드 문자를 표현할 떄는 1바이트를 사용하기 대문에 아시크 코드와 호환됩니다.

**EUC-KR은 ㅗㅁ든 글자가 완성된 형태로만 존재하는 완성형 코드입니다.** 따라서 한글 처럼 초성, 중성, 조성을 조합해 문자를 만들수 없기 떄문에 EUC-KR로 표현할 수없는 한글이 일부 본재합니다. 물론 일바적으로 사용하는 문자는 아니기긴 합니다.

```
'Hello' 문자열 길이 : 5
'Hello' 전체 문자를 표현하는 데 사용한 바이트 수 : 5 바이트
'Hello' 16진수 값: 0x48 0x65 0x6c 0x6c 0x6f
'Hello' 10진수 값: 72 101 108 108 111

'안녕하세요' 문자열 길이: 5
'안녕하세요' 전체 문자를 표현하는 데 사용한 바이트 수 : 10 바이트
'안녕하세요' 16진수 값: 0xbe 0xc8 0xb3 0xe7 0xc7 0xcf 0xbc 0xbc 0xbf 0xe4
'안녕하세요' 10진수 값: 190 200 179 231 199 207 188 181 288
```
`안녕하세요`를 출력하기 위해서는 10바이트를 사용했습니다. `EUC-KR`로 아스키 코드 영역에 있는 글자를 표현할 떄는 1바이트를 사용하지만, 한글 문자 표현할 떄는 2바이트를 사용하기 때문입니다. 이처럼 **문자열 인코딩에서는 실제 문자열 길이가 버퍼길이와 다른 경우가 많습니다. 실제 문자열 길이는 사람 눈에 보이는 문자열에 해당하고, 버퍼 길이는 컴퓨터가 문자를 표현하는 데 사용하는 바이트 수를 의미합니다.** 그래서 실제 문자열 길이와 컴퓨터가 할당하는 버퍼 크기는 항상 다를 수 있다는 점을 꼭 기억하시길 바랍니다.

## 유니코드 `UTF-8`, `UTF-16`, `UTF-32`
국가별로 독자적인 문자열 인코등을 사용하는 문제를 해결하기 위해 구겢 표준 기구에서 동일한 규칙으로 모든 언어를 표현할 수 있는 유니코드 문자열집합을 만들었습니다.

### `UTF-8`
`UTF-8`은 8비트(바이트)로 인코딩을 표현하는 것을 의미합니다. `UTF-8`은 아스키코드와 완벽하게 호환되며, 표현하려는 문자에 따라 최소 1바이트 최대 6바이트까지 사용합니다.


바이트 수 | 바이트 1 | 바이트 2 | 바이트 3 | 바이트 4 | 바이트 5 | 바이트 6
-----|------|------|------|------|------|-----
1 | 0xxxxxxx | - | - | - | - | -
2 | 110xxxxx | 10xxxxxx | - | - | - | -
3 | 1110xxxx | 10xxxxxx | 10xxxxxx | - | - | -
4 | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx | - | -
5 | 111110xx | 10xxxxxx | 10xxxxxx | 10xxxxxx | 10xxxxxx | -
6 | 1111110x | 10xxxxxx | 10xxxxxx | 10xxxxxx | 10xxxxxx | 10xxxxxx

`바이트 수`행의 값은 문자를 표현하는 데 사용하는 총 바이트를 뜻합니다. `바이트 1` ~ `바이트 6`까지 있는 1과 9은 고정된 비트 값이며, 사용하는 비트수에 따라 달라집니다. `x` 문자는 유니코드를 조장하는 데 사요할 비트 영역입니다.

첫 번쨰 줄(바이트문자 1)은 첫 번쨰 비트 값이 0이므로 0을 제외한 나머지 비트 7개로 문자를 표현합니다 **0 ~ 127까지 수로 문자를 표현하는 아시크 코드와 같은 규칙을 사용하므로 UTF-8은 아시크 코드와 완벽히 호환됩니다.**

두 번째 줄 (바이트 문자 2)은 비트 값이 `110`으로 시작합니다. 이 경우에는 2바이트로 `UTF-8` 문자를 읽어야 합니다. 첫 번쨰 바이트의 `1110xxxx`에서 `110`을 제외한 비트 5개, 두 번째 바이트 `10xxxxxx`에서 `10`을 제외한 비트 6개를 조합하면 총 11개의 비트로 `UTF-8` 문자를 만들 수 있습니다.

**보통 일반적인 문자는 3바이트 이내로 처리되며, 4바이트 영역에서 이모지같은 문자가 있습니다.** 고대 문자 같은 것을 사용하지 않은 한 5바이트 이상을 쓰는 경우가 거의 없습니다.

#### `UTF-8` 문자열 출력

```
'Hello' 문자열 길이 : 5
'Hello' 전체 문자를 표현하는 데 사용한 바이트 수 : 5 바이트
'Hello' 16진수 값: 0x48 0x65 0x6c 0x6c 0x6f
'Hello' 10진수 값: 72 101 108 108 111

'안녕하세요' 문자열 길이: 5
'안녕하세요' 전체 문자를 표현하는 데 사용한 바이트 수 : 15 바이트
'안녕하세요' 16진수 값: 0xec 0x95 0x 88 0xeb 0x85 0x 95 0xed 0x95 0x98 0xec 0x84 0x b8 0xec 0x9a 0x94
'안녕하세요' 10진수 값: 236 149 136 235 133 149 237 149 152 236 132 185 236 154 148
```

##### `UTF-8` 문자열 출력: `Hello`
`H`문자가 16진수 `0x48`로 출력됐습니다. `UTF-8`은 아스키코드와 호환되기 떄문에 출력되는 값 또한 아시크 코드와 같습니다.

##### `UTF-8` 문자열 출력: `안녕하세요`
한글 5글자를 표현하는 데 15바이트를 사용했습니다. 글자당 3바이트를 사요한 셈입니다. 먼저 `안`을 구성하는 16진수 값은 `0xec`, `0x95`, `0x88`을 각각 2진수료 표현 하면 다음과 같습니다.

16진수 | 2진수
-----|----
0xec | `1110` 1100
0x95 | `10`01 0101
0x88 | `10`00 1000

16진수 값을 차례대로 나열하면 다음과 같습니다

`11101100 10010101 10001000`

조회한 값의 첫 번쨰 바이트(`1110`1100)는 `1110`으로 시작합니다. 첫 번째 바이트가 (바이트1)가 `1110`으로 시작할 떄는 3바이트 크키가 3개의 글자가 되는 것을 알 수 있습니다.

바이트 수 | 바이트 1 | 바이트 2 | 바이트 3 | 바이트 4 | 바이트 5 | 바이트 6
-----|------|------|------|------|------|-----
3 | 1110xxxx | 10xxxxxx | 10xxxxxx | - | - | -

두 번쨰, 세 번쨰가 바이트에 있는 비트값 10은 `UTF-8`형식을 구성하는 욛도로만 사용되므로 실제 값을 읽을 떄는 사용되지 않습니다.

그래서 첫 번쨰 바이트 (1110`1110`)에서 `1110`을 제외한 비트값 `1110` 두 번쨰 바이트(10`010101`)에서 10을 제외한 비트 값 `010101`, 세 번쨰 바이트(10`001000`)에서 10을 제외한 비트값 (`0010000`)을 읽어서 다시 한번 조합하면 다음과 같은 값을 만들 수 있습니다.

`1100010101001000`

[onlineutf8tools](https://onlineutf8tools.com/convert-binary-to-utf8)에서 확인 가능


