# 목차
<!-- TOC -->

- [목차](#목차)
- [[레시피 3-3] 핸들러 인터셉터로 요청 가로채기](#레시피-3-3-핸들러-인터셉터로-요청-가로채기)
    - [과제](#과제)
    - [해결책](#해결책)
    - [풀이](#풀이)

<!-- /TOC -->

# [레시피 3-3] 핸들러 인터셉터로 요청 가로채기

## 과제
* 서블릿 명세에 정의돈 서블릿 필터를 쓰면 웹 요청을 서블릿이 처리하기 전후에 각각 전처리, 후처리를 할 수 있습니다.
* 스프링 웹 애플리케이션 컨테스트와 필터와 유사한 함수를 구성해서 컨테이너 기능을 십분 활용해보세요

## 해결책
* 스프링 MVC에서 웹 요청은 핸들러 인터셉터로 가로채 전처리/후처리를 할 수 있습니다.
* 핸들러 인터셉터는 특정 요청 URL에만 적용되도록 매핑할 수 있습니다.
* 핸들러 인터셉터는 예외 없이 `HandlerIntereceptor` 인터페이스를 구현해야 하며. `preHandle()`, `postHandle()`, `afterComplection()` 세 콜백 메서드를 구현합니다.
* `preHandle()`, `postHandle()` 메서드는 헨들러가 요청을 처리하기 직전과 직후에 가각 호출 됩니다.

## 풀이
핸들러 메서드에서 웹 요청을 처리하는 데 걸린 시간을 측정해서 뷰로 보여줍시다. 

```java
public class MeasurementInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        long startTime = System.currentTimeMillis();
        request.setAttribute("startTime", startTime);
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        long startTime = (long) request.getAttribute("startTime");
        long endTime = System.currentTimeMillis();
        request.setAttribute("endTime", endTime);
        System.out.println(endTime - startTime);
    }
    ...
}
```
* `preHandle()` 메서드는 요청 처리를 시작한 시작을 재서 요청 속성에 보관합니다.
* **`DispacthersServlet`은 `preHandle()` 메서드가 반드시 true를 반환해야 요청 처리를 계속 진행** 하여 그 외에는 이 메서드 선에서 요청 처리가 끝났다고 보고 유저에게 곧장 응답 객체를 반환합니다.
* `postHandle()` 메서드는 요청 속성에 보관된 시작 시각을 읽어들여 현재 시각과 비교해서 계산된 요소 시간을 모델에 추가한 뒤 뷰에게 넙깁니다.
* 자바에서는 인터페이스를 구현할 때 에는 원하지 앟은 메서드까지 모조리 규현해야 하는 규칙이 있습니다. 그래서 인터페이스를 군현하는 대신에 인터셉터 어뎁터 클래스를 상속 받아 사용 할수도 있습니다. `... extends HandlerInterceptorAdapter` 를 사용
  

 ```java
 @Configuration
public class InterceptorConfig  implements WebMvcConfigurer {

    @Bean
    public MeasurementInterceptor measurementInterceptor(){
        return new MeasurementInterceptor();
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(measurementInterceptor());
    }
}
``` 
* MeasurementInterceptor 인터셉터는 WebMvcConfigurer 인터페이스의 구현 클래스 InterceptorConfig에 등록할 수 있습니다.
* Bean으로 등록된 `measurementInterceptor`를 addInterceptors 메서드를 활용해서 InterceptorRegistry에 등록합니다.

```java
@GetMapping("interceptor")
public void interceptor(HttpServletRequest request, @RequestHeader HttpHeaders headers) {
    Long startTime = (Long) request.getAttribute("startTime"); //1538663792873
}
```
* 컨트롤러에서 `preHandle()` 메서드에서 설정한 `startTime` 시간 값을 확인할 수 있다.


# [레시피 3-4] 유저 로케일 해석하기

## 과제
다국어를 지원하는 웹 애플리케이션에서 각 유저마다 선호하는 로케일을 식별하고 그에 알맞은 콘텐트를 표시하세요

## 해결책
* 스프링 MVC 애플리케이션에서 유저 로케일은 LocaleResolver 인터페이스를 구현한 로케일 리졸버가 식별합니다.
* 로케일을 해석하는 기준에 따라 여러 LocaleResolver 구현체가 스프링 MVC에 준비되어 있습니다.
* LocaleResolver 는 웹 애플리케이션 컨텍스트에 LocaleResolver형 빈으로 등록합니다.
* DispatcherServlet이 자동 감지하면 로케일 리졸버 빈을 localeResolver라고 명령합니다.
* 참고로 LocaleResolver는 하나만 등록 가능합니다.

## 풀이


# [레시피 4-3] 스프링으로 REST 서비스 액세스하기

## 과제
스프링 애플리케이션 서드파티 REST 서비스의 페이로드를 받아 사용하세요

## 해결책
* 스프링 애플리케이션 에서 서드파티 REST 서비스는 RestTemplate 클래스를 이용해 액세스합니다.
* 스프링 애플리케이션에서 REST 서비스를 호출하고 반환받는 페이로드를 사용하기 아주 간편해 졌습니다.

## 풀이
```java
    @GetMapping("/members")
    public Member member(){
        return Member
                .builder()
                .address("address")
                .age(10)
                .email("asdasd@asd.com")
                .build();
    }
    
    ...
    @Override
    public void run(ApplicationArguments args) throws Exception {
        final RestTemplate restTemplate = restTemplateBuilder.build();
        final String URL = "http://localhost:8080/members";
        final String result = restTemplate.getForObject(URL, String.class);
        System.out.println(result); //{"name":"name","email":"asdasd@asd.com","age":10,"address":"address"}
    }
```
* RestTemplate 클래스를 메서드를 이요해서 REST 서비스를 엑세스해서 그 결과를 print로 출력한 코드입니다.
* `getContentAsString()` 메서드 호출 결과로 받은 응답은 stirng contentAsString 변수에 할당됩니다.
* JSON을 문자열을 데이터 추출하는 조작은 비효율적이고 실수를 하기 좋은 구조입니다.

### 매개변수화한 URL에서 데이터 가져오기
```java
    @Override
    public void run(ApplicationArguments args) throws Exception {
        final RestTemplate restTemplate = restTemplateBuilder.build();
        Map<String, String> params = new HashMap<>();
        params.put("memberId", "1");

        final String URL = "http://localhost:8080/members/{memberId}";
        final String result = restTemplate.getForObject(URL, String.class, params);
        System.out.println(result); // {"name":"name","email":"asdasd@asd.com","age":10,"address":"address"}
    }
```
* `http://localhost:8080/members/{memberId}` 처럼 URL 자체를 매개변수화 해서 바인딩 시킬 수 있습니다.
* `http://localhost:8080/members/1` 가 실제 호출되는 URL 주소
* 
### 데이터를 매핑된 객체로 가져오기

```java
    @Override
    public void run(ApplicationArguments args) {
        final RestTemplate restTemplate = restTemplateBuilder.build();
        final String URL = "http://localhost:8080/members";
        final Member member = restTemplate.getForObject(URL, Member.class);
        System.out.println(member.toString()); // Member(name=name, email=asdasd@asd.com, age=10, address=address)
    }

```
* 리턴 타입을 인자로 넘긴 클래스타입으로 받을 수 있음 Member.class
* 캡슐화 안전성 등등 해당 방법이 가장 좋다고 생각

### RestTemplateBuilder 사용법

```java
@Component
public class RestTemplateFactory {
    @Autowired
    private RestTemplateBuilder restTemplateBuilder;

    @Bean
    public RestTemplate restTemplate() {
        return restTemplateBuilder
                .additionalInterceptors(new CustomClientHttpRequestInterceptor())
                .errorHandler(new CustomResponseErrorHandler())
                .setConnectTimeout(3000)
                .build();
    }
}
```
* additionalInterceptors: Http Request 에대한 로깅 처리
* errorHandler : Http Request 에러 핸들링 처리
* setConnectTimeout : Http connection Timeout 설정

```java
@Slf4j
public class CustomClientHttpRequestInterceptor implements ClientHttpRequestInterceptor {
    
    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {
        logRequestDetails(request, body);
        return execution.execute(request, body);
    }

    private void logRequestDetails(HttpRequest request, byte[] body) {
        log.info("================");
        log.info("Headers: {}", request.getHeaders()); 
        log.info("Request Method: {}", request.getMethod());
        log.info("Request URI: {}", request.getURI());
        log.info("Request body: {}", new String(body, StandardCharsets.UTF_8));
        log.info("================");
    }
}
```
```
 Headers: {Accept=[application/json, application/json, application/*+json, application/*+json], Content-Type=[application/json;charset=UTF-8],
 Request Method: POST
 Request URI: http://localhost:8080/members
 Request body: {"name":null,"email":null,"age":10,"address":null}
```

# [레시피 4-4] RSS/아톰 피드 발행하기

## 과제
스프링 애플리케이션에서 RSS/아톰 피드를 발행하세요

## 해결책
* 자바 오픈소스 프레임워크 ROME 사용 

## 풀이
* RSS/아톰 피드로 발행할 정보를 결정

```java
@Controller
public class FeedController {
    @RequestMapping("/atomfeed")
    public String getAtomFeed(Model model) {
        List<TournamentContent> tournamentList = new ArrayList<>();
        tournamentList.add(TournamentContent.of("ATP", new Date(), "Australian Open", "www.australianopen.com"));
        tournamentList.add(TournamentContent.of("ATP", new Date(), "Roland Garros", "www.rolandgarros.com"));
        tournamentList.add(TournamentContent.of("ATP", new Date(), "Wimbledon", "www.wimbledon.org"));
        tournamentList.add(TournamentContent.of("ATP", new Date(), "US Open", "www.usopen.org"));
        model.addAttribute("feedContent", tournamentList);

        return "atomfeedtemplate";
    }

    @RequestMapping("/rssfeed")
    public String getRSSFeed(Model model) {
        List<TournamentContent> tournamentList;
        tournamentList = new ArrayList<>();
        tournamentList.add(TournamentContent.of("FIFA", new Date(), "World Cup", "www.fifa.com/worldcup/"));
        tournamentList.add(TournamentContent.of("FIFA", new Date(), "U-20 World Cup", "www.fifa.com/u20worldcup/"));
        tournamentList.add(TournamentContent.of("FIFA", new Date(), "U-17 World Cup", "www.fifa.com/u17worldcup/"));
        tournamentList.add(TournamentContent.of("FIFA", new Date(), "Confederations Cup", "www.fifa.com/confederationscup/"));
        model.addAttribute("feedContent", tournamentList);

        return "rssfeedtemplate";
    }
}

```
* http//[호스트명]/[어플리케이션명]/atomfeed 형식의 URI를 getAtomFeed 매핑
* http//[호스트명]/[어플리케이션명]/rssfeed 형식의 URI를 getRSSFeed 매핑
* TournamentContent는 POJO 객체, 해당 뷰의 값

```java
@Configuration
@EnableWebMvc
public class CourtRestConfiguration {

    @Bean
    public AtomFeedView atomfeedtemplate() {
        return new AtomFeedView();
    }

    @Bean
    public RSSFeedView rssfeedtemplate() {
        return new RSSFeedView();
    }
}
```
* 해당 Bean 등록

```java
public class AtomFeedView extends AbstractAtomFeedView {

    @Override
    protected void buildFeedMetadata(Map<String, Object> model, Feed feed, HttpServletRequest request) {
        feed.setId("tag:tennis.org");
        feed.setTitle("Grand Slam Tournaments");

        @SuppressWarnings({"unchecked"})
        List<TournamentContent> tournamentList = (List<TournamentContent>) model.get("feedContent");

        feed.setUpdated(tournamentList.stream().map(TournamentContent::getPublicationDate).sorted().findFirst().orElse(null));

    }

    @Override
    protected List<Entry> buildFeedEntries(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response)
        throws Exception {
        @SuppressWarnings({"unchecked"})
        List<TournamentContent> tournamentList = (List<TournamentContent>) model.get("feedContent");
        return tournamentList.stream().map(this::toEntry).collect(Collectors.toList());
    }
    ...
}
```
* `buildFeedMetadata()` 메서드는 피드 데이터가 담긴 Map 객체, 피드를 처리하는데 필요한 ROME의 Feed 객체, HTTP 요청을 다루어야할 때 필요한 HttpServletRequest을 받습니다.
* `buildFeedEntries()` 메서드는 Map 객체에 접근해서 호출부가 할당한 feddcontent 객체를 꺼내옴
* `Entity` 객체 List 기반으로 루프를 돌려 설정을 완료