# 목차

<!-- TOC -->

- [목차](#목차)
- [[레시피 3-3] 핸들러 인터셉터로 요청 가로채기](#레시피-3-3-핸들러-인터셉터로-요청-가로채기)
    - [과제](#과제)
    - [해결책](#해결책)
    - [풀이](#풀이)
- [[레시피 3-4] 유저 로케일 해석하기](#레시피-3-4-유저-로케일-해석하기)
    - [과제](#과제)
    - [해결책](#해결책)
    - [풀이](#풀이)
- [[레시피 4-3] 스프링으로 REST 서비스 액세스하기](#레시피-4-3-스프링으로-rest-서비스-액세스하기)
    - [과제](#과제)
    - [해결책](#해결책)
    - [풀이](#풀이)
        - [매개변수화한 URL에서 데이터 가져오기](#매개변수화한-url에서-데이터-가져오기)
        - [데이터를 매핑된 객체로 가져오기](#데이터를-매핑된-객체로-가져오기)
        - [RestTemplateBuilder 사용법](#resttemplatebuilder-사용법)
- [[레시피 4-4] RSS/아톰 피드 발행하기](#레시피-4-4-rss아톰-피드-발행하기)
    - [과제](#과제)
    - [해결책](#해결책)
    - [풀이](#풀이)
- [[레시피 5-4] 웹소켓](#레시피-5-4-웹소켓)
    - [과제](#과제)
    - [해결책](#해결책)
    - [풀이](#풀이)
        - [웹소켓](#웹소켓)
        - [WebSocketHandler 작성하기](#websockethandler-작성하기)
- [[레시피 5-5] 스프링 웹플럭스로 리액티브 애플리케이션 개발하기](#레시피-5-5-스프링-웹플럭스로-리액티브-애플리케이션-개발하기)
    - [과제](#과제)
    - [해결책](#해결책)
        - [스프링 웹플러스 컨트롤러 작성하기](#스프링-웹플러스-컨트롤러-작성하기)
        - [타임피르 뷰 작성하기](#타임피르-뷰-작성하기)
- [레시피 [5-6] 리액티브 컨트롤러로 폼 처리하기](#레시피-5-6-리액티브-컨트롤러로-폼-처리하기)
    - [과제](#과제)
    - [해결책](#해결책)
    - [풀이](#풀이)
        - [폼 뷰작성하기](#폼-뷰작성하기)
        - [폼 처리 서비스 작성하기](#폼-처리-서비스-작성하기)
        - [폼 컨트롤러 작성하기](#폼-컨트롤러-작성하기)
        - [폼데이터 검증하기](#폼데이터-검증하기)

<!-- /TOC -->

# [레시피 3-3] 핸들러 인터셉터로 요청 가로채기

## 과제
* 서블릿 명세에 정의돈 서블릿 필터를 쓰면 웹 요청을 서블릿이 처리하기 전후에 각각 전처리, 후처리를 할 수 있습니다.
* 스프링 웹 애플리케이션 컨테스트와 필터와 유사한 함수를 구성해서 컨테이너 기능을 십분 활용해보세요

## 해결책
* 스프링 MVC에서 웹 요청은 핸들러 인터셉터로 가로채 전처리/후처리를 할 수 있습니다.
* 핸들러 인터셉터는 특정 요청 URL에만 적용되도록 매핑할 수 있습니다.
* 핸들러 인터셉터는 예외 없이 `HandlerIntereceptor` 인터페이스를 구현해야 하며. `preHandle()`, `postHandle()`, `afterComplection()` 세 콜백 메서드를 구현합니다.
* `preHandle()`, `postHandle()` 메서드는 헨들러가 요청을 처리하기 직전과 직후에 가각 호출 됩니다.

## 풀이
핸들러 메서드에서 웹 요청을 처리하는 데 걸린 시간을 측정해서 뷰로 보여줍시다. 

```java
public class MeasurementInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        long startTime = System.currentTimeMillis();
        request.setAttribute("startTime", startTime);
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        long startTime = (long) request.getAttribute("startTime");
        long endTime = System.currentTimeMillis();
        request.setAttribute("endTime", endTime);
        System.out.println(endTime - startTime);
    }
    ...
}
```
* `preHandle()` 메서드는 요청 처리를 시작한 시작을 재서 요청 속성에 보관합니다.
* **`DispacthersServlet`은 `preHandle()` 메서드가 반드시 true를 반환해야 요청 처리를 계속 진행** 하여 그 외에는 이 메서드 선에서 요청 처리가 끝났다고 보고 유저에게 곧장 응답 객체를 반환합니다.
* `postHandle()` 메서드는 요청 속성에 보관된 시작 시각을 읽어들여 현재 시각과 비교해서 계산된 요소 시간을 모델에 추가한 뒤 뷰에게 넙깁니다.
* 자바에서는 인터페이스를 구현할 때 에는 원하지 앟은 메서드까지 모조리 규현해야 하는 규칙이 있습니다. 그래서 인터페이스를 군현하는 대신에 인터셉터 어뎁터 클래스를 상속 받아 사용 할수도 있습니다. `... extends HandlerInterceptorAdapter` 를 사용
  

```java
 @Configuration
public class InterceptorConfig  implements WebMvcConfigurer {

    @Bean
    public MeasurementInterceptor measurementInterceptor(){
        return new MeasurementInterceptor();
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(measurementInterceptor());
    }
}
``` 
* MeasurementInterceptor 인터셉터는 WebMvcConfigurer 인터페이스의 구현 클래스 InterceptorConfig에 등록할 수 있습니다.
* Bean으로 등록된 `measurementInterceptor`를 addInterceptors 메서드를 활용해서 InterceptorRegistry에 등록합니다.

```java
@GetMapping("interceptor")
public void interceptor(HttpServletRequest request, @RequestHeader HttpHeaders headers) {
    Long startTime = (Long) request.getAttribute("startTime"); //1538663792873
}
```
* 컨트롤러에서 `preHandle()` 메서드에서 설정한 `startTime` 시간 값을 확인할 수 있다.


# [레시피 3-4] 유저 로케일 해석하기

## 과제
다국어를 지원하는 웹 애플리케이션에서 각 유저마다 선호하는 로케일을 식별하고 그에 알맞은 콘텐트를 표시하세요

## 해결책
* 스프링 MVC 애플리케이션에서 유저 로케일은 LocaleResolver 인터페이스를 구현한 로케일 리졸버가 식별합니다.
* 로케일을 해석하는 기준에 따라 여러 LocaleResolver 구현체가 스프링 MVC에 준비되어 있습니다.
* LocaleResolver 는 웹 애플리케이션 컨텍스트에 LocaleResolver형 빈으로 등록합니다.
* DispatcherServlet이 자동 감지하면 로케일 리졸버 빈을 localeResolver라고 명령합니다.
* 참고로 LocaleResolver는 하나만 등록 가능합니다.

## 풀이


# [레시피 4-3] 스프링으로 REST 서비스 액세스하기

## 과제
스프링 애플리케이션 서드파티 REST 서비스의 페이로드를 받아 사용하세요

## 해결책
* 스프링 애플리케이션 에서 서드파티 REST 서비스는 RestTemplate 클래스를 이용해 액세스합니다.
* 스프링 애플리케이션에서 REST 서비스를 호출하고 반환받는 페이로드를 사용하기 아주 간편해 졌습니다.

## 풀이
```java
    @GetMapping("/members")
    public Member member(){
        return Member
                .builder()
                .address("address")
                .age(10)
                .email("asdasd@asd.com")
                .build();
    }
    
    ...
    @Override
    public void run(ApplicationArguments args) throws Exception {
        final RestTemplate restTemplate = restTemplateBuilder.build();
        final String URL = "http://localhost:8080/members";
        final String result = restTemplate.getForObject(URL, String.class);
        System.out.println(result); //{"name":"name","email":"asdasd@asd.com","age":10,"address":"address"}
    }
```
* RestTemplate 클래스를 메서드를 이요해서 REST 서비스를 엑세스해서 그 결과를 print로 출력한 코드입니다.
* `getContentAsString()` 메서드 호출 결과로 받은 응답은 stirng contentAsString 변수에 할당됩니다.
* JSON을 문자열을 데이터 추출하는 조작은 비효율적이고 실수를 하기 좋은 구조입니다.

### 매개변수화한 URL에서 데이터 가져오기
```java
    @Override
    public void run(ApplicationArguments args) throws Exception {
        final RestTemplate restTemplate = restTemplateBuilder.build();
        Map<String, String> params = new HashMap<>();
        params.put("memberId", "1");

        final String URL = "http://localhost:8080/members/{memberId}";
        final String result = restTemplate.getForObject(URL, String.class, params);
        System.out.println(result); // {"name":"name","email":"asdasd@asd.com","age":10,"address":"address"}
    }
```
* `http://localhost:8080/members/{memberId}` 처럼 URL 자체를 매개변수화 해서 바인딩 시킬 수 있습니다.
* `http://localhost:8080/members/1` 가 실제 호출되는 URL 주소
* 
### 데이터를 매핑된 객체로 가져오기

```java
    @Override
    public void run(ApplicationArguments args) {
        final RestTemplate restTemplate = restTemplateBuilder.build();
        final String URL = "http://localhost:8080/members";
        final Member member = restTemplate.getForObject(URL, Member.class);
        System.out.println(member.toString()); // Member(name=name, email=asdasd@asd.com, age=10, address=address)
    }

```
* 리턴 타입을 인자로 넘긴 클래스타입으로 받을 수 있음 Member.class
* 캡슐화 안전성 등등 해당 방법이 가장 좋다고 생각

### RestTemplateBuilder 사용법

```java
@Component
public class RestTemplateFactory {
    @Autowired
    private RestTemplateBuilder restTemplateBuilder;

    @Bean
    public RestTemplate restTemplate() {
        return restTemplateBuilder
                .additionalInterceptors(new CustomClientHttpRequestInterceptor())
                .errorHandler(new CustomResponseErrorHandler())
                .setConnectTimeout(3000)
                .build();
    }
}
```
* additionalInterceptors: Http Request 에대한 로깅 처리
* errorHandler : Http Request 에러 핸들링 처리
* setConnectTimeout : Http connection Timeout 설정

```java
@Slf4j
public class CustomClientHttpRequestInterceptor implements ClientHttpRequestInterceptor {
    
    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {
        logRequestDetails(request, body);
        return execution.execute(request, body);
    }

    private void logRequestDetails(HttpRequest request, byte[] body) {
        log.info("================");
        log.info("Headers: {}", request.getHeaders()); 
        log.info("Request Method: {}", request.getMethod());
        log.info("Request URI: {}", request.getURI());
        log.info("Request body: {}", new String(body, StandardCharsets.UTF_8));
        log.info("================");
    }
}
```
```
 Headers: {Accept=[application/json, application/json, application/*+json, application/*+json], Content-Type=[application/json;charset=UTF-8],
 Request Method: POST
 Request URI: http://localhost:8080/members
 Request body: {"name":null,"email":null,"age":10,"address":null}
```
```java
@Slf4j
public class CustomResponseErrorHandler implements ResponseErrorHandler {

    @Override
    public boolean hasError(ClientHttpResponse response) throws IOException {
        final HttpStatus statusCode = response.getStatusCode();
        return !statusCode.is2xxSuccessful();
    }

    @Override
    public void handleError(ClientHttpResponse response) throws IOException {
        final String error = getErrorAsString(response);

        log.error("================");
        log.error("Headers: {}", response.getHeaders());
        log.error("Response Status : {}", response.getRawStatusCode());
        log.error("Request body: {}", error);
        log.error("================");

        throw new RestClientException(error);
    }

    private String getErrorAsString(ClientHttpResponse response) throws IOException {
        final InputStream is = response.getBody();
        final Reader reader = new InputStreamReader(is);
        final BufferedReader bufferedReader = new BufferedReader(reader);
        final String error = bufferedReader.readLine();

        is.close();
        reader.close();
        bufferedReader.close();
        return error;
    }
}
```

```
Headers: {Content-Type=[application/json;charset=UTF-8], Transfer-Encoding=[chunked], Date=[Fri, 05 Oct 2018 16:44:21 GMT], Connection=[close]}
Response Status : 400
Request body: {
  "timestamp": "2018-10-05T16:44:21.354+0000",
  "status": 400,
  "error": "Bad Request",
  "errors": [
    ..
      "defaultMessage": "반드시 값이 존재하고 길이 혹은 크기가 0보다 커야 합니다.",
      "objectName": "member",
      "field": "name",
    },
    ...
  ],
  "message": "Validation failed for object='member'. Error count: 2",
  "path": "/members"
}
```



# [레시피 4-4] RSS/아톰 피드 발행하기

## 과제
스프링 애플리케이션에서 RSS/아톰 피드를 발행하세요

## 해결책
* 자바 오픈소스 프레임워크 ROME 사용 

## 풀이
* RSS/아톰 피드로 발행할 정보를 결정

```java
@Controller
public class FeedController {
    @RequestMapping("/atomfeed")
    public String getAtomFeed(Model model) {
        List<TournamentContent> tournamentList = new ArrayList<>();
        tournamentList.add(TournamentContent.of("ATP", new Date(), "Australian Open", "www.australianopen.com"));
        tournamentList.add(TournamentContent.of("ATP", new Date(), "Roland Garros", "www.rolandgarros.com"));
        tournamentList.add(TournamentContent.of("ATP", new Date(), "Wimbledon", "www.wimbledon.org"));
        tournamentList.add(TournamentContent.of("ATP", new Date(), "US Open", "www.usopen.org"));
        model.addAttribute("feedContent", tournamentList);

        return "atomfeedtemplate";
    }

    @RequestMapping("/rssfeed")
    public String getRSSFeed(Model model) {
        List<TournamentContent> tournamentList;
        tournamentList = new ArrayList<>();
        tournamentList.add(TournamentContent.of("FIFA", new Date(), "World Cup", "www.fifa.com/worldcup/"));
        tournamentList.add(TournamentContent.of("FIFA", new Date(), "U-20 World Cup", "www.fifa.com/u20worldcup/"));
        tournamentList.add(TournamentContent.of("FIFA", new Date(), "U-17 World Cup", "www.fifa.com/u17worldcup/"));
        tournamentList.add(TournamentContent.of("FIFA", new Date(), "Confederations Cup", "www.fifa.com/confederationscup/"));
        model.addAttribute("feedContent", tournamentList);

        return "rssfeedtemplate";
    }
}

```
* http//[호스트명]/[어플리케이션명]/atomfeed 형식의 URI를 getAtomFeed 매핑
* http//[호스트명]/[어플리케이션명]/rssfeed 형식의 URI를 getRSSFeed 매핑
* TournamentContent는 POJO 객체, 해당 뷰의 값

```java
@Configuration
@EnableWebMvc
public class CourtRestConfiguration {

    @Bean
    public AtomFeedView atomfeedtemplate() {
        return new AtomFeedView();
    }

    @Bean
    public RSSFeedView rssfeedtemplate() {
        return new RSSFeedView();
    }
}
```
* 해당 Bean 등록

```java
public class AtomFeedView extends AbstractAtomFeedView {

    @Override
    protected void buildFeedMetadata(Map<String, Object> model, Feed feed, HttpServletRequest request) {
        feed.setId("tag:tennis.org");
        feed.setTitle("Grand Slam Tournaments");

        @SuppressWarnings({"unchecked"})
        List<TournamentContent> tournamentList = (List<TournamentContent>) model.get("feedContent");

        feed.setUpdated(tournamentList.stream().map(TournamentContent::getPublicationDate).sorted().findFirst().orElse(null));

    }

    @Override
    protected List<Entry> buildFeedEntries(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response)
        throws Exception {
        @SuppressWarnings({"unchecked"})
        List<TournamentContent> tournamentList = (List<TournamentContent>) model.get("feedContent");
        return tournamentList.stream().map(this::toEntry).collect(Collectors.toList());
    }
    ...
}
```
* `buildFeedMetadata()` 메서드는 피드 데이터가 담긴 Map 객체, 피드를 처리하는데 필요한 ROME의 Feed 객체, HTTP 요청을 다루어야할 때 필요한 HttpServletRequest을 받습니다.
* `buildFeedEntries()` 메서드는 Map 객체에 접근해서 호출부가 할당한 feddcontent 객체를 꺼내옴
* `Entity` 객체 List 기반으로 루프를 돌려 설정을 완료

# [레시피 5-4] 웹소켓

## 과제
서버/클라이언트가 웹에서 양뱡향 통신을 하는 방안을 강구하세요

## 해결책
HTTP와 달리 전이중 통신이 가능한 웹소켓을 이용하면 서버/클라이언트가 서로 앙뱡향 통신을 할 수있습니다.

## 풀이
* 웹소켓에서 HTTP 는 처음 핸드세이크를 할 때만 쓰이고 이후에는 접속 프로토콜이 일반 HTTP -> TCP 소켓으로 변경 됩니다.

### 웹소켓 
```java
@Configuration
@EnableWebSocket
public class WebSocketConfiguration implements WebSocketConfigurer {}
```
* 구성 클래스에 `@EnableWebSocket`만 붙이면 웹소켓 기능을 사용할 수있습니다.

```java
@Bean
public ServletServerContainerFactoryBean configureWebSocketContainer() {
    ServletServerContainerFactoryBean factory = ServletServerContainerFactoryBean();
    
    factory.setMaxBinaryMessageFufferSize(1384);
    factory.setMaxTextMessageBufferSize(1384);
    factory.setMaxSessionIdleTimeout(TimeUinit.MINUTES.convert(30, TimeUnit.MILLESECOUNDS));
    
    return factory;
}
```
* 텍스트 크기 버퍼 및 바이너리 크기 비동기 전송 타입 아웃 시간, 비동기 세션 타임아웃 시간을 설정합니다.


### WebSocketHandler 작성하기

```java
public class EchoHandler extends TextWebSocketHandler {

    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        session.sendMessage(new TextMessage("CONNECTION ESTABLISHED"));
    }

    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        session.sendMessage(new TextMessage("CONNECTION CLOSED"));
    }

    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        String msg = message.getPayload();
        session.sendMessage(new TextMessage("RECEIVED: " + msg));
    }
}
```
* 접속이 체결되면 TextMessage를 클라이언트에 돌려 돌려보내 알립니다.
* TextMeesage가 수신되면 페이로드를 꺼내 그 앞에 `RECEIVED:`를 붙여 클라이언트에게 회송합니다.
  
```java
@Configuration
@EnableWebSocket
public class WebSocketConfiguration implements WebSocketConfigurer {

    @Bean
    public EchoHandler echoHandler() {
        return new EchoHandler();
    }

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(echoHandler(), "/echo")
            .addInterceptors();
    }
}
```
* 위에서 만든 핸들러를 WebSocketConfiguration 인터페이스에서 구현한 `registerWebSocketHandlers()`메서드를 오버라이드 해서 등록합니다.
* `addHandler()` 메서드에 `/echo` URL을 넣어 핸들러를 등록합니다.
* 클라어은트는 `ws://localhost:8080/echo-ws/echo` URL로 웹소켓에 접속 할 수 있습니다.

```javascript
var ws = null;
var url = "ws://localhost:8080/echo-ws/echo";

function setConnected(connected) {
    document.getElementById('connect').disabled = connected;
    document.getElementById('disconnect').disabled = !connected;
    document.getElementById('echo').disabled = !connected;
}

function connect() {
    ws = new WebSocket(url);

    ws.onopen = function () {
        setConnected(true);
    };

    ws.onmessage = function (event) {
        log(event.data);
    };

    ws.onclose = function (event) {
        setConnected(false);
        log('Info: Closing Connection.');
    };
}

function disconnect() {
    if (ws != null) {
        ws.close();
        ws = null;
    }
    setConnected(false);
}
function echo() {
    if (ws != null) {
        var message = document.getElementById('message').value;
        log('Sent: ' + message);
        ws.send(message);
    } else {
        alert('connection not established, please connect.');
    }
}

function log(message) {
    var console = document.getElementById('logging');
    var p = document.createElement('p');
    p.appendChild(document.createTextNode(message));
    console.appendChild(p);
    while (console.childNodes.length > 12) {
        console.removeChild(console.firstChild);
    }
    console.scrollTop = console.scrollHeight;
}
```
* Connect 이벤트를 통해 `ws://localhost:8080/echo-ws/echo` URL로 접속해 처음으로 웹소켓을 엽니다.
* WebSocket를 사용해 메시지, 이벤트를 리스능할 수있습니다.

# [레시피 5-5] 스프링 웹플럭스로 리액티브 애플리케이션 개발하기

## 과제
스프링 웹플러스의 기본 개념과 구성 방법을 이해하고 간단한 리액티브 웹 애플리케이샨을 개발하세요


## 해결책


```java
public class Reservation {

    private String courtName;
    private LocalDate date;
    private int hour;
    private Player player;
    private SportType sportType;

    //getter, setter...

```

```java
@Service
public class InMemoryReservationService implements ReservationService {
    ...
    @Override
    public Flux<Reservation> query(String courtName) {
        if (courtName != null) {
            return findAll()
                    .filter(r -> r.getCourtName().startsWith(courtName));
        }
        return Flux.empty();
    }
}
```
* 리턴 자료형을 Flux으로 변경 

```java
@Configuration
@EnableWebFlux
@ComponentScan
public class WebFluxConfiguration implements WebFluxConfigurer {...}
```
* `@EnableWebFlux` 어노테이션으로 리액티브 처리 기능을 활성화 합니다.

### 스프링 웹플러스 컨트롤러 작성하기

```java
@Controller
@AllArgsConstructor
public class SampleController {
    private final ReservationService reservationService;

    @GetMapping("reservationQuery")
    public void setupForm() {
    }

    @PostMapping("reservationQuery")
    public String sumbitForm(ServerWebExchange serverWebExchange, Model model) {

        Flux<Reservation> reservations = serverWebExchange.getFormData()
                .map(form -> form.get("courtName"))
                .flatMapMany(Flux::fromIterable)
                .concatMap(courtName -> reservationService.query(courtName));

        model.addAttribute("reservations", reservations);
        return "reservationQuery";
    }
}
```
* `void setupForm()` 컨트롤러는 뷰 페이지
* `String sumbitForm()` 컨트롤러는 @PostMapping 
    * serverWebExchange 매게변수는 요청 변수 courtName을 추출하려고 선언한 객체입니다. `reservationQuery?courtName=<변수>`
    * MVC 컨트로러에서는 `@RequestParam` 어노테이이션으로 가능하지만 스프링 웹플럭스에서는 폼 데이터를 구성하는 매개변수를 가져올 수 없고 URL에 포함된 메개변수값만 얻을 수 있습니다.

### 타임피르 뷰 작성하기

```java
@Bean
public SpringResourceTemplateResolver thymeleafTemplateResolver() {
    final SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver();
    resolver.setPrefix("classpath:/templates/");
    resolver.setSuffix(".html");
    resolver.setTemplateMode(TemplateMode.HTML);
    return resolver;
}

@Bean
public ISpringWebFluxTemplateEngine thymeleafTemplateEngine(){
    final SpringWebFluxTemplateEngine templateEngine = new SpringWebFluxTemplateEngine();
    templateEngine.addDialect(new Java8TimeDialect());
    templateEngine.setTemplateResolver(thymeleafTemplateResolver());
    return templateEngine;
}


@Bean
public ThymeleafReactiveViewResolver thymeleafReactiveViewResolver() {

    final ThymeleafReactiveViewResolver viewResolver = new ThymeleafReactiveViewResolver();
    viewResolver.setTemplateEngine(thymeleafTemplateEngine());
    viewResolver.setResponseMaxChunkSizeBytes(16384);
    return viewResolver;
}

@Override
public void configureViewResolvers(ViewResolverRegistry registry) {
    registry.viewResolver(thymeleafReactiveViewResolver());
}
```
* 템플릿을 실제 HTML로 변환함으로 ISpringWebFluxTemplateEngine 빈을 구성
* 타임리프 템플릿은 템플릿 리졸버가 해석해야되기 때문에 리졸버에 타임리프 등록

# 레시피 [5-6] 리액티브 컨트롤러로 폼 처리하기

## 과제
폼 컨트롤러는 유저에 폼을 보여주고 유저가 제출한 폼을 처리하는 일을 담당합니다.

## 해결책

* HTTP GET 요청 하면 초기 폼 뷰를 유저에게 반한 한다.
* HTTP POST 전송하면 유저가 입력한 데이터를 검증한 다음 정해진 처리를 담당한다. 폼이 정상 처리되면 성공뷰를, 도중 실패하면 에러 메시지가 담딘 폼뷰를 유저에게 돌려준다.

## 풀이

### 폼 뷰작성하기

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Reservation Form</title>
    <style>
        .error {
            color: #ff0000;
            font-weight: bold;
        }
    </style>
</head>

<body>
<form method="post" th:object="${reservation}">

    <table>
        <tr>
            <td>Court Name</td>
            <td><input type="text" th:field="*{courtName}" required/></td>
            <td><span class="error" th:if="${#fields.hasErrors('courtName')}" th:errors="*{courtName}"></span></td>
        </tr>
        <tr>
            <td>Date</td>
            <td><input type="date" th:field="*{date}" required/></td>
            <td><span class="error" th:if="${#fields.hasErrors('date')}" th:errors="*{date}"></span></td>
        </tr>
        <tr>
            <td>Hour</td>
            <td><input type="number" min="8" max="22" th:field="*{hour}"/></td>
            <td><span class="error" th:if="${#fields.hasErrors('hour')}" th:errors="*{hour}"></span></td>
        </tr>
        <tr>
            <td>Player Name</td>
            <td><input type="text" th:field="*{player.name}" required/></td>
            <td><span class="error" th:if="${#fields.hasErrors('player.name')}" th:errors="*{player.name}"></span></td>
        </tr>
        <tr>
            <td>Player Phone</td>
            <td><input type="text" th:field="*{player.phone}" required/></td>
            <td><span class="error" th:if="${#fields.hasErrors('player.phone')}" th:errors="*{player.phone}"></span>
            </td>
        </tr>
        <tr>
            <td>Sport Type</td>
            <td>
                <select th:field="*{sportType}">
                    <option th:each="sportType : ${sportTypes}" th:value="${sportType.id}" th:text="${sportType.name}"/>
                </select>
            </td>
            <td><span class="error" th:if="${#fields.hasErrors('sportType')}" th:errors="*{sportType}"></span></td>
        </tr>
        <tr>
            <td colspan="3"><input type="submit"/></td>
        </tr>
    </table>

</form>
</body>
</html>
```

### 폼 처리 서비스 작성하기
```java
@Service
public class InMemoryReservationService implements ReservationService {
    ...

    @Override
    public Mono<Reservation> make(Reservation reservation) {

        long cnt = reservations.stream()
                .filter(made -> Objects.equals(made.getCourtName(), reservation.getCourtName()))
                .filter(made -> Objects.equals(made.getDate(), reservation.getDate()))
                .filter(made -> made.getHour() == reservation.getHour())
                .count();

        if (cnt > 0) {
            return Mono.error(new ReservationNotAvailableException(reservation
                    .getCourtName(), reservation.getDate(), reservation
                    .getHour()));
        } else {
            reservations.add(reservation);
            return Mono.just(reservation);
        }
    }
```
* 예약 내역을 조회하는 기능을 make()의 메서드입니다.
* 중복 예약건이 있으면 `Mono.error()` 메서드를 통해 `ReservationNotAvailableException` 예외를 발생시킵니다.


### 폼 컨트롤러 작성하기
```java
@PostMapping
    public String submitForm(@Validated @ModelAttribute("reservation") Reservation reservation, BindingResult result) {
        reservationService.make(reservation);
        return "redirect:reservationSuccess";
    }
```
* `submitForm()` 메서드의는 위에서 작성한 `make()` 메서드를 통해 Reservation 객체를 추가하 합니다.
  

### 폼데이터 검증하기

```java
@Component
public class ReservationValidator implements Validator {
    @Override
    public boolean supports(Class<?> clazz) {
       return Reservation.class.isAssignableFrom(clazz);
    }

    @Override
    public void validate(@Nullable Object target, Errors errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "courtName",
                "required.courtName", "Court name is required.");
        ValidationUtils.rejectIfEmpty(errors, "date",
                "required.date", "Date is required.");
        ValidationUtils.rejectIfEmpty(errors, "hour",
                "required.hour", "Hour is required.");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "player.name",
                "required.playerName", "Player name is required.");
        ValidationUtils.rejectIfEmpty(errors, "sportType",
                "required.sportType", "Sport type is required.");

        Reservation reservation = (Reservation) target;
        LocalDate date = reservation.getDate();
        int hour = reservation.getHour();
        if (date != null) {
            if (date.getDayOfWeek() == DayOfWeek.SUNDAY) {
                if (hour < 8 || hour > 22) {
                    errors.reject("invalid.holidayHour", "Invalid holiday hour.");
                }
            } else {
                if (hour < 9 || hour > 21) {
                    errors.reject("invalid.weekdayHour", "Invalid weekday hour.");
                }
            }
        }

    }
}
```
* 폼을 처리하기 전에 유저가 입력한 데이터를 검증하는 과정 입니다.
* 스프링 웹플럭스에서도 스프링 MVC 처럼 Validator  인터페이스를 구현한 검증 객체가 이 일을 감당합니다.
* 필숫 값 존재 여부는 `ValidationUtils` 클래스의 `rejectIfEmpty()` 메서드를 통해서 이루어집니다.
* 두 번째 인수는 프로퍼티명, 세 번째, 네 번쨰 인수는 각각 에러 코드 및 에기본 에러 메시지입니다.
  
```java
@PostMapping리
public String submitForm(@Validated @ModelAttribute("reservation") Reservation reservation, BindingResult result) {
    if (result.hasErrors()) {
        return "reservationForm";
    } else {
        reservationService.make(reservation);
        return "redirect:reservationSuccess";
    }
}
```
* `@Validated` 어노테이션으로 검증을 위에서 등록한 폼 검증을 진행합니다.
* `result.hasErrors()` 메서드를 통해 폼 검증 실패 유무를 boolean 타입으로 리턴 받습니다.
