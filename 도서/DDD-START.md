<p align="center">
  <img src="http://image.kyobobook.co.kr/images/book/xlarge/446/x9788993827446.jpg">
</p>

# 목차
<!-- TOC -->

- [목차](#목차)
- [1장 도메인 모델 시작](#1장-도메인-모델-시작)
    - [도메인 모델 패턴](#도메인-모델-패턴)
- [2장 아키텍처 개요](#2장-아키텍처-개요)
    - [네 개의 영역](#네-개의-영역)
    - [계층 구조 아키텍처](#계층-구조-아키텍처)
    - [DIP](#dip)
        - [DIP 주의사항](#dip-주의사항)
        - [DIP와 아키텍처](#dip와-아키텍처)
    - [도메인 영역의 주요 구성요소](#도메인-영역의-주요-구성요소)
        - [엔티티와 벨류](#엔티티와-벨류)
        - [애그리거트](#애그리거트)
        - [리포지터리](#리포지터리)
- [3장 애그리거트](#3장-애그리거트)
    - [애그리거트 루트](#애그리거트-루트)
    - [도메인 규칙과 일관성](#도메인-규칙과-일관성)
    - [트랜잭션 범위](#트랜잭션-범위)
    - [ID를 이용한 애그리거트 참조](#id를-이용한-애그리거트-참조)
        - [편한 탐색 오용](#편한-탐색-오용)
        - [선능에 대한 고민](#선능에-대한-고민)
        - [확장 어려움](#확장-어려움)
- [4장 리포지터리와 모델구현(JPA 중심)](#4장-리포지터리와-모델구현jpa-중심)
    - [매핑 구현](#매핑-구현)
        - [엔티티와 벨류 기본 매핑 구현](#엔티티와-벨류-기본-매핑-구현)
    - [필드 접근 방식 사용](#필드-접근-방식-사용)
    - [기본 생성자](#기본-생성자)
    - [별도 테이블에 저장하는 벨류 매핑](#별도-테이블에-저장하는-벨류-매핑)

<!-- /TOC -->

# 1장 도메인 모델 시작

## 도메인 모델 패턴
| 계층          | 설명                                                                               |
| ----------- | -------------------------------------------------------------------------------- |
| 사용자인터페이스 UI | 사용자의 요청을 처리하고 사용자에게 정보를 보여준다. 여기서 사용자는 소프트웨어를 사용하는 사람뿐만 아니라 외부 시스템도 사용자가 돌 수 있다. |
| 응용          | 사용자가 요청한 기능을 실행한다. 업무 로직을 직접 구현핮 않으며 도메인 계층을 조합해서 기능을 실행한다.                      |
| 도메인         | 시스템이 제공할 도메인의 규칙을 구현한다.                                                          |
| 인프라스트럭처     | 데이터베이스나 메시징 시스템과 같은 외부 시스템과 연동을 처리한다.                                            |

**핵심 규칙을 구현한 코드는 도메인 모델에만 위치하기 때문에 규칙이 바꾸거나 규칙을 확장해야 할 때 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반영할 수 있게 된다.**


# 2장 아키텍처 개요

## 네 개의 영역 

```java
public class CancelOrderService {
    public void cancelOrder(String orderId){
        Order order = findOrderById(orderId);
        if(order == null) throw new OrderNotFoundExcepton(orderId);
        order.cancel();
    }
}
```
응용 서비스는 로직을 직접 수행하깁보다는 도메인 모델에 로직수행을 위임한다. 위코드도 주문 취소 로직을 집적 구혀하지 않고 Order 객체에 취소 처리를 위임하고있다.

도메인 영역은 도메인 모델을 구현한다. 도메인 모델은 도메인의 핵심 로직을 구현한다. 주문 도메인의 경우 배송지 변경, 결제 완료, 주문 총액 계산과 같은 핵심 로직을 도메인 모델에서 구현한다.

인프라스트럭처 여역은 구현 기술에 대한 것을 다룬다. RDBMS 연동, 메시징 큐에 메시지 전송, 외부 API 호출 등을 처리한다. 인프라스트럭처 영역은 논리적인 개념 표현하기보다는 실제 구현을 다룬다.

## 계층 구조 아키텍처

```
[표현]
  ↓
[응용]
  ↓
[도메인]
  ↓
[인프라스트럭처]
```
**계층 구조는 특정상 상위 계층에서 하위 계층으로 의존만 존재하고 하위 계층은 상위 계층에 의존하지 앟는다.** 예를 들어 표현 계층은 응용 계층에 의존하고 응용 계층은 도메인 계층에 의존하지만, 반대로 인프라스트럭처 계층이 도메인 계층에 의존하거나 도메인 응용 계층에 의존하지는 않는다.

하지만 구현의 편리함을위해 계층 구조를 유연하게 적용한다. 예를들어, 응용 계층은 바로 아래 계층인 도메인 계층의 의존하지만 외부 시스템과의 연동을 위해 더 아래 계층인 인프라스트럭처 게층에 의존하기도 한다.

## DIP

고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다. 그런데, 고수준 모듈이 저수준 모듈을 사용하면 구현 변경과 테스트하기가 어려운 문제가 발생한다

**DIP는 이 문제를 해결 하기위해 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다. 고수준 모듈을 구현하려면 저수주 모듈을 사용해야 하는데, 반대로 저수준 모듈이 고수준 모듈에 의존하도록 추상화 인터페이스를 추가 해야한다.**

### DIP 주의사항
DIP의 핵심은 고소준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함인데 DIP를 적용한 결과 구조만 보고 저수준 모듈에서 인터페이스를 수출하는 경우가 있다.

DIP를 적용할 때 하위 기능을 추상화한 인터페이스는 고수준 모듈 관점에서 도출한다. 예를 들어 DiscountService 입장에서 봤을 때 할인 금액을 구하기 위해 룰 엔진을 사용하는지, 직접 연사하는지 여부는 중요하지 않다. 단지 규칙에 따라 할인금액을 계산한다는 것이 중요할 뿐이다. **즉 할인 금액 계산을 추상화한 인터페이스는 저수준 모듈이 아닌 고수준 모듈에 위치한다.**

### DIP와 아키텍처
응용 계층과 인프라스트럭처 계층을 인터페이스를 두고 DIP를 적용하면 변경에 유용하다.

## 도메인 영역의 주요 구성요소
| 요소      | 설명                                                                                                                                                      |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 엔티티     | 고유의 식별자를 갖는 객체로 자신의 라이프사이클을 갖는다. 주문, 회원, 상품과 같이 도메인의 고유한 개념을 표현한다. 도메인의 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 함꼐 제공한다.                                          |
| 벨류      | 고유의 식별자를 갖지 않은 객체로 주로 개념적으로 하나의 도메인의 객체의 속성을 표현할 때 사용 한다. 배송지 주소를 표현하기 위해 주소, 구매 금액을 금액과 같은 타입이 벨류 타입이다. 엔티티의 속성으로 사용될 뿐만 아니라 다른 벨류 타입의 속성으로도 사용될 수 있다. |
| 애그리거트   | 애그리거트는 관련된 엔티리와 벨류 객체를 개념적으로 하나 물ㄲ은 것이다. 예를들어 즈믄과 연관된 Order 엔티티, OrderLine 벨류, Order 벨류 객체를 주문 애그리거트로 묶을수 있다.                                          |
| 리포지터리   | 도메인 모델의 영속성을 처리한다. 예를들어 RDBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능을 제공한다.                                                                                        |
| 도메인 서비스 | 특정 엔티티에 속하지지 않은 도메인 로직을 제공한다.                                                                                                                           |



### 엔티티와 벨류
실제 도메인 모델의 엔티티와 DB 관계형 모델의 엔티티는 같지 않다.

이 두 모델의 가장큰 차이점은 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 함께 제공한다는 점이다. 예를 들어 주문을 표현하는 엔티티는 주문과 관련된 데이터뿐만 아니라 배송지 주소 변경을 위한 기능을 함께 제공한다.

**도메인 모델의 엔틴티는 단순히 데이터를 담고 있는 데이터 구조라기보다는 데이터와 함께 기능을 제공하는 객체이다. 도메인 관점에서 기능을 구현하고 기능을 구현을 캡슐화해서 데이터가 임의로 변경되는 것을 막는다.**

또 다른 차이점은 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나 인 경우 벨류 타입을 이용해서 표현 할 수 있다라는 것이다.

### 애그리거트
도메인이 커질수록 개발할 도메인 모델도 커지면서 많은 엔티티와 벨류가 출현한다. 엔티티와 밸류 개수가 많아지면 많아질수록 모델은 점점 더 복잡해진다. 도메인 모델에서 전체 구조를 이해하는데 도움이 되는 것이 바로 애그리거트이다.

애그리거트는 관련 객체를 하나로 묶는 군집이다. 애그리거트의 대표적인 예가 주문이다. 주문이라는 도메인 개념은 주문, 배송지 정보, 주문자, 주문 목록, 총 결제 금액 하위 모델로 구성되는 데 이 떄 하위 개념을 표현한 모델을 하나로 묶어서 주문이라는 상위 개념으로 표현할 수 있다.

애그리거트를 구현할 떄는 고려할 것이 많다. 애그리거트를 어떻게 구성했느냐에 따라 구현이 복잡해지기도 하고 트랜잭션 범위가 달라지기도 한다. 또한 선택한 구현 기술에 따라 애그리거트 구현에 제약이 생기기도 한다.

### 리포지터리
도메인 객체를 지속적으로 사용하려면 RDMBS, NoSQL 과 같은 물리적인 저장소에 도메인 객체를 보관해야 한다. 이를 위해 도메인 모델이 리포지터리이다. 

# 3장 애그리거트
백 개 이상의 테이블을 한장의 ERD에 모두 표시하면 개별 테이블 간의 관계를 파악하느라 큰 틀에서 데이터 구조를 이해하는 데 어려움을 겪게 되는 것처럼, 도메인 객체 모델이 복잡해지면 개별 구성요소 모델을 이해하게 되고 전박적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워 진다.

복잡한 도메인을 이해하고 관리하기 쉬운 단우로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 바로 애그리거트이다. 2장에에서 설명한 것처럼 애그리거트는 관련된 객체를 하나의 군으로 묶어준다. 수많은 객체를 애그리거트로 묶어서 바로보면 좀 더 상위 수준에서 도메인 모델 간의 관계를 파알 할 수 있다.

**애그리거트는 경계를 갖는다 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. 애그리거트는 독립적 객체 군이며, 각 에그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다.** 예를 들어 주문 애그리거트는 배송지를 변경하거나 주문 상품 개수를 변경하는 등 자기 자신을 관리하지만, 주문 애그리거트에서 회원의 비밀번호를 변경하거나 상품의 가격을 변경하지는 않는다.

**경계를 설정할 떄 기본이 되는 것은 도메인 규칙과 요구사항이다. 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.**

A가 B를 갖는다는 해석으로 요구사항이 있다고 하더라도 이것으 반드시 A와 B가 한 애그리거트에 속한다는 것을 의미하는 것은 아니다.

좋은 예가 상품과 리뷰다. 상품 상세 페이지에 들어가면 상품 상세 정보와 함께 리뷰내용을 보여줘야하는 요구사항이 있다면 Product, Review 엔티티가 한 애그리거트에 속한다고 생각할 수 있다. 하지만 Product, Review는 함께 생성되지 않고 함께 변경되지도 않는다. 게다가 Product와 Review는 함께 생성되지도 함께 변경되지도 않는다. 게다가 Product를 변경하는 주체가 상품 담당자라면 Review를 생성학 변경하는 주체는 고객이다.

## 애그리거트 루트
애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이어서는 안된다. 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가저야한다.

애그리거트 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데 이 책임을 지키는 것이 바로 애그리거트의 루트 엔티티이다.

## 도메인 규칙과 일관성
애그리거트 루트가 단순히 애그리거트에 속한 객체를 포함하는 것으로 끝나는 것은 아니다. 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다. 이를 위해 애그리거트는 루트 애그리거트가 제공해야 할 도메인 기능을 구현한다.

## 트랜잭션 범위
트랜잭션 범위는 작을수록 좋다. DB 테이블을 기준으로 한 트랜잭션이 한 개 테이블을 수정하는 것과 세 개의 테이블을 수정하는 것은 선능에서 차이가 발생한다. 

동일하게 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다. 한 트랜잭션에서 두 개 이상의 애그리거트를 수정함 트랜잭션 충돌이 발생할 가능성이 더 높아지기 때문에 한번에 수정하는 애그리거트 개수가 많아질수록 전체 처리량이 떨어지게 된다.

한 트랜잭션에 한 애그리거트만 수정한다는 것은 애그리거트에서 다른 애그리거트를 변경하지 않는 다는 것을 뜻한다. 한 애그리거트에서 다른 애그리거트를 수정하면 결과적으로 두 개의 애그리거트를 한 트랜잭샨에서 수정하게 되므로 한 애그리거트 내부에서 다른 애그리거트의 상태를 변경하는 기능을 실행하면 안 된다.

## ID를 이용한 애그리거트 참조
한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 다른 애그리거트를 참조한다. 애그리거트의 관리 주체가 애그리거트 루트이므로 애그리거트에서 다른 애그리거트를 참조한다는 것은 애그리거트의 루트를 참조한다는 것과같다.

필드를 이용해서 다른 애그리거트를 직접 참조하는 것은 개발자에게 구현의 편리함을 제공한다. 

```java
order.getOrder().getMember().getId();
```
JPA를 사용하면 @ManyToOne, @OneToOne과 같은 애노테이션을 시용해서 연관된 객체를 로딩하는 기능을 제공하고 있음으로 필드를 이용해서 다른 애그리거트를 쉽게 참조할 수 있다.

하지만 필드를 이용한 애그리거트 참조는 다음의 문제를 야기할 수 있다.
* 편한 탐색 오용
* 선능에 대한 고민
* 확장 어려움

### 편한 탐색 오용
한 애그리거트 내부에서 다른 애그리거트 객체에 접그할 수 있으면 다른 애그리거트의 상태를 쉽게 변경할 수 있게 된다. 트랜잭션 범위에서 언급한 것처럼 애그리거트가 관리하는 범위는 자기 자신으로 한정해야 한다.

트랜잭션 범위에서 말한 것처럼, 한 애그리거트에서 다른 애그리거트의 상태를 변경하는 것은 애그리거트 간의 의존 결합도를 높여서 결과적으로 애그리거트의 변경을 어렵게 만든다.

### 선능에 대한 고민
애그리거트를 직접 참조하면 성능과 관련된 여러 가지 고민을 해야한다는 것이다. JPA를 사용할 경우 참조한 객체를 지연, 즉시 로딩하는 두 가지 방식으로 로딩할 수 있다. 이러한 다양한 경우의 수를 고려해서 연관 매핑 전략을 결정해야한다.

### 확장 어려움
초기에는 단일 서버 DBMS로 서비스를 제공하는 것이 가능하다. 문제는 사용자가 몰리기 시작하면서 발생한다. 사용자가 늘고 트래픽이 증가하면 자연스럽게 부하를 분산하기 위해 도메인 별로 시스템을 분리하기 시작한다. 이런 괒정에서 하위 도메인 마다 서로 다른 DBMS 를 사용할 가능성이 높아진다. 이 과정에서 하위 도메인 마다 서로 다른 DBMS를 사용할 가능성이 높아진다. 심지어 하위도메인 마다 다른 종류의 데이터저장소를 사용하기도한다. 이는 더이상 다른 애그리거트 루트를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없음을 믜미한다.

# 4장 리포지터리와 모델구현(JPA 중심)

## 매핑 구현

### 엔티티와 벨류 기본 매핑 구현
애그리거트와 JPA 매픙을 위한 기본 규칙은 다음과 같다
* 애그리거트 루트 엔티티이므로 @Entity로 매핑 설정한다.
* 한 테이블에 엔티티와 벨류 데이터가 같이 있다면
    * 벨류는 @Embeddable로 매핑 설정한다
    * 벨류 타입 프로머티는 @Embedded로 매핑한다.


## 필드 접근 방식 사용
엔티티에 프로퍼티를 위한 공개 get/set 메서드를 추가하려면 도메인의 의도가 사라지고 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높아진다. **특히 set 메서드는 내부 데이터를 외부에서 변경할 수 있는 수단이 되기 떄문에 캡슐화를 꺠는 원인이 될 수 있다.**

**엔티티가 객체로서 제 역할을 하려면 외부에 set 메서드 대신 의도가 잘 드러나는 기능을 제공해야 한다. 상태 변경을 위한 setState() 메서드 보다 주문 취소를 위한 cancel()메서드가 도메인을 더 잘표현 한다. setShippingInfo() 메서드보다 배송지를 변경한다는 의미를 갖는 changeShippingInfo()가 도메인을 더 잘표현한다.**

벨류 타입을 불변으로 구성하고 싶은 경우 set 메서드 자체가 필요 없는데 JPA의 구현 방식 떄문에 set 메서드를 추가하는 것도 좋지 않다.

## 기본 생성자
엔티티와 벨류의 생성자 객체를 생성할 때 필요한 것은 전달받는다. 분변 타입이면 생성 시점에 필요한 값을 모두 전달받음으로 값을 변경하는 set 메서드를 제공하지 않는다. 그래서 기본 생성자를 재공해주지 않아도 된다. **하지만 JPA @Entity @Embeddable로 클래스를 매핑하려면 기본 생성자를 제공 해야한ㄷ. 하이버네이트와 같은 JPA 프러바이더는 DB에서 데이터를 읽어와 매핑된 객체를 생성할 때 기본 기본 생성자를 사용해서 객체를 생성한다.**

하이버네이트는 클래스를 상속한 프록시 객체를 이용해서 지연 로딩을 구한다. 이 경우 플록시 클래스 상위 클래스의 기본 생성자를 호출할 수 있어야 하므로 지연 로딩 대상이되는 @Entity, @Embeddable의 게본 생성자는 private가 아닌 proteted로 지정해야한다.

## 별도 테이블에 저장하는 벨류 매핑
애그리거트에서 루트 엔티티를 뺀 나머지 구성요스는 대부분 벨류이다. 루트 엔티티 외에 또 다른 엔티티가 있다면 진짜 엔티티인지 의심해봐야한다. 단지 별도 테이블에 데이터를 저장한다고 해서 엔티티인 것은 아니다.

벨류가 아니라 엔티티가 확실하다면 다른 애그리거트는 아닌지 확인헤야한다. 특히 자신만의 독자적인 라이프사이클을 갖는다면 다른 애그리거트일 가능성이 높다. 예를 들어 상품 상세 화면을 보면 상품 자체에 대한 정보와 고객의 리뷰를 함께 보여주는데, 이를 보고 상품 애그리거트에 곡객 리뷰가 포함된다고 생각할 수 있다. 하지만 Product와 Review는 함께 생성되지 않고, 함께 변경되지 않는다. 게다가 변경 주체도 다르다.

**애그리거트에 속한 객체가 벨류인지 엔ㄴ티티인지 구분하는 방법은 고유 식별자를 갖는지 여부를 확인하는 것이다.**

