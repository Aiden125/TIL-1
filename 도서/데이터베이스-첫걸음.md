![http://www.hanbit.co.kr/data/books/B5934047828_l.jpg]!

# 용어정리

## Dirty Write
* 어떤 사람도 문제 없이 파일을 여는 것이 가능하고 나중에 수행된 쪽의 갱신이 반영된다는 경우를 `Dirty Write` 라고 합니다.
* 남보다 늦게 손을 내밀어 이기는 가위바위보 같은 것입니다. 데이터베이스에서 이런 식의 제어는 일반적으로 데이터 무결성 관점에서 기피하는 경향이 있습니다.

# 트랜잭션

## ACID

1. Atomicity 원자성
2. Consistency 일관성
3. Isolation 고립성 또는 격리성
4. Durability 지속성

### Atomicity 원자성
Atomicity 원자성 이란 데디터의 변경을 수반하는 일련의 데이터 조작이 전부 성공할지 전부 실패할지를 보증하는 구조입니다. 

### Consistency 일관성
데이터베이스에는 데이터베이스 오브젝트에 대한 각종 정합성 제약을 추가할 수 있습니다. 이는 이련의 데이터 조작 전후에 그 상태를 유지하는 것을 보증하는, 즉 일관성을 유지하기 위한 구조입니다.

예를 들어 시스템에 사용자를 등록할 때 사용자를 임의로 식별하기 위해 일련번호를 사용자에게 발급합니다. 이때 이 번호 이 번호에 유니크 제약을 설정하면 중복된 사용자 번호를 지정할 수 없습니다.

### Isolation 고립성 또는 격리성
일련의 데이터 조작을 복수 사용자가 동시에 실행해도 각각의 처리가 모순 없이 실행되는 것을 보증한다. 입니다. 

1. 현재 빈 깅글룸의 수를 확인한다. (select)
2. 빈 싱글룸 수에서 1을 빼고 결과를 빈 싱글룸 수로 돌려 쓴다. (update)

이것을 사용자 A, B가 동시에 요청할 경우 문제가 발생합니다.

이런 사태가 발생하는 것을 막기 위해 데이터베이스에는 데이터베이스 오브젝트인 테이블에 대해 Lock을 걸어서 후속 처리 블록 하는 방법이 있습니다.

장금 단위에는 테이블 전체, 블록, 행 등이 있는데 MySQL에서는 트랜잭션 처리를 할 때 주로 행 단위 잠금 기능을 이용합니다.

위 예제로 설명하면 `(1) 현재 빈 깅글룸의 수를 확인한다`을 처리할 때는 `select update` 실행하면 select한 행에 잠금이 걸립니다. 이렇게 되면 후속 처리 해당 잠금이 해제될 때 commit or rollback 까지 대기하게 되며 올바른 처리를 계속할 수 있게 됩니다.



#### Isolation Level

| 격리 수준            | 설명                                                                                                                                |
| ---------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| DEFAULT          | DB 기본 격리 수준을 사용합니다.                                                                                                               |
| READE_UNCOMMITED | 다른 트랜잭션이 아직 커밋하지 않은 값을 한 트랜잭션이 읽을 수 있습니다. 따라서 오염된 읽기, 재현 불가한 읽기, 허상 읽기 문제가 발생할 가능성이 있습니다.                                         |
| READE_COMMITED   | 한 트랜잭션이 다른 트랜잭션이 커밋한 값만 읽을수 있습니다. 이로써 오염된 값 읽기 문제는 해결되지만 재현 불가한 읽기, 허상 읽기 문제는 여전히 남습니다.                                           |
| REPEATABLE_READ  | 트랜잭션이 어떤 필드를 여러번 읽어도 동일한 값을 읽도록 보장합니다. 트랜잭션이 지속되는 동안 다른 트랜잭션이 해당 필드를 변경할수 없습니다. 오렴된 값 읽기, 재현 불가한 읽기 문제는 해결되지만 허상 읽기는 여전히 남습니다.    |
| SERIALIZABLE     | 트랜잭션이 테이블을 여러 번 읽어도 정확히 동일한 로우를 읽도록 보장합니다. 트랜잭션이 지속되는 동안에는 다른 트랜잭션이 해당 테이블에 삽입, 수정, 삭제를 할 수 없습니다. 동시성 문제는 모두 해소괴지만 성능이 현저히 떨어집니다. |


현상 | 설명
---|---
더티 읽기(Dirty Read) | 어떤 트랜잭션이 커밋되기 전에 다른 트랜잭션에서 데이터를 읽는 현상이다. 예를들면 사용자 A가 값을 변경하고 아직 커밋하지 않아도 사용자 B가 변경한ㄴ 후의 값을 읽는 것을 가리킨다.
애매한 읽기/반복 불가능 읽기(Fuzzy/NonRepeatable Read) | 어떤 트랜잭션이 이전에 읽어 들인 데이터를 다시 읽어 들일 때 2회 이후의 결과가 1회 때와 다른 현상이다. 예들들면 최초에 사용자 A가 빈 싱글룸 수 10을릭고 그 후 사용자 B가 값을 9로 변경해 커밋했다고 하자. 계속해서 사용자 A가 SELECT를 다시 실행하면 최초에 SELECT한 결과는 9가 된다. 사용자 A가 최초에 읽은 값 10이 2회 이후에 SELECT에서 보증되지 못하고 애매하게 된다.
팬덤 읽기(Phantom Read) | 어떤 트랜잭션을 읽을 때 선택할 수 있는 데이터가 나타나거나 사라지는 현상이다. 최초에 사용자 A가 범위 검색을 수행 후 3행을 읽었다고 가정 하자. 계속해서 사용자 B가 그 범위에 들어가는 데이터 1행을 INSERT하고 커밋도 실행했다. 계속해서 사용자 A는 다시 같은 SELECT 문을 실행하면 최초에 SELECT 문을 실행하면 최초 SELECT 3행이 아닌 4행이된다. 이처럼 나타거나 사라지는 데이터가 유령과 닮아서 붙여진 이름이다.



### Durability 지속성
지속성은 일련의 데이터 조작을 완료하고 완료 통지를 사용자가 받는 시점에서 그 조작이 영구적이 되어 그 결과를 잃지 않는 것을 나타냅니다.