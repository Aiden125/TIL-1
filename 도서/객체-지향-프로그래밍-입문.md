# 객체지향 프로그래밍 입문
[객체지향 프로그래밍 입문 동영상 강의](https://www.inflearn.com/course/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%85%EB%AC%B8/)

# 목차
- [객체지향 프로그래밍 입문](#%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%85%EB%AC%B8)
- [목차](#%EB%AA%A9%EC%B0%A8)
- [객체](#%EA%B0%9D%EC%B2%B4)
    - [절차 지향](#%EC%A0%88%EC%B0%A8-%EC%A7%80%ED%96%A5)
    - [객체 지향](#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5)
    - [객체란 ?](#%EA%B0%9D%EC%B2%B4%EB%9E%80)
    - [캐슐화](#%EC%BA%90%EC%8A%90%ED%99%94)
    - [캡슐화를 위한 규칙](#%EC%BA%A1%EC%8A%90%ED%99%94%EB%A5%BC-%EC%9C%84%ED%95%9C-%EA%B7%9C%EC%B9%99)
        - [Tell, Don't Ask : 묻지 말고 시켜라](#tell-dont-ask--%EB%AC%BB%EC%A7%80-%EB%A7%90%EA%B3%A0-%EC%8B%9C%EC%BC%9C%EB%9D%BC)
            - [Demeter's Law](#demeters-law)
- [추상화](#%EC%B6%94%EC%83%81%ED%99%94)
    - [다형성](#%EB%8B%A4%ED%98%95%EC%84%B1)
    - [추상화](#%EC%B6%94%EC%83%81%ED%99%94)
        - [추상화는 의존 대상이 변경하는 시점에](#%EC%B6%94%EC%83%81%ED%99%94%EB%8A%94-%EC%9D%98%EC%A1%B4-%EB%8C%80%EC%83%81%EC%9D%B4-%EB%B3%80%EA%B2%BD%ED%95%98%EB%8A%94-%EC%8B%9C%EC%A0%90%EC%97%90)
        - [추상화를 잘 하려면](#%EC%B6%94%EC%83%81%ED%99%94%EB%A5%BC-%EC%9E%98-%ED%95%98%EB%A0%A4%EB%A9%B4)
- [상속보단 조립](#%EC%83%81%EC%86%8D%EB%B3%B4%EB%8B%A8-%EC%A1%B0%EB%A6%BD)
    - [상속과 재사용의 단점](#%EC%83%81%EC%86%8D%EA%B3%BC-%EC%9E%AC%EC%82%AC%EC%9A%A9%EC%9D%98-%EB%8B%A8%EC%A0%90)
        - [상속의 단점 해결은 조립](#%EC%83%81%EC%86%8D%EC%9D%98-%EB%8B%A8%EC%A0%90-%ED%95%B4%EA%B2%B0%EC%9D%80-%EC%A1%B0%EB%A6%BD)
- [기능과 책임 분리](#%EA%B8%B0%EB%8A%A5%EA%B3%BC-%EC%B1%85%EC%9E%84-%EB%B6%84%EB%A6%AC)
    - [큰 클래스, 큰 메서드](#%ED%81%B0-%ED%81%B4%EB%9E%98%EC%8A%A4-%ED%81%B0-%EB%A9%94%EC%84%9C%EB%93%9C)
    - [패턴 적용](#%ED%8C%A8%ED%84%B4-%EC%A0%81%EC%9A%A9)
- [의존과 DI](#%EC%9D%98%EC%A1%B4%EA%B3%BC-di)
    - [의존](#%EC%9D%98%EC%A1%B4)
    - [의존 주입 DI](#%EC%9D%98%EC%A1%B4-%EC%A3%BC%EC%9E%85-di)
- [정리](#%EC%A0%95%EB%A6%AC)
    - [캡슐화](#%EC%BA%A1%EC%8A%90%ED%99%94)
    - [추상화](#%EC%B6%94%EC%83%81%ED%99%94)
    - [상속보단 조립](#%EC%83%81%EC%86%8D%EB%B3%B4%EB%8B%A8-%EC%A1%B0%EB%A6%BD)
    - [의존과 DI](#%EC%9D%98%EC%A1%B4%EA%B3%BC-di)
- [부록](#%EB%B6%80%EB%A1%9D)
    - [DIP](#dip)
        - [고소준 모듈, 저수준 모듈](#%EA%B3%A0%EC%86%8C%EC%A4%80-%EB%AA%A8%EB%93%88-%EC%A0%80%EC%88%98%EC%A4%80-%EB%AA%A8%EB%93%88)
        - [고수준이 저수준에 직접 의존하면](#%EA%B3%A0%EC%88%98%EC%A4%80%EC%9D%B4-%EC%A0%80%EC%88%98%EC%A4%80%EC%97%90-%EC%A7%81%EC%A0%91-%EC%9D%98%EC%A1%B4%ED%95%98%EB%A9%B4)
        - [고수준 관점에서 추상화](#%EA%B3%A0%EC%88%98%EC%A4%80-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EC%B6%94%EC%83%81%ED%99%94)
# 객체


## 절차 지향

![](https://i.imgur.com/8dN2Czy.png)

* 프로시저와 데이터간의 접근이 자유롭다
* 개발 초기단계에서는 편의성이 있지만 시간이 지날수록 프로시저가 어느 데이터에든 접근 할 수있어 캡슐화가 저하되있기 때문에 개발이 어려운 점이 있다.

## 객체 지향

![](https://i.imgur.com/HOKQ2GT.png)

* 처음에는 어려울 수 있음
    * 데이터 프로시저를 알맞게 묶는 것이 어려움
* 하지만 시간이 흘러갈 수록 캡슈화 이점 때문에 큰 장점이 있음

## 객체란 ?

**객체의 핵심 -> 기능 제공**
* 객체는 제공하는 기능으로 정의
    * 내부적으로 가진 필드(데이터로) 정의 하지 않음
    * 데이터(맴버 필드)가 중요하지 않음 기능 으로 정의
    * 해당 기능이 동작할때 맴버 필드 들이 변경 됨

객체와 객체 상호 작용: 메시지를 주고 받는 
* 메서드를 출하는 메시지, 리턴하는 메시지, 입렙션 메시지 **클래스 간의 상호 작용이 메시지라고 정의**

## 캐슐화
* 데이터 + 관련 된 기능 묶기
* 객체 가 기능을 어떻게 구현했는지 외부에 감추는 것(정보은닉)
    * 구현에 사용된 데이터의 상세 내용을 외부에 감춤
* 정보 은닉 의미  포함
    * 최근에는 캡슐화에 정보은닉이라는 개념도 포함시켜 이야기함
    * 즉 캡슐화은 정보 은닉이라는 개념도 포함되 있다.
* 외부에 영향 없이 객체 내부 구현 변경 가능
* **기능의 구현을 외부에 감춤**
* **기능을 사용한 코드에 영향을 주지 않고 내부 규현을 변경할 수 있는 유연함**


## 캡슐화를 위한 규칙 

### Tell, Don't Ask : 묻지 말고 시켜라

```java
// 묻고 있다.
if(acc.getMemberShip() == REGUAR) {...}

if (acc.hasRegularPermission()){...}
```

#### Demeter's Law
* 메서드에서 생성한 객체의 메서드만 호출
* 파라미터로 받은 객체의 메서드만 호출
* 필드로 참조하는 객체의 메서드만 호출

```java
acc.getExpDate().isAfter(now) // 안티
acc.isExpired(now) // 적절
```

# 추상화

## 다형성

* 다형성 : 여러 모습을 갖는 것
* 객체 지향에서는 한 객체가 여러 타입을 갖는 것
    * 즉 한 객체가 여러 타입의 기능을 제공
    * 타입 상속으로 다형성 구현

## 추상화
* 데이터나 프로세스 등을 의미가 비슷한 개념이나 의미 있는 표현으로 정의하는 과정
* 두 가지 방식의 추상화
    * 특성한 성질, 공통 설징(일반회)
* 간단한 예
    * DB의 User 테이블 : 아이디, 이름, 이메일
    * Money 클래스 : 통화, 금액
    * 프린터 : HP MXXXX, 삼성 SL-M2XXX
    * GPU: 지포스, 라데온

### 추상화는 의존 대상이 변경하는 시점에
* 추상화 -> 추상 타입 증가 -> 복잡도 증가
    * 아직 존재하지 않은 기능에 대한 이른 추상화는 주의 : 잘못된 추상화 가능성, 복잡도만 증가
    * 실제 변경, 확장이 발생 할때 추상화

### 추상화를 잘 하려면
* 구현을 한 이유가 무엇 때문인지 생각해야함

# 상속보단 조립

## 상속과 재사용의 단점
* 상위 클래스 변경 어려움
    * 상위 클래스의 변경시 하위 클래스가 비 정상적으로 동작할 가능성이 높음
    * 상위 클래스 입장에서는 어느 하위 클래스가 추가될지 알 수가 없음
    * 하위 클래스는 상위 클래스의 동작 방법에 어느정도는 알아야함
        * 상위 클래스는 하위 클래스에 대해 캡슐화가 약해지게 됨
* 클래스 증가
    *  새로운 조합이 생길때마다 새로은 클래스가 생김
    *  새로운 조합이 생길때 어느 클래스를 상속 받아야 할지 어려움
* 상속 오용
    * 상위 클래스의 메소드를 호출할 가능성이 있음
        * 상위 클래스의 메소드를 호출하게 되어 생각지 못하게 동작하게됨
        * 이는 실수하기 너무 좋은 구조
### 상속의 단점 해결은 조립
* 조립
    * 여러 갹체를 묶어서 더 복잡한 기능을 제공
    * 보통 필드로 다른 객체를 참조하는 방시긍로 조립 또는 객체를 필요 시점에 생성 / 구함
    * 조립을 통한 기능 재사용
        * 단순 재사용의 목적으로 상속을 하는 것은 상속의 오용
    * 상속하기 위해 앞서 조립으로 풀 수 없는 지 검토
    * 진짜 하위 타입인 경우에만 상속허용


# 기능과 책임 분리
* 기능 분해
    * 기능은 하위 기능으로 분해

* 기능을 누가 제공할것인가 ?
    * **기능은 곧 책임**
    * 분리한 각 기능을 알맞게 분배

## 큰 클래스, 큰 메서드
* 클래스나 메서드가 커지면 전차 지향의 문제 발생
    * 큰 클래스 -> 많은 필드를 많은 메서드가 공유
    * 큰 메서드 -> 많은 변수를 많은 코드가 공유
    * 여러 기능이 한 클래스 / 메서드에 썩여 있을 가능성
* 책임에 따라 알맞게 코드 분리

## 패턴 적용
* 전형적인 역할 분리
    * 간단한 웹
        * 컨트롤러, 서비스, DAO
    * 복잡한 도메인
        * 엔티티, 베류, 레포지토리, 도메인 서비스
    * AOP
        * 공통 기능
    * GoF
        * 팩토리, 빌더, 전략, 템플릿 메서드, 프록시/데코레이터 등

# 의존과 DI

## 의존
* 기능 구현을 위해 다른 구성 요소를 사용하는 것
    * 의존의 예: 객체 생성, 메서드 호출, 데이터 사용
* 의존은 변경이 전파될 가능성을 의미
    * 의존하는 대상이 바뀌면 바뀔 가능성이 높아짐
    * ex) 호출하는 메서드의 파라미터가 변경
    * ex) 호출하는 메서드가 발생할 수 있는 입셉션 타입이 추가
* 순한 의존
    * 변경 연쇄 전파 가능성
    * 클래스, 패키지, 모듈 등 등 모둔 수준에서 순혼 의존 없도록

## 의존 주입 DI
* 외부에서 의존 갹체를 주입
    * 생성자나 메서드를 이용해서 주입
* DI 장점
    * 상위 타입을 사용할 경우 의존 대상이 바뀌면 조립기 설정만 변경하면됨 
* DI를 습과너럼 사용하기
    * 의존 객체는 주입받도록 코드 작성하는 습관

# 정리
* 소프트웨어의 가치는 변화
    * 적은 비용으로 변화할 수 있는 방법 중 하나 객체 지향
* 객체는 제공하는 기능으로 정의
    * ex) 회원 객체, 암호 변경 기능
* 메서드를 이용해서 기능 명세
    * 이름, 파라미터, 결과로 구성

## 캡슐화
* 내부 구현 감춤
* 내부 구현 변경에 따른 외부 영향을 최소화
* 내부 구현 변경의 유연함

## 추상화
* 여러 구현의 공통점을 상위 타입으로 도출

## 상속보단 조립
* 상속의 단점을 조립하는 방식으로 해소

## 의존과 DI
* DI로 의존 객체 접근
    * 의존 객체 변경이 쉽고 테스트에서 대역 객체 사용 용이

# 부록

## DIP
* 의존 역전 원칙
    * 고수준 모듈은 저수준 모듈의 구현에 의존하면 안 됨
    * 저수준 모듈이 고수준 모듈에 정의한 추상타입에 의존 해야 함
* DIP는 유연함을 높임
    * 고소준 모듈의 변경을 최소하하면서 저수준 모듈의 변경 유연함을 높임



### 고소준 모듈, 저수준 모듈
* 고수준 모듈
    * 의미 있는 단일 기능을 제공
    * 상위 수준의 정책 구현
* 저수준 모듈
    * 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현

### 고수준이 저수준에 직접 의존하면
* 저수준 모듈 변경 -> 고수준 모듈에 영향
    * 고수준 정책이 바꾸지 않았으나 저수준 구현 변경으로 코드 변경 발생

### 고수준 관점에서 추상화
* 고수준 입장에서 저수준 모듈을 추상화
    * 구현 입장에서 추상화 하지 말


