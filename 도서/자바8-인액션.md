![](http://image.kyobobook.co.kr/images/book/xlarge/796/x9788968481796.jpg)


# 목차


# 기초

## 메서드 래퍼런스

자바8에서는 메서드 래퍼런스를 만들어 전달할 수 있게 되었다.

```java
public class FileHidden {

    public void refercenMethod() {
        final File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
            @Override
            public boolean accept(File file) {
                return file.isHidden();
            }
        });
    }
    
    public void refercenMethod2(){
        File[] hiddenFiles = new File(".").listFiles(File::isHidden);
    }
}
```
* 메서드 래퍼런스를 통해서 코드를 심플하게 표현할 수 있다.

## 람다 익명함수


```java
public static boolean isGreenApple(Apple apple) {
        return "green".equals(apple.getColor());
    }

public static boolean isHeavyApple(Apple apple) {
    return apple.getWeight() > 150;
}

public interface Predicate<T> {
    boolean test(T t);
}


public static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {

    final ArrayList<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if (p.test(apple)) {
            result.add(apple);
        }
    }
    return result;
}

@Test
public void test() {
    final List<Apple> apples = new ArrayList<>();
    Apple.filterApples(apples, LambdaSampleCode::isGreenApple);
    Apple.filterApples(apples, LambdaSampleCode::isHeavyApple);
    Apple.filterApples(apples, (Apple a)-> a.getColor().equals("RED"));
}
```
기존에는 메서드를 값으로 전달한다 이런 방식은 유용하지만 각각의 기능들을 만들어야한다. 하지만 자바8에서는 이 문제도 익명함수를 통해(람다함수)간단하게 해결 할 수있다.

한 번만 사용할 메서드는 따로 정의를 구현할 필요가 없이 익명함수를 이용할 수 도 있다. 물론 람다보다는 코드가 수행하는 일을 잘 설명하는 이름을 가진 메섣를 정의하고 위 예제처럼 메서드 레퍼런스를 활용 하는것이 바람직하다. 코드의 명확성이 우선시돠어야 한다.


## 스트림
거의 모든 자바 애플리케이션은 컬렉션들 만들고 활용한다. 하지만 컬렉션으로 모든 문제가 해결되지는 않는다.

```java
public void lambda() {
    Map<Currency, List<Transaction>> transcationByCurrencies = transcations.stream()
    .filtet((Transcation t)-> t.getPrice() > 1000)
    .collect(groupingBy(Transcation::getCurrency));
}
```
코드의양이 심플해지고 람다식이 익숙해지면 더욱 명확해진다.

## 스트림

### 멀티 스레딩은 어렵다.
자바8은 스트림 API로 컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제, 멀티 코어 활용 어려움 이라는 두 가지 문제를 모두 해결했다.

## 디폴트 메서드

# 동작 파라미터화 코드 전덜하기

 동작 파라미터화를 이용하면 자주 바뀌는 요ㅕ구사항에 효과적으로 대응할 수 있다. 동작 파라미터화란 아직 어떻게 실행할 것인지 결정 하지 않은 코드 블록을 의미한다. 이 코드 블록은 나중에 프로그램에서 호출한다. **즉 코드 블럭의 실행은 나중으로 미뤄진다.** 예를 들어 컬렉션을 처리할 때 다음과 같은 메서드들로 구현한다고 가정하자.

* 리스트의 모든 요소에 `어떤 동작`을 수행할 수 있음
* 리스트 관련 작업을 끝낸 다음에 `어떤 다른 동작`을 수행할 수있음
* 에러가 발생하면 `정해진 어떤 다른 동작`을 수행할 수 있음

## 요약
* 동작 파라미터화에서는 메서드 내부적으로 다양한 동작을 수행할 수 있도록 코드를 메서드 인수로 전달한다.
* 동작 파라미터화를 이용하면 변화는 요구사항에 더 잘 대응할 수 있는 코드를 구현할 수 있으며 나중에 엔지니어링 비용을 줄일 수 있다,
* 코드 전달 기법을 이ㅛㅇ하면 동작 메서드의 인수로 전달할 수 있다. 하지만 자바 8 이전에서는 코드를 지저분하게 구현했어야했다. 이런것을 익명 클래스로 어느정도 코드를 깔금하게 제공
  
# 람다 표현식

## 람다란 무엇인가?
람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화 한 것이라고 할 수있다. 람다 표현식에는 이름은 없지만, 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트는 가질 수 있다.

* 익명 : 보통의 메서드와는 달리 이름이 없으므로 **익명**이라는 표현한다. 구현해야 할 코드에 대한 걱정거리가 줄어든다.
* 함수 : 람다는 메서드 처럼 특정 클래스에 족동되지 않으 함수라고 부른다. 하지만 메서드처럼 파라미터 리스트 바디, 변환 형식, 가능한 예외 리스트를 포함한다.
* 전달 : 람다 ㅍ현식을 메서드 인수로 전달하거나 변수로 지정할 수 있다.
* 간결성 : 익명 클래스처럼 많은 자질구레한 코드를 구현할 필요가 없다.

```java
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
```
* 파라미터 리스트 : `(Apple a1, Apple a2)`
* 화살표 : 화살표 (->)는 람다의 파라미터 리스트와 바디를 구분한다.
* 람다의 바디 : `a1.getWeight().compareTo(a2.getWeight());` 람다의 반환값에 해당하는 표현식이다.

## 형식 검사, 형식 추론 제약
람다 표현식 자체에는 람다가 어떤 함수형 인터페이스를 구현하는지의 정보가 포함되어 있지 않다. 따라 람다 표현식 더 제대로 이해하려면 람다의 실제 형식을 파악해야 한다.

### 형식 검사
람다가 사용되는 Context를 이용해서 람다의 Type을 추론할 수 있다. 어떤 Context(예를 들면 람다가 전달될 메서드 파라미터나 람다가 할당되는 변수등)에서 기대되는 람다 표현식으로 형식을 대상 형식 이라고 부른다.

다음 쿼드의 형식 확인 과정을 보여준다. 다음과 같은 순서로 형식 확인 과정이 진행된다.
```java
List<Apple> haavierThan150g = filter(inventory, (Apple e) -> a.getWeight() > 150);
```

1. filter 메서드의 선언을 확인한다.
2. filter 메서드 두 번째 파라미터로 `Predicate<Apple>` 형식(대상 형식)을 기대한다.
3. `Predicate<Apple>`은 test라는 한 개의 추상 메서드를 정의하는 함수형 인터페이스다.
4. `test` 메서드는 `Apple`을 받아 `boolean`을 반환하는 함수 디스크립터를 묘사한다.
5. `filter` 메서드로 전달된 인수는 이와 같은 요구사항을 만족해야 한다.

```
1.람다가 사용된 콘텍스트는 무엇인지 확인하기 위해서 filter의 정의를 확인 한다.  filter(inventory, (Apple e) -> a.getWeight() > 150);

2. 대상 형식은 Predicate<Apple> 이다(T는 Apple로 대치됨) filter(List<Apple> inventory, Predicate<Apple> p)

3. Predicate<Apple> 인터페이스의 추상메서드는 무엇인가? boolean test(Apple apple)

4. Apple을 인수로 받아 boolean을 반환하는 test 메서드다. Apple -> boolean
```

### 같은 람다, 다른 함수형 인터페이스
대상 형식 이라는 특성 때문에 같은 람다 표현식이더라도 호환되는 추상 메서드를 가진 다른 함수형 인터페이스로 사영될 수 있다.

### 지역 변수 사용
람다 표현식에서는 익명 함수가 하는 것처럼 자우 변수를 활용 할 수있다. 이 와 같은 동작을 람다 캡처링이라고 부른다.

```java
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);
```
하지만 자유 변수에도 약간의 제약이 있다. 람다는 인스턴스 변수와 정적 변수를 자유롭게 캡처(자신의 바디에서 참조할 수 있도록) 할 수 있다. **하지만 그러면 지역 변수는 명시적으로 final로 선언된 변수와 똑같이 사용되어야 한다.**

예를 들어 다음 에제는 portNumber에 값을 두 번할당하므로 컴파일할 수 없는 코드다.

```java
int portNumber = 1337;
Runnable r () -> System.out.println(portNumber);
portNumber = 31337;
```

### 지역 변수의 제약
왜 지역 변수에 이런 제약이 필요한지에 대한 설명이다. 우선 내부적으로 인스턴스 변수와 지역 변수는 태생부터가 다르다. 인스턴스 변수는 힙에 저장되는 반면 지역 변수는 스택에 위치한다. 

람다에서 지역 변수에 바로 접근할 수 있다는 가정에 하에 람다가 스레드에서 실행된다면 변수를 할당한 스레드가 사라져서 변수 할당이 해제되었는데도 람다를 실행하는 스레드에서 해당 변수에 접근하려 할 수 있다. 따라사 자바 구현에서 원래 변수에 접근을 허용하는 것이 아니라 자유 지역 변수의 복사본을 제공한다. 따라서 복사본의 값이 바뀌지 않아야 하므로 지역 변수에 한 번만 값을 할당 해야한다는 제약이 생긴 것이다.

또한 지역 변수에 제약 때문에 외부 변수를 변화시키는 일반적인 명령형 프로그래밍 패턴에 제동을 걸 수 있다.

지역 변수 값은 스택에만 존재하므로 자신을 정의한 스레드와 생존을 같이 해야 하며 따라서 지역 변수는 final 이어야 한다. 가변 지역 변수를 새로운 스레드에서 캡처할 수 있다면 안전하지 않은 동작을 수행할 가능성이 생긴다(인스턴스 변수는 스레드가 공유하는 힙에 존재하므로 특별한 제약이 없다)

### 메서드 레퍼런스
메서드 레퍼런스를 이용하면 기존 메서드 정의를 재활용해서 람다처럼 전달할 수 있다. 때로는 람다 표현식보다 메서드 레퍼런스를 사용하는 것이 더 가독성이 좋으며 자연스러울 수 있다. 다음은 메서드 레퍼런스와 새로운 자바 8 API를 활용한 정렬 예제다.

```java
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));

// 메서드 레퍼런스와 Comparator.comparing를 활용한 코드
inventory.sort(comparing(Apple::getWeight)); // 첫 번째 메서드 래퍼런스!
```

### 메서드 레퍼선스를 만드는 방법

1. Static 메서드 레퍼런스
   * Interger의 parseInt 메서드 `Integer::parseInt`로 표현할 수 있다.
2. 다양한 형식의 인스턴스 메서드 레퍼런스
   * String의 length 메서드는 `String::length`로 표현할 수 있다.
3. 기존 객체의 인스턴스 메서드 레퍼런스
   * Transcation 객체를 할당받은 transaction 지역 변수가 있다면 `transaction::getValue`라고 표현할 수 있다.

```
(1)
람다 - > (args) Class.staticMethod(args)
메서드 레퍼런스 -> Class::staticMethod

ex)
Function<String, Integer> stringToInterger = (String s) -> Integer.parseInt(s);
Function<String, Integer> stringToInterger = Integer::parseInt;

(2)
람다 - > (arg0, rest) -> arg0.instanceMethod(rest)
메서드 레퍼런스 -> ClassName::instanceMethod

ex)
BiPredicate<String<String>, String> contains = (list, element) -> list.contains(element);
BiPredicate<String<String>, String> contains = List::contains;

(3)
람다 -> (args) -> expr.instanceMethod(args)
메서드 레퍼런스 -> expr::instanceMethod
```

### 생성자 레퍼런스
Class::new 처럼 클래스명과 new 키워드를 이용해서 기존 생성자의 레퍼런스를 만들 수 있다. 이것은 정적 메서드의 레퍼런스를 만드는 방법과 비슷하다.

```java
Supplier<Apple> c1 = Apple::new; //디폴트 생성자 Apple()의 생성자 레퍼런스
Apple a1 = c1.get(); // Supplier의 get 메서드를 호출해서 새로운 Apple 객체를 만들 수 있다.
```


```java
Function<Intenger, String> c1 = (weight) -> new Apple(weight); // 특정 무게의 사과를 만드는 람다 포현식
```

## 람다 표현식 조합할 수 있는 유용한 메서드


### Comparator 조합

```java
Comparator<Apple> c = Comparator.comparing(Apple::getWeight);
// 역정렬
Invertory.sort(comparing(Apple:getWeight).reversed()); // 내림 차순 정렬

Invertory
    .sort(comparing(Apple:getWeight).reversed()
    .reversed()
    .thenComparing(Apple::getCountry)); // 두 사과 무게가 같으면 국가 별로 정렬
```


# 함수형 데이터 처리

## 스트림이란 무엇인가?

스트림을 이용하면 선언형, 즉 데이터를 처리하는데 임시 구현 코드 대신에 질의로 표현하는 것으로 컬렉션 데이터를 처리할 수 있다.
또한 스트림을 이용하면 멀티 스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있다.

자바 7 코드
```java
List<Dish> lowCaloriDishes = new ArrayList<>();
for(Dish d : memu){
    if(d.getCalories() < 400){
        lowCaloriDishes.add(d);
    }
}

Collections.sort(lowCaloriDishes, new Comparator<Dish>){ // 익명 클래스로 요리 정렬
    public int compare(Dish d1, Dish d2){
        return Intenger.compare(d1.getCalories(), d2.getCalories());
    }
}

List<String> lowCaloriDishesName = new ArrayList<>();
for(Dish d : memu){
    lowCaloriDishesName.add(d);
}
```
자바 8 코드

```java
List<String> lowCaloriDishesName = memu.parallelStream()
    .filter(d -> d.getCalories() < 400)
    .sorted(comparing(Dishes::getCalories))
    .map(Dish::getName)
    .collect(toList());
```

* 선언형 코드로 구현할 수 있다.
  * 루프와 if 조건문 등의 제어 블록을 사용해서 어떻게 동작을 구현할지 지정할 피룡 없이 `저칼로리의 요리만 선택해라` 같은 동작의 수행을 지정할 수 있다.
  * 즉 기존 코드를 복사하여 붙여 넣는 방식을 사용하지 않고 람도 표현식을 이용해서 저칼로리 대신 고칼로리의 요리만 필터링하는 코드도 쉽게 구현할 수 있다.
  
filter같은 연산은 고수준 빌딩 블록(heigh-level building)으로 이루어져 있음으로 특정 스레드 모델에 제한되지 않고 자유롭게 어떤 상황에서든지 사용할 수있다.

**또한 이들은 내부적으로 단일 스레드 모델에서 사용할 수 있지만 멀티코어 아키텍처를 최대한 투명하게 활용할 수 있도록 구현되어 있다. 결과적으로 우리는 데이터 처리 과정을 병렬화하면서 스레드와 락을 걱정팔 필요가 없어졌다.**

다음 코드로 더욱 간결화할 수 있다. 물론 추가적인 학습이 더 필요 하다

```java
Map<Dish.Type, List<Dish>> dishersByType = memu.stream().collect(groupBy(Dish::getType));
```


## 스트림 시작하기

스트림이란 **[데이터 처리 연산]**을 지원하도록 **[소스]**에서 추출된 **[역속된 요소]**로 정의 할 수있다.

### 역속된 요소
* 컬렉션과 마찬가지로 스트림은 특정 요소 형식으로 이루어진 역속된 값 집합의 인터페이스를 제공한다.
* 스트림은 filter, sorted, map이 계산식을 주로 이룬다. 즉 컬렉션의 주제는 데이터고 스트림의 주제는 계산이다.

### 소스
* 스트림은 컬랙션, 배열, I/O  자원 등의 데이터 제공 소스로부터 데이터를 소비한다. 정렬된 컬렉션으로 스트림을 생성하면 정렬이 그대로 유지된다. 즉 리스트로 스트림을 만들면 스트림 요소는 리스트의 요소와 같은 순서를 유지한다.

### 데이터 처리 연산
* 스트림은 함수형 프로그래밍에서 일반적으로 지원하는 연선과 데이터베이스와 비슷한 연산을 지원한다.
* filter, map, find, match, sort 등으로 데이터를 조작할 수 있다.
* 스트림은 연산은 순차적으로 또는 병렬로 실핼 할 수 있다.

### 파이프 라이닝
대부분의 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프라인을 구성할 수 있도록 스트림 자신을 반환한다. 그 덕분에 lay, 같은 촤적화도 얻을 수 있다. 

### 내부 반복
반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원한다.

```java
List<String> threeHighCaloricDishNames = memu.stream()
        .filter(dish -> dish.getCalories() > 300)
        .map(Dish::getName)
        .limit(3)
        .collect(Collectors.toList());

System.out.println(threeHighCaloricDishNames);
```
1. memu에서 stream 메서드를 호출해서 요리 리스트로 부터 스트림을 얻어 온다.
2. 여기서 데이터 소스는 요리 리스트(메뉴)다. 데이터 소스는 연속된 요소를 스트림에 제공한다.
3. 스트림에 filter, map, limit, collect로 이어지는 일련의 데이터 처리 연산을 적용한다.
4. collect를 호출하기전까지는 menu에 아무것도 선턱되지 않으며, 출력 결과도 없다. **즉 collect가 호출되기 전까지 메서드 호출이 저장되는 효과가 없다.**

#### filter
람다를 인수로 받아 스트림에서 특정 요소를 제외시킨다. 예제에서는 `d -> d.getCalories() > 300` 이라는 람다를 전달해서 300 칼로리 이상의 요리를 선택한다.

#### map
람다를 이용해서 한 요소를 다른 요소로 변환하거나 정보를 추출한다. 예제에서는 메서드 래퍼런스 `Dish::getName` 람다 표현식에서는 `d -> d.getName()` 전달해서 각각의 요리명을 추출한다

#### limit
정해진 개수 이상의 요소가 스트림에 저장되지 못하게 스트림 크기를 축소한다.

#### collect
스트림을 다른 형식으로 변환한다. 

## 스트림과 컬렉션
데이터를 **언제** 계산하느냐가 컬렉션과 스트림의 가장 큰 차이라고 할 수 있다. 컬렉션은 현재 자료구조가 포함된 모든 값을 메모리에 저장하는 자료구조이다. 즉 컬렉션의 모든 요소를 컬렉션에 추가하기전에 계산되어야한다. (컬렉션에 요를 추가하거나 컬렉션의 요소를 삭제할 수 있다. 이런 연산을 수행할 때마다 컬렉션의 몯ㄴ 요소를 메로리에 저장해야 하며 컬렉션에 추가하려는 요소는 미리 계산도어야한다.)

반면 스트림은 이론적으로 요청할 때만 요소를 계한 하는 고정된 자료구조이다.(스트림에서 요소를 추가하거나, 요소를 제가할 수 앖다.) 이러한 스트림의 특성은 프로그래밍에 큰 도움을 준다.

### 외부 반복과 내부반복

컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야한다.(for-each) 이를 외부 반복 이라고 한다. 반면 스트림이라는 라이브러리는 (반복을 알아서 처리하고 결과 스트림값을 어딘가에 저장해주는) 내부 반복을 사용한다.

내부 반복을 사용하면 작업을 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리할 수 있다.

### 스트림 연산

스트림 인터페이스의 연산을 크게 두 가지로 구분할 수 있다. 

```java
List<String> threeHighCaloricDishNames = memu.stream()
            .filter(dish -> dish.getCalories() > 300) // 중간 연산
            .map(Dish::getName) // 중간 연산
            .limit(3) // 중간 연산
            .collect(Collectors.toList()); // 최종 연산
```

#### 중간 연산
filter, sorted같은 중간 연산은 다른 스트림을 반환한다. 따라서 여러 중간 연산을 연결해 질의를 만들 수 있다. 중간 연산의 중요한 특징은 단말 연산을 스트림 파이프라인에서 실행하기 전까지는 아무도 연산도 수행할 수없다는 것이다. **즉 Lay 하다는 것이다. 중간연산을 합친 다음에 합쳐진 중간 연산을 최종 연산으로 한 번에 처리하기 때문이다.**

#### 최종 연산
최종 연산은 스트림 파이프라인에서 결과를 도출한다. 보통 최종 연산에 의해 List, Integer, void 등 스트림 이외의 결과가 반환된다.

## 요약
* 스트림은 소스에 추출된 요소로, 데이터 처리 연산을 지원한다.
* 스트림 내부 반복을 지원한다. 내부 반복은 filter, map, sorted 등의 연산을 반복을 추상화한다
* 스트림에서 중간 연산과 최종 연산이 있다.
* 스트림의 요소는 요청할 때만 계산된다.

# 스트림 활용

## 필터링과 슬라이싱
스트림 요소를 선택하는 방법, 즉 Predicate 필터링, 고유 요소 필터링, 스트림의 일부 요소를 무시하거나 스트림을 주어진 크기로 축소하는 방법을 설명한다.

### Predicate로 필터링
스트림 인터페이스는 fiter 메서드를 지원한다. fiter 메서드는 Predicate를 함수로 받아 Predicate와 칠치하는 모든 요소를 포함하는 스트림을 반환한다. 다음 예제는 채식 요리를 필터링해서 체식 메뉴를 만들 수 있다

```java
List<String> vegetarianMenu = memu.stream()
                .filter(Dish::isVegetarian)
                .collect(toList());
```

### 고유 요소 필터링
스트림은 고유 요소로 이루어진 스트림을 변환하는 `distinct` 라는 메서드도 지원한다.


```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
numbers.stream()
    .filter(i -> i % 2 == 0)
    .distinct()
    .forEach(System.out::println);
```

## 매핑
스트림 API는 map, flatMap 메서드는 트겆 데이터를 선택하는 기능을 제공한다.

### 스트림의 각요소에 함수 적용하기

```java
final List<String> words = Arrays.asList("java8", "cheese", "In");
final List<Integer> collect = words.stream()
        .map(String::length)
        .collect(Collectors.toList());
```
인수로 제공된 함순ㄴ 각 요소에 적용ㄷ히며 함수를 적요한 결과가 새로운 요소로 매핑된다. 이 과정은 기전 값을 고친다라는ㄱ ㅐ념보단 새로운 버전을 만든다는 개념에 가까우므로 변환에 가까운 매핑이라는 단어를 사용한다.

### 검색화 매칭

```java
final boolean isHealthy = memu.stream()
                .allMatch(dish -> dish.getCalories() < 1000);
```

스트림의 모든 요소가 주어진 Predicate와 칠치하는지 검사한다. 

## 리듀싱

스트림 요소를 조합해서 더 복잡한 질의를 표현할 수 있다.

### 모든 요소의 합

```java
 int sum = numbers.stream().reduce(0, (a, b)-> a + b);
```

## 요약
* 스트림 API를 이용하면 복잡한 데이처 처리 질의를 표현할 수 있다.
* filter, distinct, skip, limit 메서드로 스트림 필터링하거나 자를 수 있다.
* findFirst, findAny 메서드로 스트림의 요소를 검색할 수 있다. allMatch, noneMatch, anyMatch 메서드를 이용해서 주어진 Predicate와 일치하는 요소를 스트림에서 검색할 수 있다.

# 스트림으로 데이터 수집

Collect와 컬렉터로 구현할 수 있는 질의 예제이다.

통화별로 트랜잭션을 그룹화한 코드
```java
Map<Currency, List<Transaction>> transcationsByCurrencies = 
    transcations.stream().cellect(groupBy(Transaction::getCurrency));
```

## 컬렉터란 무엇인가?
함수형 프로그래밍에서 `무엇`을 원하는지 직접 명시할 수 이써엇 어던 방법으로 이를 얻을지 신경 쓸 필요가 없다. 이전 예제에서 collect 메서드로 Collector 이너페이스 구현을 전달했다. 

Collector 인터페이스 구현은 스트림 요소를 어떤 식으로 도출할지 지정한다. 여기서는 grouppingBy를 이용해서 `각 키 (통화)와 버킷`그리고 각 키 버킷에 대응하는 요소 리스트를 값으로 포함하는 맵을 만들라는 동작을 수행한다.

### 미리 정의된 컬렉터

Collectors에서 제공하는 메서드의 기능은 크게 사가지로 구분할 수 있다.

1. 스트림 요소를 하나의 값으로 리듀스 하고 요약
2. 요소 그룹화
3. 요소 분활

## 그룹화


```java
// 고기를 포함하는 그룹, 생성을 포함하는 그룹, 나머지 그룹화를 편리하게 할 수 있다.
Map<Dish.DishType, List<Dish>> dishesByType = memu.stream()
        .collect(Collectors.groupingBy(Dish::getType));
```

### 다수준 그룹화

바깥쪽 groupingBy 메서드에서 스트림의 항목을 분류할 두 번째 기준을 정의할 내부 groupingBy를 전달해서 두 수준으로 스트림의 항목을 그룹화 할 수 있다.

```java
Map<Dish.DishType, Map<CaloricLevel, List<Dish>>> dishesByTypeCaloricLevel = memu.stream()
    .collect(
        groupingBy(Dish::getType,
            groupingBy(dish -> {
                if (dish.getCalories() <= 400) {
                    return CaloricLevel.DIET;
                } else if (dish.getCalories() <= 700) {
                    return CaloricLevel.NORMAL;
                } else {
                    return CaloricLevel.DIET;
                }
            })));
```
## 분할
분할은 분할 함수 라불리는 Predicate 분류 함수로 사용하는 특수한 그룹화 기능이다 분활 함수는 불린을 반한하므로 맵의 키 형식은 Boolean 이다 결과적으로 그룹화 맵은 최대 두 개(true or false)의 그룹은 분류된다.

채식 료이와 채식이 아닌 요리로 분류 하는 코드

```java
Map<Boolean, List<Dish>> partitionMemu = memu.stream()
        .collect(partitioningBy(Dish::isVegetarian));
```

### 분할의 장점
**분할 함수가 반환하는 참, 거짓 두 가지 요소의 스트림 리스트를 모두 유지하는 것이 분할의 장점이다.**

## 요약
* collect는 스트림 요소를 요약 결과로 누적하는 다양한 방법을 인수로 갖는 최종 연산이다.
* 스트림의 요소를 하나씩 값으로 리듀스하고 요약하는 컬렉터뿐 아니라 최솟값, 최댓값 평균값을 계산하는 켈렉터 등이 미리 정의도어 있다.
* 미리 정의돈 컬렉터인 groupingBy로 스트림의 요소를 그룹화하거나, partitioningBy로 스트림 요소를 분활 할 수 있다.
* 컬렉터는 다수준의 그룹화, 분할, 리듀싱 연산에 적합하게 설계되어 있다.
* Collector 인터페이스에 정의돈 메서드를 구현해서 커스텀 컬렉터를개발 할 수 있다.

# 병렬 데이처 처리와 성능

