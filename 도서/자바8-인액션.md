![](http://image.kyobobook.co.kr/images/book/xlarge/796/x9788968481796.jpg)


# 목차

# 기초

## 메서드 래퍼런스

자바8에서는 메서드 래퍼런스를 만들어 전달할 수 있게 되었다.

```java
public class FileHidden {

    public void refercenMethod() {
        final File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
            @Override
            public boolean accept(File file) {
                return file.isHidden();
            }
        });
    }
    
    public void refercenMethod2(){
        File[] hiddenFiles = new File(".").listFiles(File::isHidden);
    }
}
```
* 메서드 래퍼런스를 통해서 코드를 심플하게 표현할 수 있다.

## 람다 익명함수


```java
public static boolean isGreenApple(Apple apple) {
        return "green".equals(apple.getColor());
    }

public static boolean isHeavyApple(Apple apple) {
    return apple.getWeight() > 150;
}

public interface Predicate<T> {
    boolean test(T t);
}


public static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {

    final ArrayList<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if (p.test(apple)) {
            result.add(apple);
        }
    }
    return result;
}

@Test
public void test() {
    final List<Apple> apples = new ArrayList<>();
    Apple.filterApples(apples, LambdaSampleCode::isGreenApple);
    Apple.filterApples(apples, LambdaSampleCode::isHeavyApple);
    Apple.filterApples(apples, (Apple a)-> a.getColor().equals("RED"));
}
```
기존에는 메서드를 값으로 전달한다 이런 방식은 유용하지만 각각의 기능들을 만들어야한다. 하지만 자바8에서는 이 문제도 익명함수를 통해(람다함수)간단하게 해결 할 수있다.

한 번만 사용할 메서드는 따로 정의를 구현할 필요가 없이 익명함수를 이용할 수 도 있다. 물론 람다보다는 코드가 수행하는 일을 잘 설명하는 이름을 가진 메섣를 정의하고 위 예제처럼 메서드 레퍼런스를 활용 하는것이 바람직하다. 코드의 명확성이 우선시돠어야 한다.


## 스트림
거의 모든 자바 애플리케이션은 컬렉션들 만들고 활용한다. 하지만 컬렉션으로 모든 문제가 해결되지는 않는다.

```java
Map<Currency, List<Transaction>> transcationByCurrencies = transcations.stream()
    .filtet((Transcation t)-> t.getPrice() > 1000)
    .collect(groupingBy(Transcation::getCurrency));
```
코드의양이 심플해지고 람다식이 익숙해지면 더욱 명확해진다.

## 스트림

### 멀티 스레딩은 어렵다.
자바8은 스트림 API로 컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제, 멀티 코어 활용 어려움 이라는 두 가지 문제를 모두 해결했다.

## 디폴트 메서드

# 동작 파라미터화 코드 전덜하기

 동작 파라미터화를 이용하면 자주 바뀌는 요ㅕ구사항에 효과적으로 대응할 수 있다. 동작 파라미터화란 아직 어떻게 실행할 것인지 결정 하지 않은 코드 블록을 의미한다. 이 코드 블록은 나중에 프로그램에서 호출한다. **즉 코드 블럭의 실행은 나중으로 미뤄진다.** 예를 들어 컬렉션을 처리할 때 다음과 같은 메서드들로 구현한다고 가정하자.

* 리스트의 모든 요소에 `어떤 동작`을 수행할 수 있음
* 리스트 관련 작업을 끝낸 다음에 `어떤 다른 동작`을 수행할 수있음
* 에러가 발생하면 `정해진 어떤 다른 동작`을 수행할 수 있음

## 요약
* 동작 파라미터화에서는 메서드 내부적으로 다양한 동작을 수행할 수 있도록 코드를 메서드 인수로 전달한다.
* 동작 파라미터화를 이용하면 변화는 요구사항에 더 잘 대응할 수 있는 코드를 구현할 수 있으며 나중에 엔지니어링 비용을 줄일 수 있다,
* 코드 전달 기법을 이ㅛㅇ하면 동작 메서드의 인수로 전달할 수 있다. 하지만 자바 8 이전에서는 코드를 지저분하게 구현했어야했다. 이런것을 익명 클래스로 어느정도 코드를 깔금하게 제공
  
# 람다 표현식

## 람다란 무엇인가?
람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화 한 것이라고 할 수있다. 람다 표현식에는 이름은 없지만, 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트는 가질 수 있다.

* 익명 : 보통의 메서드와는 달리 이름이 없으므로 **익명**이라는 표현한다. 구현해야 할 코드에 대한 걱정거리가 줄어든다.
* 함수 : 람다는 메서드 처럼 특정 클래스에 족동되지 않으 함수라고 부른다. 하지만 메서드처럼 파라미터 리스트 바디, 변환 형식, 가능한 예외 리스트를 포함한다.
* 전달 : 람다 ㅍ현식을 메서드 인수로 전달하거나 변수로 지정할 수 있다.
* 간결성 : 익명 클래스처럼 많은 자질구레한 코드를 구현할 필요가 없다.

```java
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
```
* 파라미터 리스트 : `(Apple a1, Apple a2)`
* 화살표 : 화살표 (->)는 람다의 파라미터 리스트와 바디를 구분한다.
* 람다의 바디 : `a1.getWeight().compareTo(a2.getWeight());` 람다의 반환값에 해당하는 표현식이다.

## 형식 검사, 형식 추론 제약
람다 표현식 자체에는 람다가 어떤 함수형 인터페이스를 구현하는지의 정보가 포함되어 있지 않다. 따라 람다 표현식 더 제대로 이해하려면 람다의 실제 형식을 파악해야 한다.

### 형식 검사
람다가 사용되는 Context를 이용해서 람다의 Type을 추론할 수 있다. 어떤 Context(예를 들면 람다가 전달될 메서드 파라미터나 람다가 할당되는 변수등)에서 기대되는 람다 표현식으로 형식을 대상 형식 이라고 부른다.

다음 쿼드의 형식 확인 과정을 보여준다. 다음과 같은 순서로 형식 확인 과정이 진행된다.
```java
List<Apple> haavierThan150g = filter(inventory, (Apple e) -> a.getWeight() > 150);
```

1. filter 메서드의 선언을 확인한다.
2. filter 메서드 두 번째 파라미터로 `Predicate<Apple>` 형식(대상 형식)을 기대한다.
3. `Predicate<Apple>`은 test라는 한 개의 추상 메서드를 정의하는 함수형 인터페이스다.
4. `test` 메서드는 `Apple`을 받아 `boolean`을 반환하는 함수 디스크립터를 묘사한다.
5. `filter` 메서드로 전달된 인수는 이와 같은 요구사항을 만족해야 한다.

```
1.람다가 사용된 콘텍스트는 무엇인지 확인하기 위해서 filter의 정의를 확인 한다.  filter(inventory, (Apple e) -> a.getWeight() > 150);

2. 대상 형식은 Predicate<Apple> 이다(T는 Apple로 대치됨) filter(List<Apple> inventory, Predicate<Apple> p)

3. Predicate<Apple> 인터페이스의 추상메서드는 무엇인가? boolean test(Apple apple)

4. Apple을 인수로 받아 boolean을 반환하는 test 메서드다. Apple -> boolean
```

### 같은 람다, 다른 함수형 인터페이스
대상 형식 이라는 특성 때문에 같은 람다 표현식이더라도 호환되는 추상 메서드를 가진 다른 함수형 인터페이스로 사영될 수 있다.

### 지역 변수 사용
람다 표현식에서는 익명 함수가 하는 것처럼 자우 변수를 활용 할 수있다. 이 와 같은 동작을 람다 캡처링이라고 부른다.

```java
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);
```
하지만 자유 변수에도 약간의 제약이 있다. 람다는 인스턴스 변수와 정적 변수를 자유롭게 캡처(자신의 바디에서 참조할 수 있도록) 할 수 있다. **하지만 그러면 지역 변수는 명시적으로 final로 선언된 변수와 똑같이 사용되오야 한다.**

예를 들어 다음 에제는 portNumber에 값을 두 번할당하므로 컴파일할 수 없는 코드다.

```java
int portNumber = 1337;
Runnable r () -> System.out.println(portNumber);
portNumber = 31337;
```

### 지역 변수의 제약
왜 지역 변수에 이런 제약이 필요한지에 대한 설명이다. 우선 내부적으로 인스턴스 변수와 지역 변수는 태생부터가 다르다. 인스턴스 변수는 힙에 저장되는 반면 지역 변수는 스택에 위치한다. 

람다에서 지역 변수에 바로 접근할 수 있다는 가정에 하에 람다가 스레드에서 실행된다면 변수를 할당한 스레드가 사라져서 변수 할당이 해제되었는데도 람다를 실행하는 스레드에서 해당 변수에 접근하려 할 수 있다. 따라사 자바 구현에서 원래 변수에 접근을 허용하는 것이 아니라 자유 지역 변수의 복사본을 제공한다. 따라서 복사본의 값이 바뀌지 않아야 하므로 지역 변수에 한 번만 값을 할당 해야한다는 제약이 생긴 것이다.

또한 지역 변수에 제약 때문에 외부 변수를 변화시키는 일반적인 명령형 프로그래밍 패턴에 제동을 걸 수 있다.

지역 변수 값은 스택에만 존재하므로 자신을 정의한 스레드와 생존을 같이 해야 하며 따라서 지역 변수는 final 이어야 한다. 가변 지역 변수를 새로운 스레드에서 캡처할 수 있다면 안전하지 않은 동작을 수행할 가능성이 생긴다(인스턴스 변수는 스레드가 공유하는 힙에 존재하므로 특별한 제약이 없다)

### 메서드 레퍼런스
메서드 레퍼런스를 이용하면 기존 메서드 정의를 재활용해서 람다처럼 전달할 수 있다. 때로는 람다 표현식보다 메서드 레퍼런스를 사용하는 것이 더 가독성이 좋으며 자연스러울 수 있다. 다음은 메서드 레퍼런스와 새로운 자바 8 API를 활용한 정렬 예제다.

```java
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));

// 메서드 레퍼런스와 Comparator.comparing를 활용한 코드
inventory.sort(comparing(Apple::getWeight)); // 첫 번째 메서드 래퍼런스!
```

### 메서드 레퍼선스를 만드는 방법

1. Static 메서드 레퍼런스
   * Interger의 parseInt 메서드 `Integer::parseInt`로 표현할 수 있다.
2. 다양한 형식의 인스턴스 메서드 레퍼런스
   * String의 length 메서드는 `String::length`로 표현할 수 있다.
3. 기존 객체의 인스턴스 메서드 레퍼런스
   * Transcation 객체를 할당받은 transaction 지역 변수가 있다면 `transaction::getValue`라고 표현할 수 있다.

