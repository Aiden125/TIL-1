# 트랜잭션

트랜잭션이란 쉽게 말해 연속된 여러 액션을 한 단위의 작업으로 뭉뚱그린 겁니다. 이 액션 뭉치는 전체가 완전히 끝나든지, 아니면 아무런 영향도 미치치 않아야 합니다. 모든 액션이 제대로 잘 끝나면 트랜잭션을 영구 커밋되지만 하나라도 잘됫되면 애초에 아무 일도 없던 거처럼 초기 상태로 롤뱁됩니다.

* 원자성 : 트랜잭션은 연속적인 액션들로 이루어진 원자성 작업입니다. 트랜잭션의 액션은 전부다 수행되거나 아무것도 수행되지 않도록 보장합니다.
* 일관성 : 트랜잭션의 액션이 모두 완료되면 커밋되고 데이터 및 리소스는 비지니스 규칙에 맞게 일관된 상태를 유지합니다.
* 격리성 : 동잉한 데이터를 여러 트랜잭션이 동일하게 처리할 경우 데이터가 변질되지 않게 하려면 각각의 트랜잭션을 격리 해야합니다.
* 지속성: 트랜잭션 완료 후 그 결과는 설령 시스템이 실패하더라도 살아남아야합니다.보통 트랜잭션 결과물을 퍼시턴스 저장소에 씌어집니다.


## 트랜잭션 격리 속성 

* 오염된 읽기: T2가 수정후 커밋하지 않은 필드를 T1이 읽는 사황에서 나중에 T2가 롤백되면 T1이 읽은 필드는 일시적인 값으로 더이상 유효하지 않습니다.
* 재현 불가한 읽기: 어떤 필들를 T1이 읽은 후 T2가 수정할 경우, T1이 같은 필드를 다시 읽으면 다른 값을 얻습니다.
* 허상 읽기: T1이 테이블 로우 몇 개를 읽은후 T1가 같은 테이블에 새로운 로우를 삽입할 경우 나중에 T1이 같은 테이블을 다시 읽으면 T2가 삽입한 러우라 보입니다.
* 소실된 수정: T1, T2 모두 어떤 로우를 수정하려고 읽고 그 로우의 상태에 따라서 수정하려는 경우입니다. T1이 먼저 로우를 수정 후 커밋하기 전 T2가 T1이 수정한 로우를 똑같이 수정했다면 T1이 커밋한 후에 T2 역시 커밋을하게 될텐데 그러면 T1이 수정한 로우를 T2가 엎어쓰기데 외어 T1이 수정한 내용이 소실됩니다.

이론적으로 이런 저수준의 문제를 예방하려면 트랜잭션을 서로 완전히 격리 하면 되겠지만 그렇게 하면 트랜잭션을 한 줄로 세워놓고 하나씩 실행하는 꼴이라서 엄청난 성능 저하가 유하게 됩니다. **실무에서는 성능을 감안하여 트랜잭션 격리 수준을 낮추는 게 제일 일반적입니다.**


격리 수준 | 설명
------|---
DEFAULT | DB 기본 격리 수준을 사용합니다.
READE_UNCOMMITED | 다른 트랜잭션이 아직 커밋하지 않은 값을 한 트랜잭션이 읽을 수 있습니다. 따라서 오염된 읽기, 재현 불가한 읽기, 허상 읽기 문제가 발생할 가능성이 있습니다.
READE_COMMITED | 한 트랜잭션이 다른 트랜잭션이 커밋한 값만 읽을수 있습니다. 이로써 오염된 값 읽기 문제는 해결되지만 재현 불가한 읽기, 허상 읽기 문제는 여전히 남습니다.
REPEATABLE_READ | 트랜잭션이 어떤 필드를 여러번 읽어도 동일한 값을 읽도록 보장합니다. 트랜잭션이 지속되는 동안 다른 트랜잭션이 해당 필드를 변경할수 없습니다. 오렴된 값 읽기, 재현 불가한 읽기 문제는 해결되지만 허상 읽기는 여전히 남습니다.
SEPIALIZABLE | 트랜잭션이 테이블을 여러 번 읽어도 정확히 동일한 로우를 읽도록 보장합니다. 트랜잭션이 지속되는 동안에는 다른 트랜잭션이 해당 테이블에 삽입, 수정, 삭제를 할 수 없습니다. 동시성 문제는 모두 해소괴지만 성능이 현저히 떨어집니다.


### READE_UNCOMMITED, READE_COMMITED 격리


문제 시나리오
1. 스레드 1이 도서 재고를 늘리고 스레드 슬립, 아직 롤백되지 않은 상태
2. 스레드 1이 슬립일 동안 스레드 2가 시작되고 도서 재고를 읽음
3. 스레드 2는 스레드 1의 트랜잭션이 아직 변경 후 커밋하지 않은 재곳값을 그래로 읽습니다. 
4. 스레드 1이 꺠어나면서 RuntimeException 때문에 트랜잭션이 롤백되고 스레드 2가 읽은 값은 더이상 유효하지 않은 일시적인 값이됨. 트랜잭션이 읽어들인 값이 오염되었다 해서 오염된 값읽기 문제라고 함

해결 시나리오
1. 스레드 1이 도서 재고 늘리고 슬립
2. 스레드 2가 스레드 1이 트랜잭션 롤백하기 전까지는 재고값을 읽을 수 없음
3. 오염된 값 읽기 문제는 한 트랜잭션이 아직 커밋하지 않은 값을 다른 트랜잭션이 읽지 못하게 차단함으로써 방지할 수 있습니다.

### REPEATABLE_READ 격리 수준
스레드 1 도서 재고 체크 작업
스레드 2 재고 늘리는 작업

문제
1. 처음 스레드는 1이 도서 재고를 체크하고 슬립합니다. 이때 스레드 1의 트랜잭션은 아직 커밋되지 않은 상태입니다.
2. 스레드 1이 슬립 동안 스레드 2가 시작되어 도서 재고를 늘립니다.
3. 격리 수준이 READE_COMMITED 이므로 스레드 2는 아직 커밋되지 않은 트랜잭션이 읽은 재고값을 수정할 수 있습니다.
4. 그러나 스레드 1이 께어나고 재고를 다시 읽으면 그 값은 이미 처음에 읽은 값이 아닙니다. 이것이 바로 재현 불가한 읽기 문제 이며 한 트랜잭션이 동일한 필드를 다른 값으로 읽어드리므로 모순이 발생합니다.

해결
스레드2는 스레드1이 트랜잭션 커밋하기 전까지 재곳값을 수정할 수 없습니다. 이 처럼 재현 불가한 읽기는 커밋되지 않은 트랜잭션이 읽은 값을 다른 트랜잭션이 수정하지 못하게 차단함으로써 방지할 수 있습니다.

### SEPIALIZABLE 격리 수준
트랜잭션 1이 테이블에서 여러 로우를 읽은 후, 트랜잭션 23가 같은 테이블에 여러 로우를 새로 추가할 경우

트랜잭션 1이 같은 테이블을 다시 릭으면 자신이 처음 읽었을 때 와 달리 새로 추가된 로우가 있음을 감지합니다. 이를 허상 읽기 무넺라고 합니다. 사실 허상 일기는 여러 로우가 연관되이있는 점만 빼면 재현 불가한 읽기 문제와 비슷합니다.

허상 읽기 문제까지 해결하려면 최고 격리 수준 SEPIALIZABLE으로 올려야합니다. 이렇게 설정하면 전체 테이블에 읽기 잠금을 걸기 때문에 실행 속도는 가장 느립니다. 실우메어는 요건을 충족하는 가장 낮은 수준으로 격리 수준을 선택하는 게 좋습니다.


# 참고
* 스프링 레시피5