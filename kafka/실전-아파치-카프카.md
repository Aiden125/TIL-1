> 해당 글은 [실전 아파치 카프카](http://www.hanbit.co.kr/media/books/book_view.html?p_code=B8503179529)를 보고 정리한 내용 입니다.

# 아파치 카프카 개요

## 아파치 카프카
아파치 카프카는 여러 대의 분산 서버에서 대량의 데이터를 처리하는 분산 메시징 시스템이다. 메시지(데이터)를 받고, 받은 메시지를 다른 시스템이나 장치에 보내기 위해 사용된다.

카프카는 대량의 데이터를 **높은 처리량**과 **실시간**으로 취급하기 위한 제품으로 다음 4가지를 실현할 수 있다.
1. 확장성: 여러 서버로 확장 구성을 할수 있기 때문에 데이터 양에 따라 시스템 확장이 가능하다.
2. 영속성: 수신한 데이터를 **디스크에 유지**할수 있기 때문에 언제라도 데이터를 읽을 수 있다.
3. 유연성: 연계할 수 있는 제품이 많기 때문에 제품이나 시스템을 연결하는 허브 역할을 한다.
4. 신뢰성: **메시지 전달 보증**을 하므로 데이터 분실 걱정하지 않아도 된다.

카프카는 원래 높은 처리량으로 데이터를 실시간 처리하는 처리 성능에 초점을 두었고, 이후 기능과 신뢰성을 향샹시켜 현재는 종합 스트림 처리를 위한 플랫폼이 되고 있다.

## 카프카로 요구사항 시렿하기
기존 링크드인의 요구사항을 총족시키지 못했기 때문에 카프카 개발을 시작하게 되었다. 해당 요구사항은 다음과 같다.

요구 사항
1. 높은 처리량으로 실시간 처리한다.
2. 임이의 타이밍에 데이터를 읽는다.
3. 다양한 제품과 시슽메에 쉽게 연동한다.
4. 메시지를 읽지 않는다.

실현 수단
1. 메시징 모델과 스케일 아웃형 아키텍처
2. 디스크로의 데이터 영속화
3. 이해하기 쉬운 API 제공
4. 전달 보증

### 메시지 모델과 스케일 아웃
카프카에서는 다음과 같은 요구 사항을 만족시켜야 했다.

1. 높은 처리량으로 실시간 처리한다.
2. 임이의 타이밍에 데이터를 읽는다.
3. 다양한 제품과 시스템에 쉽게 연동한다.

이러한 여구 사항을 해결 하기 위해 카프카에서는 메시징 모델을 채용 했다. 일반적으로 메시징 모델은 다음 세가지 요소로 구성된다.

* Producer: 메시지 생산자
* Brokcer: 메시지 수집/전달 역할
* Consumer: 메시지 소비자

![](../assets/message-model.png)
카프카 메시징 모델을 설명하는데 있어 기존의 메시징 모델인 큐잉 모델과 Publish/Subscribe 메시징 모델 두 가지 모델을 먼저 보자. **카프카는 이 둘의 특증을 겸비한 셩태로 만들어 졌다**

#### 큐잉 모델
브로커 안에 큐를 준비해, 프로듀서에서 메시지가 큐에 담기고, 컨슈머가 큐에서 메시지를 추출한다. 하나의 큐에 대해 컨슈머가 여러개 존재하는 것을 생각할 수 있다. 이 모델은 컨슈머를 여러 개 준비함으로써 컨슈머에 의한 처리를 확장 시킬 수 있이며, 컨슈머가 메시지를 받으면 다른 컨슈머는 메시지를 받을 수 없다.

![](../assets/queueing.png)
* 큐에서 여러 개의 컨슈머가 메시지를 추출할 수 있어 컨슈머에 의한 처리가 병렬로 가능하다.
* 큐에서 추출된 메시지는 컨슈머에 도달하면 사라진다. 즉 하나의 메세지는 여러 컨슈머 중 어느 하나에서 처리한다.


#### 펍/섭 메시징 모델
메시지 생산자를 프로듀서를 퍼플리셔, 메시지 소비자의 해당 컨슈머를 서브스크라이버 라고 한다.

**퍼블리셔가 서브스크라이브에게 직접 메시지를 보내는 것이 아니라 브로커를 통해 전달한다.** 퍼블리셔는 누가 메세지를 수신하는지 알수 없고 브로커에 있는 토픽이라고 불리는 카테고리 안에 메시지를 등록 시킨다.

한편 서브스크라이버는 여러 개 존재하는 톡픽 중 하나를 선책하여 메시지를 받는다. 여러 서브스크라이버가 동일한 토픽을 구독하기로 결정한다면, 이 여러 서브스크라이버는 동일한 메시지를 받는다.

![](../assets/pub-subscriberpng.png)
* 서브스크라이버는 브로커 내의 토픽에서 자신이 흥미 있는 것을 선택한다.
* **큐잉 모델과 달리 같은 토픽을 구독하는 여러 서브스크라이버에게는 동일한 메시지가 전달된다.**

서브 스크라이버는 여러 개 존재하는 토픽 중 하나를 선택하여 메시지를 받는다. 여러 서브스크라이버가 동일한 토픽을 **구독하기로 결정한다면, 이 여러 서브스크라이버는 동일한 메시지를 받는다.**

#### 프로듀서/컨슈머 사이의 브로커를 끼우는 장점
큐잉 모델이든, 펍/섭 메시징 **모델이든 모두 브로커를 사이에 끼우는 형태이다.** 이 모델을 이용하면 변경에 강한 시스템 아키턱처를 만들 수 있다느 장점이 있다.

***프로듀서/컨슈머 모두 접속처를 하나로 할 수 있다.***
프로듀서는 누구에게 메세지를 전동하면 좋을지 생각할 필요 없이 브로커로 보내기만 하면 된다. 마찬 가지로 컨슈머도 단순히 브로커에서만 수신하면 된다.

***프로듀서/컨슈머 증감에 대응 할 수 있다.***
**프로듀서/컨슈머 모두 서로의 존재를 몰라도 되기 때문에 증감에 유연하게 대응할 수 있다.** 프로듀서를 증가시키려면 브로커에만 접속하면 되고, 컨슈머도 접속하려면 새로운 수신을 시작할 수 있다.


### 카프카 메시징 모델
카프카에서는 큐잉 모델에서 실현한 **여러 컨슈머가 분산 처리로 메세지를 소비**하는 모델과 펍/섭 메시징 모델에서 실현한 **여러 서브스크라이버에 동일한 메세지를 전달하고, 토픽 기반으로 전달 내용을 변경** 하는 모델로 되어 있다. 이 모델을 실현 하기 위해 컨슈머 그룹 이라는 개념을 도입 하여 컨슈머를 확장 구성할 수 있도록 설계계 하고 있다.